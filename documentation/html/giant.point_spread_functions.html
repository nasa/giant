<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>giant.point_spread_functions &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=51b770b3"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="_static/logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="giant.point_spread_functions.psf_meta" href="point_spread_functions/giant.point_spread_functions.psf_meta.html" />
    <link rel="prev" title="OpNavImage.parse_data" href="image/giant.image.OpNavImage.parse_data.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="giant.html">API Reference</a><ul>
      <li>Previous: <a href="image/giant.image.OpNavImage.parse_data.html" title="previous chapter">OpNavImage.parse_data</a></li>
      <li>Next: <a href="point_spread_functions/giant.point_spread_functions.psf_meta.html" title="next chapter">giant.point_spread_functions.psf_meta</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="image/giant.image.OpNavImage.parse_data.html" title="Previous document">OpNavImage.parse_data</a>
        </li>
        <li>
          <a href="point_spread_functions/giant.point_spread_functions.psf_meta.html" title="Next document">giant.point_spread_functions.psf_meta</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="module-giant.point_spread_functions">
<span id="giant-point-spread-functions"></span><h1>giant.point_spread_functions<a class="headerlink" href="#module-giant.point_spread_functions" title="Link to this heading">¶</a></h1>
<p>This package provides classes for creating/using point spread function is GIANT.</p>
<p>In GIANT a Point Spread Function (PSF) represents the way a camera spreads out light from a point source across multiple
pixels.  This is analogous to the modulation transfer function (MTF) but in the spatial domain instead of the frequency
domain.</p>
<p>PSFs are used extensively throughout GIANT.  They are used to locate the centroid of stars and unresolved objects in
<a class="reference internal" href="giant.stellar_opnav.html#module-giant.stellar_opnav" title="giant.stellar_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stellar_opnav</span></code></a>, <a class="reference internal" href="relative_opnav/estimators/giant.relative_opnav.estimators.unresolved.html#module-giant.relative_opnav.estimators.unresolved" title="giant.relative_opnav.estimators.unresolved"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unresolved</span></code></a>, and <a class="reference internal" href="giant.calibration.html#module-giant.calibration" title="giant.calibration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration</span></code></a>.  They are also used in <a class="reference internal" href="giant.relative_opnav.html#module-giant.relative_opnav" title="giant.relative_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">relative_opnav</span></code></a> to
“blur” templates to make them more closely resemble what is actually captured by the camera before attempting
cross-correlation.</p>
<p>There are many different ways to model PSFs for cameras, but one of the most popular and common is to use a
2D Gaussian function.  Giant provides implementations for using Gaussian functions as the PSF in classes
<a class="reference internal" href="#giant.point_spread_functions.Gaussian" title="giant.point_spread_functions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gaussian</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian" title="giant.point_spread_functions.GeneralizedGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedGaussian</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeGaussian" title="giant.point_spread_functions.IterativeGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeGaussian</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeGeneralizedGaussian" title="giant.point_spread_functions.IterativeGeneralizedGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeGeneralizedGaussian</span></code></a>,
<a class="reference internal" href="#giant.point_spread_functions.IterativeGaussianWBackground" title="giant.point_spread_functions.IterativeGaussianWBackground"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeGaussianWBackground</span></code></a> and <a class="reference internal" href="#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground" title="giant.point_spread_functions.IterativeGeneralizedGaussianWBackground"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeGeneralizedGaussianWBackground</span></code></a>.
These fully implemented classes can generally be used as is throughout GIANT for most cameras.  In some cases however a
camera may have a PSF that is not well modeled by a Gaussian function, in which case, the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">point_spread_functions</span></code> module provides some abstract base classes and common
functionality that can make creating a new PSF easier.</p>
<p>If you are just starting out, we recommend that you begin with one of the provided PSF models as these are generally
sufficient and are easy to use.</p>
<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">PointSpreadFunction</span></span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction" title="Link to this definition">¶</a></dt>
<dd><p>This abstract base class serves as the template for implementing a point spread function in GIANT.</p>
<p>A point spread function models how a camera spreads out a point source of light across multiple pixels in an image.
GIANT uses PSFs both for making rendered templates more realistic for correlation in <a class="reference internal" href="giant.relative_opnav.html#module-giant.relative_opnav" title="giant.relative_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">relative_opnav</span></code></a> and for
centroiding of stars and unresolved bodies for center finding (<a class="reference internal" href="relative_opnav/estimators/giant.relative_opnav.estimators.unresolved.html#module-giant.relative_opnav.estimators.unresolved" title="giant.relative_opnav.estimators.unresolved"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unresolved</span></code></a>), attitude estimation
(<a class="reference internal" href="giant.stellar_opnav.html#module-giant.stellar_opnav" title="giant.stellar_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stellar_opnav</span></code></a>), and camera calibration (<a class="reference internal" href="giant.calibration.html#module-giant.calibration" title="giant.calibration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration</span></code></a>).</p>
<p>In general, a PSF class is assigned to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">ImageProcessing.psf</span></code> attribute and an initialized version of the
class is assigned to the <a class="reference internal" href="camera/giant.camera.Camera.html#giant.camera.Camera.psf" title="giant.camera.Camera.psf"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Camera.psf</span></code></a> attribute.  GIANT will then use the specified PSF wherever it is
needed. For more details refer to the <a class="reference internal" href="#module-giant.point_spread_functions" title="giant.point_spread_functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">point_spread_functions</span></code></a> package documentation.</p>
<p>This class serves as a prototype for implementing a PSF in GIANT.  It defines all the interfaces that GIANT expects
for duck typing as abstract methods and properties to help you know you’ve implemented everything you need.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because this is an ABC, you cannot create an instance of this class (it will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>)</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.apply_1d">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">apply_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.apply_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.apply_1d" title="Link to this definition">¶</a></dt>
<dd><p>Applies the defined PSF using the stored parameters to the 1D image scans provided.</p>
<p><code class="docutils literal notranslate"><span class="pre">image_1d</span></code> can be a 2D array but in that case each row will be treated as an independent 1D scan.</p>
<p>For non-symmetric PSFs, a <code class="docutils literal notranslate"><span class="pre">direction</span></code> argument can be supplied which should be the direction in the image of
each scan line.  This can be used to determine the appropriate cross-section of the PSF to use for applying to
the 1D scans (if applicable).  If no direction is provided then the x direction [1, 0] is assumed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_1d</strong> (<em>ndarray</em>) – The scan line(s) to be blurred using the PSF</p></li>
<li><p><strong>direction</strong> (<em>ndarray</em><em> | </em><em>None</em>) – The direction for the 1D cross section of the PSF.  This should be either None, a length 2
array, or a shape nx2 array where n is the number of scan lines</p></li>
<li><p><strong>step</strong> (<em>float</em>) – The step size of the lines being blurred.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an array containing the input after blurring with the defined PSF</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.centroid">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centroid</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.centroid" title="Link to this definition">¶</a></dt>
<dd><p>This should return the centroid or peak of the initialized PSF as a x, y length 2 numpy array.</p>
<p>This property is used to enable the PSF class to be used in identifying the center of
illumination in image processing (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">ImageProcessing.centroiding</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.compare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.compare" title="Link to this definition">¶</a></dt>
<dd><p>For real PSFs, this method generates how well the PSF matches another between 0 and 1, with 1 being a perfect
match and 0 being a horrible match.</p>
<p>Typically this is evaluated as the clipped pearson product moment coefficient between the kernels of the 2 psfs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<em>Self</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.covariance">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.covariance" title="Link to this definition">¶</a></dt>
<dd><p>This should return the formal covariance of the PSF parameters (if the PSF was fit and not initialized).</p>
<p>If the PSF is not the result of a fit or the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.save_residuals" title="giant.point_spread_functions.PointSpreadFunction.save_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code> this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.evaluate">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>This method evaluates the PSF at the given x and y.</p>
<p>This method is not intended to be used to apply the PSF for an image (use the callable capability of the class
instead for this).  Instead it simply computes the height of the PSF above the xy-plane at the requested
locations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x locations the height of the PSF is to be calculated at.</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y locations the height of the PSF is to be calculated at.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array containing the height of the PSF at the requested locations the same shape as x and y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.fit">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.fit" title="Link to this definition">¶</a></dt>
<dd><p>This function fits the defined PSF to the input data and returns an initialize version of the class based on the
fit.</p>
<p>The fit assumes that z = f(x, y) where f is the PSF (and thus z is the “height” of the PSF).</p>
<p>If the fit is unsuccessful then this should set the attributes of the PSF to NaN to indicate to the rest of
GIANT that the fit failed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the PSF that best fits the provided data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.generate_kernel">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_kernel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.generate_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.generate_kernel" title="Link to this definition">¶</a></dt>
<dd><p>Generates a square kernel centered at the centroid of the PSF normalized to have a volume (sum) of 1.</p>
<p>Essentially this evaluates <span class="math notranslate nohighlight">\(z = f(x, y)\)</span> for x in <span class="math notranslate nohighlight">\([x_0-size//2, x_0+size//2]\)</span> and y in
<span class="math notranslate nohighlight">\([y_0-size//2, y_0+size//2]\)</span> where x0 is the x location of the centroid of the PSF and y0 is the y
location of the centroid of the PSF.</p>
<p>The resulting values are then normalized to sum to 1 so that the result can be applied using convolution
without changing the overall signal level.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A normalized kernel of the PSF centered at the centroid</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.residual_mean">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">residual_mean</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.residual_mean" title="Link to this definition">¶</a></dt>
<dd><p>This should return the mean of the post-fit residuals from fitting this PSF to the data.</p>
<p>If the PSF is not the result of a fit or the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.save_residuals" title="giant.point_spread_functions.PointSpreadFunction.save_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code> this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.residual_rss">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">residual_rss</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.residual_rss" title="Link to this definition">¶</a></dt>
<dd><p>This should return residual sum of squares (RSS) of the post-fit residuals from fitting this PSF to the data.</p>
<p>If the PSF is not the result of a fit or the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.save_residuals" title="giant.point_spread_functions.PointSpreadFunction.save_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code> this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.residual_std">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">residual_std</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.residual_std" title="Link to this definition">¶</a></dt>
<dd><p>This should return the standard deviation of the post-fit residuals from fitting this PSF to the data.</p>
<p>If the PSF is not the result of a fit or the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.save_residuals" title="giant.point_spread_functions.PointSpreadFunction.save_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code> this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.save_residuals">
<span class="sig-name descname"><span class="pre">save_residuals</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.save_residuals" title="Link to this definition">¶</a></dt>
<dd><p>This class attribute specifies whether to save the residuals when fitting the specified PSF to data.</p>
<p>Saving the residuals can be important for in depth analysis but can use a lot of space when many fits are being 
performed and stored so this defaults to off.  To store the residuals simply set this to <code class="docutils literal notranslate"><span class="pre">True</span></code> before 
initialization.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.shift_centroid">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shift_centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.shift_centroid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.shift_centroid" title="Link to this definition">¶</a></dt>
<dd><p>Shift the centroid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shift</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – the shift to apply as a len array like x, y</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.PointSpreadFunction.volume">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#PointSpreadFunction.volume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.PointSpreadFunction.volume" title="Link to this definition">¶</a></dt>
<dd><p>This should compute the total volume contained under the PSF.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total volume contained under the PSF</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.SizedPSF">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">SizedPSF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#SizedPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.SizedPSF" title="Link to this definition">¶</a></dt>
<dd><p>This ABC adds common functionality for a PSF where the required size can be determine algorithmically.</p>
<p>Specifically, this adds an instance attribute <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.size" title="giant.point_spread_functions.SizedPSF.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a> which stores the size of the PSF,
a new abstract method <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.determine_size" title="giant.point_spread_functions.SizedPSF.determine_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">determine_size()</span></code></a> which should be implemented to algorithmically determine the size of
the kernel required for the PSF, and concrete method <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.generate_kernel" title="giant.point_spread_functions.SizedPSF.generate_kernel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_kernel()</span></code></a>, which generates a square unit kernel
based on the <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.size" title="giant.point_spread_functions.SizedPSF.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> (<em>int</em><em> | </em><em>None</em>) – The size of the kernel to generate.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.SizedPSF.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#SizedPSF.compare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.SizedPSF.compare" title="Link to this definition">¶</a></dt>
<dd><p>For real PSFs, this method generates how well the PSF matches another between 0 and 1, with 1 being a perfect
match and 0 being a horrible match.</p>
<p>Typically this is evaluated as the clipped pearson product moment coefficient between the kernels of the 2 psfs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.PointSpreadFunction.html#giant.point_spread_functions.psf_meta.PointSpreadFunction" title="giant.point_spread_functions.psf_meta.PointSpreadFunction"><em>PointSpreadFunction</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.SizedPSF.determine_size">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">determine_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#SizedPSF.determine_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.SizedPSF.determine_size" title="Link to this definition">¶</a></dt>
<dd><p>Sets the size required for the kernel algorithmically.</p>
<p>Typically this is based on the width of the PSF.</p>
<p>The determined size should be stored in the instance attribute <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.size" title="giant.point_spread_functions.SizedPSF.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.SizedPSF.generate_kernel">
<span class="sig-name descname"><span class="pre">generate_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#SizedPSF.generate_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.SizedPSF.generate_kernel" title="Link to this definition">¶</a></dt>
<dd><p>Generates a square kernel centered at the centroid of the PSF normalized to have a volume (sum) of 1 for the
size input or specified in the <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.size" title="giant.point_spread_functions.SizedPSF.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a> attribute.</p>
<p>Essentially this evaluates <span class="math notranslate nohighlight">\(z = f(x, y)\)</span> for x in <span class="math notranslate nohighlight">\([x_0-size//2, x_0+size//2]\)</span> and y in
<span class="math notranslate nohighlight">\([y_0-size//2, y_0+size//2]\)</span> where x0 is the x location of the centroid of the PSF and y0 is the y
location of the centroid of the PSF.</p>
<p>The resulting values are then normalized to sum to 1 so that the result can be applied using convolution
without changing the overall signal level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> (<em>int</em><em> | </em><em>None</em>) – The size of the kernel to generate (ie return a (size, size) shaped array).  Overrides the
<a class="reference internal" href="#giant.point_spread_functions.SizedPSF.size" title="giant.point_spread_functions.SizedPSF.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a> attribute.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A normalized kernel of the PSF centered at the centroid</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.SizedPSF.size">
<span class="sig-name descname"><span class="pre">size</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#giant.point_spread_functions.SizedPSF.size" title="Link to this definition">¶</a></dt>
<dd><p>The size of the kernel to return on a call to <a class="reference internal" href="#giant.point_spread_functions.SizedPSF.generate_kernel" title="giant.point_spread_functions.SizedPSF.generate_kernel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_kernel()</span></code></a>.</p>
<p>Typically this should be an odd number to ensure that the kernel is square and centered.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSF">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">InitialGuessIterativeNonlinearLSTSQPSF</span></span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#InitialGuessIterativeNonlinearLSTSQPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSF" title="Link to this definition">¶</a></dt>
<dd><p>This class provides a fit class method which generates the initial guess from a subclass and then converges to a
better solution using iterative Nonlinear LSTSQ.</p>
<p>This class is designed to work where you have a non-iterative but biased class for estimating the defined PSF (as
is done with Gaussian PSFs by using a logarithmic transformation).  If that is the case, and the unbiased estimator
class uses the same attributes and the biased estimator class, then you can use this as is to add the ability to get
the biased estimate and then correct it.  Otherwise you will need to do things yourself and shouldn’t bother with
this class.</p>
<p>To use this class, override the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.fit" title="giant.point_spread_functions.PointSpreadFunction.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method, and then call
<code class="docutils literal notranslate"><span class="pre">super().fit_lstsq(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p>
<p>This also adds 2 instance attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">_residuals</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">_covariance</span></code> which store the covariance and
residuals of the fit if requested.</p>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSF.fit_lstsq">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit_lstsq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#InitialGuessIterativeNonlinearLSTSQPSF.fit_lstsq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSF.fit_lstsq" title="Link to this definition">¶</a></dt>
<dd><p>This fits a PSF to a surface using iterative non-linear least squares estimation.</p>
<p>The estimation in this function is performed iteratively.  First, a non-iterative fit is performed using the
super class’s fit method.  This initial fit is then refined using iterative non-linear least squares to
remove biases that might have been introduced in the non-iterative fit..</p>
<p>If the fit is unsuccessful due to a rank deficient matrix then <code class="xref py py-meth docutils literal notranslate"><span class="pre">update_states()</span></code>
will be called which will likely result in the state parameters being set to NaN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">InitialGuessIterativeNonlinearLSTSQPSFwBackground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bg_b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_d_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#InitialGuessIterativeNonlinearLSTSQPSFwBackground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground" title="Link to this definition">¶</a></dt>
<dd><p>This class provides a fit class method which generates the initial guess from a subclass and then converges to a
better solution using iterative Nonlinear LSTSQ including a background gradient.</p>
<p>This class is designed to work where you have a non-iterative but biased class for estimating the defined PSF (as
is done with Gaussian PSFs by using a logarithmic transformation).  If that is the case, and the unbiased estimator
class uses the same attributes and the biased estimator class, then you can use this as is to add the ability to get
the biased estimate and then correct it along with the background gradient.  Otherwise you will need to do things
yourself and shouldn’t bother with this class.</p>
<p>To use this class, override the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.fit" title="giant.point_spread_functions.PointSpreadFunction.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method, and then call
<code class="docutils literal notranslate"><span class="pre">super().fit_lstsq(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p>
<p>This also adds 2 instance attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">_residuals</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">_covariance</span></code> which store the covariance and
residuals of the fit if requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bg_b_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The x slope of the background gradient</p></li>
<li><p><strong>bg_c_coef</strong> (<em>float</em><em> | </em><em>None</em>) – They y slope of the background gradient</p></li>
<li><p><strong>bg_d_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The constant offset of the background gradient</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground.compute_jacobian_all">
<span class="sig-name descname"><span class="pre">compute_jacobian_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#InitialGuessIterativeNonlinearLSTSQPSFwBackground.compute_jacobian_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground.compute_jacobian_all" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the Jacobian of the PSF with respect to a change in the state.</p>
<p>Mathematically, it should return the nxm matrix</p>
<div class="math notranslate nohighlight">
\[\mathbf{J} = \frac{\partial f(x, y)}{\partial \mathbf{t}}\]</div>
<p>where <span class="math notranslate nohighlight">\(f(x,y)\)</span> is the function being fit, <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> is a length m vector of the state parameters,
and <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> is the Jacobian matrix.  This specific implementation appends the background Jacobian to
the normal PSF Jacobian for estimating background terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values to evaluate the Jacobian at as a length n array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values to evaluate the Jacobian at as a length n array</p></li>
<li><p><strong>computed</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(f(x,y)\)</span> evaluated at x and y as a length n array.
This is provided for efficiency and convenience as the evaluated function is frequently needed
in the computation of the Jacobian and it is definitely needed in the non-linear least squares.
If not needed for computing the Jacobian this can safely be ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian matrix as a nxm numpy array, with n being the number of measurements and m being the
number of state parameters being estimated</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#InitialGuessIterativeNonlinearLSTSQPSFwBackground.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>This method evaluates the PSF at the given x and y.</p>
<p>This method is not intended to be used to apply the PSF for an image (use the callable capability of the class
instead for this).  Instead it simply computes the height of the PSF above the xy-plane at the requested
locations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x locations the height of the PSF is to be calculated at.</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y locations the height of the PSF is to be calculated at.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array containing the height of the PSF at the requested locations the same shape as x and y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground.fit_lstsq">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit_lstsq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#InitialGuessIterativeNonlinearLSTSQPSFwBackground.fit_lstsq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.InitialGuessIterativeNonlinearLSTSQPSFwBackground.fit_lstsq" title="Link to this definition">¶</a></dt>
<dd><p>This fits a PSF to a surface using iterative non-linear least squares estimation.</p>
<p>The estimation in this function is performed iteratively.  First, the rough background is estimated and removed.
Then, a non-iterative fit is performed using the super class’s fit method on the data with the rough background
removed.  This initial fit is then refined using iterative non-linear least squares to
remove biases that might have been introduced in the non-iterative fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix then
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update_states()</span></code> will be called which will likely result in the state
parameters being set to NaN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">IterativeNonlinearLSTSQwBackground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bg_b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_d_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQwBackground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground" title="Link to this definition">¶</a></dt>
<dd><p>This class provides support for estimating the superposition of the PSF and a linear background gradient.</p>
<p>This class is typically not used by the user except when implementing a new PSF class that uses iterative nonlinear
least squares to fit the PSF to data.</p>
<p>Beyond the typical implementation in <code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonLinearLSTSQ</span></code>, this class provides a concrete
implementation of methods <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.compute_jacobian_bg" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.compute_jacobian_bg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_jacobian_bg()</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.evaluate_bg" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.evaluate_bg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evaluate_bg()</span></code></a>, and <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.apply_update_bg" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.apply_update_bg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_update_bg()</span></code></a> which
handle the linear background gradient of the form</p>
<div class="math notranslate nohighlight">
\[f_{bg}(x, y) = f(x,y)+Bx+Cy+D\]</div>
<p>where <span class="math notranslate nohighlight">\(f_{bg}(x,y)\)</span> is the PSF with the background, <span class="math notranslate nohighlight">\(f(x,y)\)</span> is the PSF without the background,
<span class="math notranslate nohighlight">\(B\)</span> is the slope of the gradient in the x direction, <span class="math notranslate nohighlight">\(C\)</span> is the slope of the gradient in the y direction
and <span class="math notranslate nohighlight">\(D\)</span> is the constant background level.</p>
<p>The way this class should be used it to subclass it, then in the regular <code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_jacobian()</span></code> method call
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.compute_jacobian_bg" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.compute_jacobian_bg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_jacobian_bg()</span></code></a> and include with the rest of your Jacobian matrix (typically at the end),
then in <code class="xref py py-meth docutils literal notranslate"><span class="pre">evaluate()</span></code> call <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.evaluate_bg" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.evaluate_bg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evaluate_bg()</span></code></a> and add the results to the PSF, and finally in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update_states()</span></code> call <code class="xref py py-meth docutils literal notranslate"><span class="pre">update_states_bg()</span></code> inputting the portion of the state vector that contains the
background update according to where you added it to your existing Jacobian.</p>
<p>The background terms are stored in instance attributes <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_b_coef" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_b_coef"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bg_b_coef</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_c_coef" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_c_coef"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bg_c_coef</span></code></a>, and <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_d_coef" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_d_coef"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bg_d_coef</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bg_b_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The x slope of the background gradient</p></li>
<li><p><strong>bg_c_coef</strong> (<em>float</em><em> | </em><em>None</em>) – They y slope of the background gradient</p></li>
<li><p><strong>bg_d_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The constant offset of the background gradient</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.apply_update_bg">
<span class="sig-name descname"><span class="pre">apply_update_bg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bg_update</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQwBackground.apply_update_bg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.apply_update_bg" title="Link to this definition">¶</a></dt>
<dd><p>This applies the background update to the background state</p>
<p>This typically should be called from the regular <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_state()</span></code></a> and only fed
the components of the update vector that correspond to the background Jacobian matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bg_update</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – The update to apply to the background terms as a length 3 array</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.compute_jacobian_bg">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_jacobian_bg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQwBackground.compute_jacobian_bg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.compute_jacobian_bg" title="Link to this definition">¶</a></dt>
<dd><p>This computes the Jacobian matrix for the background terms.</p>
<p>Mathematically this is</p>
<div class="math notranslate nohighlight">
\[\mathbf{J}_{bg} = \left[\begin{array}{ccc}\frac{\partial f_{bg}(x,y)}{\partial B} &amp;
\frac{\partial f_{bg}(x,y)}{\partial C} &amp; \frac{\partial f_{bg}(x,y)}{\partial D}\end{array}\right]=
\left[\begin{array}{ccc} x &amp; y &amp; 1\end{array}\right]\]</div>
<p>The results from this function should be appended to the rest of the Jacobian matrix using <code class="docutils literal notranslate"><span class="pre">hstack</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values underlying the data the surface is to be fit to</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values underlying the data the surface is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian for the background as a nx3 numpy array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.evaluate_bg">
<span class="sig-name descname"><span class="pre">evaluate_bg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQwBackground.evaluate_bg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.evaluate_bg" title="Link to this definition">¶</a></dt>
<dd><p>This computes the background component at locations <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>The background component is defined as</p>
<div class="math notranslate nohighlight">
\[Bx+Cy+D\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values where the background is to be computed at</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values where the background is to be computed at</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The background according to the model</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.fit_bg">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit_bg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQwBackground.fit_bg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.fit_bg" title="Link to this definition">¶</a></dt>
<dd><p>This method tries to fit the background using linear least squares without worrying about any PSF included.</p>
<p>This is useful if you need to subtract off a rough estimate of the background before attempting to fit the PSF
for an initial guess.  The results of the fit are stored in the <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_b_coef" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_b_coef"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bg_b_coef</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_c_coef" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_c_coef"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bg_c_coef</span></code></a>, and
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_d_coef" title="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_d_coef"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bg_d_coef</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the data the background is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the data the background is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values for the background</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized BG PSF with values according to the fit for the background only</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_b_coef">
<span class="sig-name descname"><span class="pre">bg_b_coef</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_b_coef" title="Link to this definition">¶</a></dt>
<dd><p>The x slope of the background gradient</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_c_coef">
<span class="sig-name descname"><span class="pre">bg_c_coef</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_c_coef" title="Link to this definition">¶</a></dt>
<dd><p>The y slope of the background gradient</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_d_coef">
<span class="sig-name descname"><span class="pre">bg_d_coef</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQwBackground.bg_d_coef" title="Link to this definition">¶</a></dt>
<dd><p>The constant offset of the background gradient</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">IterativeNonlinearLSTSQPSF</span></span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF" title="Link to this definition">¶</a></dt>
<dd><p>This ABC defines common attributes, properties, and methods for Iterative Non-linear least squares estimation of
a Point Spread function.</p>
<p>This class is typically not used by the user except when implementing a new PSF class that uses iterative nonlinear
least squares to fit the PSF to data.</p>
<p>To use this class when implementing a new PSF, simply subclass it and then override the abstract methods
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_jacobian()</span></code></a> and <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_state()</span></code></a> (in addition to the required abstract methods from the typical
<a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction" title="giant.point_spread_functions.PointSpreadFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSpreadFunction</span></code></a> ABC) according to the PSF you are implementing.  You may also want to override the
default class attributes <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_iter</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atol</span></code></a>, and <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rtol</span></code></a>, which control when to break out of the
iterations.</p>
<p>Once you have overridden the abstract methods (and possibly the class attributes), you simply need to call the
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.converge" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.converge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">converge()</span></code></a> method from somewhere within the <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.fit" title="giant.point_spread_functions.PointSpreadFunction.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method after initializing the
class with the initial guess of the PSF parameters.  The <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.converge" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.converge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">converge()</span></code></a> method will then perform iterative
non-linear least squares until convergence or the maximum number of iterations have been performed according the the
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_iter</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atol</span></code></a>, and <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rtol</span></code></a> class attributes.  The converged solution will be stored as the
updated class parameters</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol">
<span class="sig-name descname"><span class="pre">atol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-10</span></em><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol" title="Link to this definition">¶</a></dt>
<dd><p>The absolute tolerance cut-off for the iterative least squares. (The iteration will cease when the new estimate is 
within this tolerance for every element from the previous estimate)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQPSF.compute_jacobian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the Jacobian of the PSF with respect to a change in the state.</p>
<p>Mathematically, it should return the nxm matrix</p>
<div class="math notranslate nohighlight">
\[\mathbf{J} = \frac{\partial f(x, y)}{\partial \mathbf{t}}\]</div>
<p>where <span class="math notranslate nohighlight">\(f(x,y)\)</span> is the function being fit, <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> is a length m vector of the state parameters,
and <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> is the Jacobian matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values to evaluate the Jacobian at as a length n array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values to evaluate the Jacobian at as a length n array</p></li>
<li><p><strong>computed</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(f(x,y)\)</span> evaluated at x and y as a length n array.
This is provided for efficiency and convenience as the evaluated function is frequently needed
in the computation of the Jacobian and it is definitely needed in the non-linear least squares.
If not needed for computing the Jacobian this can safely be ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian matrix as a nxm numpy array, with n being the number of measurements and m being the
number of state parameters being estimated</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.converge">
<span class="sig-name descname"><span class="pre">converge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQPSF.converge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.converge" title="Link to this definition">¶</a></dt>
<dd><p>Performs iterative non-linear least squares on a PSF model until convergence has been reached for a function of
the form <span class="math notranslate nohighlight">\(z=f(x, y)\)</span></p>
<p>Iterative non-linear least squares is performed by linearizing at each step about the current best estimate of
the state.  This means that for each iteration, the Jacobian matrix is computed based off the current best
estimate of the state, and then used to form a linear approximation of the model using a Taylor expansion.
The resulting estimate is a delta from the current state, so that it is typically applied by adding the
resulting update state vector to the existing states (although in some instances such as for rotations, a more
complicated update application may be needed.</p>
<p>Iterative non-linear least squares typically needs an adequate initial guess to ensure convergence, therefore,
it is recommended that the state of the class be appropriately initialized before calling this method (what is
appropriate is dependent on the PSF itself.</p>
<p>The iteration performed in this method can be controlled using the <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_iter</span></code></a>, <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atol</span></code></a>, and
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rtol</span></code></a> class attributes which control the maximum number of iterations to attempt for convergence, the
absolute tolerance criteria for convergence, and the relative tolerance criteria for convergence respectively.</p>
<p>This method use <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_jacobian()</span></code></a> to return the Jacobian matrix for the current estimate of the state
vector and <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_state()</span></code></a> to apply the estimated update at each iteration step, therefore, these methods
should expect the same order of state elements.</p>
<p>If the iteration diverges then this method will call <a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_state()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">None</span></code> as the argument, which
should typically indicate that the state parameters should be set to NaN so that other GIANT algorithms are
aware the PSF fit failed.</p>
<p>If <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction.save_residuals" title="giant.point_spread_functions.PointSpreadFunction.save_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code></a> is set to True, then this function will return a vector of the
residuals and the covariance matrix from the fit as numpy arrays.  Otherwise it returns None, None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x locations of the expected values as a 1D array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y locations of the expected values as a 1D array</p></li>
<li><p><strong>z</strong> (<em>ndarray</em>) – The expected values to fit to as a 1D array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Either (residuals, covariance) as (n,) and (m,m) arrays if <code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tuple</em>[<em>ndarray</em>[tuple[<em>Any</em>, …], <em>dtype</em>[<em>_ScalarT</em>]] | None, <em>ndarray</em>[tuple[<em>Any</em>, …], <em>dtype</em>[<em>_ScalarT</em>]] | None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">20</span></em><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.max_iter" title="Link to this definition">¶</a></dt>
<dd><p>An integer defining the maximum number of iterations to attempt in the iterative least squares solution.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol">
<span class="sig-name descname"><span class="pre">rtol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-10</span></em><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.rtol" title="Link to this definition">¶</a></dt>
<dd><p>The relative tolerance cut-off for the iterative least squares. (The iteration will cease when the maximum percent 
change in the state vector from one iteration to the next is less than this value)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#IterativeNonlinearLSTSQPSF.update_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.update_state" title="Link to this definition">¶</a></dt>
<dd><p>Updates the current values based on the provided update vector.</p>
<p>The provided update vector is in the order according to order of the columns returned from
<a class="reference internal" href="#giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian" title="giant.point_spread_functions.IterativeNonlinearLSTSQPSF.compute_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_jacobian()</span></code></a>.</p>
<p>If the input is <code class="docutils literal notranslate"><span class="pre">None</span></code> then this method should set the state parameters to NaN to indicate to the rest of
GIANT that the estimation failed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>update</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – The vector of additive updates to apply or None to indicate that the fit failed</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.KernelBasedCallPSF">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">KernelBasedCallPSF</span></span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#KernelBasedCallPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.KernelBasedCallPSF" title="Link to this definition">¶</a></dt>
<dd><p>This ABC adds concrete common functionality for applying the initialized PSF to 2D images to
<a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction" title="giant.point_spread_functions.PointSpreadFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSpreadFunction</span></code></a>.</p>
<p>The implementation that is shared by most PSFs for 2D images is stored in <code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code>.  This method,
works by generating a square kernel of the PSF by a call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_kernel()</span></code> and then convolving the kernel
with the image.  For most PSFs, this form will be used, although a few like <a class="reference internal" href="#giant.point_spread_functions.Gaussian" title="giant.point_spread_functions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gaussian</span></code></a> may have a further
optimized call sequence.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.KernelBasedApply1DPSF">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">KernelBasedApply1DPSF</span></span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#KernelBasedApply1DPSF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.KernelBasedApply1DPSF" title="Link to this definition">¶</a></dt>
<dd><p>This ABC adds concrete common functionality for applying the initialized PSF to 1D scan lines to
<a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction" title="giant.point_spread_functions.PointSpreadFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSpreadFunction</span></code></a>.</p>
<p>The implementation that is shared by most PSFs for 1D scan lines is stored in <a class="reference internal" href="#giant.point_spread_functions.KernelBasedApply1DPSF.apply_1d_sized" title="giant.point_spread_functions.KernelBasedApply1DPSF.apply_1d_sized"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_1d_sized()</span></code></a>.  This method,
which isn’t part of the actual interface GIANT expects, is used for applying the specified PSF to 1D scan lines
if the size of the required kernel is known.  Therefore, when implementing method:<cite>apply_1d</cite>, all you need to do is
calculate the required size of the 1D kernel and then dispatch to <a class="reference internal" href="#giant.point_spread_functions.KernelBasedApply1DPSF.apply_1d_sized" title="giant.point_spread_functions.KernelBasedApply1DPSF.apply_1d_sized"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_1d_sized()</span></code></a>.  An example of this can
be seen in <a class="reference internal" href="#giant.point_spread_functions.Gaussian" title="giant.point_spread_functions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gaussian</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.KernelBasedApply1DPSF.apply_1d_sized">
<span class="sig-name descname"><span class="pre">apply_1d_sized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/psf_meta.html#KernelBasedApply1DPSF.apply_1d_sized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.KernelBasedApply1DPSF.apply_1d_sized" title="Link to this definition">¶</a></dt>
<dd><p>Applies the defined PSF using the stored parameters to the 1D image scans provided with a given kernel size.</p>
<p><code class="docutils literal notranslate"><span class="pre">image_1d</span></code> can be a 2D array but in that case each row will be treated as an independent 1D scan.</p>
<p>For non-symmetric PSFs, a <code class="docutils literal notranslate"><span class="pre">direction</span></code> argument can be supplied which should be the direction in the image of
each scan line.  This can be used to determine the appropriate cross-section of the PSF to use for applying to
the 1D scans (if applicable).  If no direction is provided then the x direction [1, 0] is assumed.</p>
<p>This method works by sampling the PSF in the (optionally) specified direction(s) centered around the centroid of
the PSF according to the input <code class="docutils literal notranslate"><span class="pre">size</span></code>. These kernels are then applied to the input scan lines using a Fourier
transform, and the resulting scan lines are returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_1d</strong> (<em>ndarray</em>) – The scan line(s) to be blurred using the PSF</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when convolving the PSF with the scan line</p></li>
<li><p><strong>direction</strong> (<em>ndarray</em><em> | </em><em>None</em>) – The direction for the 1D cross section of the PSF.  This should be either None, a length 2
array, or a shape nx2 array where n is the number of scan lines</p></li>
<li><p><strong>step</strong> (<em>float</em>) – The step size of the lines being blurred.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an array containing the input after blurring with the defined PSF</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.Gaussian">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">Gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#Gaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Gaussian" title="Link to this definition">¶</a></dt>
<dd><p>A class for representing and fitting a standard (non-rotated) 2D gaussian point spread function.</p>
<p>This class represents a 2D Gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is the <code class="xref py py-attr docutils literal notranslate"><span class="pre">amplitude</span></code> of the PSF, <span class="math notranslate nohighlight">\(\sigma_x\)</span> is the Gaussian RMS width in the x direction,
<span class="math notranslate nohighlight">\(\sigma_y\)</span> is the Gaussian RMS width in the y direction, and <span class="math notranslate nohighlight">\((x_0,y_0)\)</span> is the centroid of the Gaussian
(location of the peak response).</p>
<p>This class can be used for both estimating a Gaussian fit to an observed PSF (using the <a class="reference internal" href="#giant.point_spread_functions.Gaussian.fit" title="giant.point_spread_functions.Gaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> class method to
create an instance) as well as for applying the represented PSF to 1D scan lines (using <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_1d()</span></code>) and 2D
images (using the <em>call</em> capabilities of an instance of this class).  In addition, if generated from a fit to data,
this class will store the residuals and statistics about the residuals of the fit if the class attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code> is set to True before calling <a class="reference internal" href="#giant.point_spread_functions.Gaussian.fit" title="giant.point_spread_functions.Gaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a>.</p>
<p>This class can be used anywhere GIANT expects a point spread function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_x</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS width in the x direction in pixels</p></li>
<li><p><strong>sigma_y</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS Width in the y direction in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> this is set to be
the same as <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code></p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when applying this PSF in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
computed based on the Gaussian RSM widths.</p></li>
<li><p><strong>amplitude</strong> (<em>float</em><em> | </em><em>None</em>) – The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code>
this will be computed so that the kernel does not increase/decrease the total signal.</p></li>
<li><p><strong>centroid_x</strong> (<em>float</em><em> | </em><em>None</em>) – The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em><em> | </em><em>None</em>) – The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Gaussian.compute_jacobian">
<span class="sig-name descname"><span class="pre">compute_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#Gaussian.compute_jacobian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Gaussian.compute_jacobian" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the Jacobian of the PSF with respect to a change in the state.</p>
<p>It returns a mx5 matrix defined as</p>
<div class="math notranslate nohighlight">
\[\mathbf{J} = \left[\begin{array}{ccccc} \frac{\partial f}{\partial x_0} &amp;
\frac{\partial f}{\partial y_0} &amp;
\frac{\partial f}{\partial \sigma_x} &amp;
\frac{\partial f}{\partial \sigma_y} &amp;
\frac{\partial f}{\partial A}\end{array}\right]=\left[\begin{array}{ccccc}
\frac{x-x_0}{\sigma_x^2}f(x, y) &amp;
\frac{y-y_0}{\sigma_y^2}f(x, y) &amp;
\frac{(x-x_0)^2}{\sigma_x^3}f(x, y) &amp;
\frac{(y-y_0)^2}{\sigma_y^3}f(x, y) &amp;
\frac{f(x, y)}{A}\end{array}\right]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>computed</strong> (<em>ndarray</em>) – The PSF evaluated at x and y as a length m array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian matrix as a mx5 numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.Gaussian.covariance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.point_spread_functions.Gaussian.covariance" title="Link to this definition">¶</a></dt>
<dd><p>The formal covariance of the PSF parameters after fitting this PSF model to data.</p>
<p>If this instance is not the result of a fit (<a class="reference internal" href="#giant.point_spread_functions.Gaussian.fit" title="giant.point_spread_functions.Gaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a>) or if <code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> then this
will raise an assertion error</p>
<p>The order of the state vector (and thus the covariance matrix) is <span class="math notranslate nohighlight">\([x_0, y_0, \sigma_x, \sigma_y, A]\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Gaussian.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#Gaussian.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Gaussian.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>This method evaluates the PSF at the given x and y.</p>
<p>This method is not intended to be used to apply the PSF for an image (use the callable capability of the class
instead for this).  Instead it simply computes the height of the PSF above the xy-plane at the requested
locations.</p>
<p>Specifically, this method computes</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x locations the height of the PSF is to be calculated at.</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y locations the height of the PSF is to be calculated at.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array containing the height of the PSF at the requested locations the same shape as x and y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Gaussian.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#Gaussian.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Gaussian.fit" title="Link to this definition">¶</a></dt>
<dd><p>This fits a 2d gaussian function to a surface using least squares estimation.</p>
<p>The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the “height” of the gaussian
function).</p>
<p>The fit performed is for a 2D gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}\]</div>
<p>The estimation in this function is performed by transforming the gaussian function into the logspace, which
allows us to perform a true linear least squares fit without iteration but overweights the tails of the
function.  Therefore, it is best to constrain the data you are fitting to be near the peak of the PSF to ensure
that too much noise is not being given extra weight in the fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data
will be set to np.nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.html#giant.point_spread_functions.gaussians.Gaussian" title="giant.point_spread_functions.gaussians.Gaussian"><em>Gaussian</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Gaussian.update_state">
<span class="sig-name descname"><span class="pre">update_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#Gaussian.update_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Gaussian.update_state" title="Link to this definition">¶</a></dt>
<dd><p>Updates the current values based on the provided update vector.</p>
<p>The provided update vector is in the order of <span class="math notranslate nohighlight">\([x_0, y_0, \sigma_x, \sigma_y, A]\)</span>.</p>
<p>If the update vector is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> then sets everything to NaN to indicate a bad fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>update</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – The vector of additive updates to apply</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">GeneralizedGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#GeneralizedGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian" title="Link to this definition">¶</a></dt>
<dd><p>A class for representing and fitting a generalized (rotated) 2D gaussian point spread function.</p>
<p>This class represents a 2D Gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is the <code class="xref py py-attr docutils literal notranslate"><span class="pre">amplitude</span></code> of the PSF, <span class="math notranslate nohighlight">\(a\)</span> is the coefficient for <span class="math notranslate nohighlight">\((x-x_0)^2\)</span>,
<span class="math notranslate nohighlight">\(c\)</span> is the coefficient for <span class="math notranslate nohighlight">\((y-y_0)^2\)</span>,  <span class="math notranslate nohighlight">\(b\)</span> is the coefficient for <span class="math notranslate nohighlight">\((x-x_0)(y-y_0)\)</span>, and
<span class="math notranslate nohighlight">\((x_0,y_0)\)</span> is the centroid of the Gaussian (location of the peak response).</p>
<p>This is equivalent to a function of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(x, y) = A e^{-\left[\begin{array}{cc} (x-x_0) &amp; (y-y_0)\end{array}\right]\mathbf{B}\mathbf{S}\mathbf{B}^T
\left[\begin{array}{c}(x-x_0) \\ (y-y_0)\end{array}\right]}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{B} = \left[\begin{array}{cc} \text{cos}(\theta) &amp; -\text{sin}(\theta) \\
\text{sin}(\theta) &amp; \text{cos}(\theta)\end{array}\right] \\
\mathbf{S} = \left[\begin{array}{cc} \frac{1}{\sigma_x^2} &amp; 0 \\ 0 &amp; \frac{1}{\sigma_y^2}\end{array}\right]\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the x-axis and the principal axis of the Gaussian, <span class="math notranslate nohighlight">\(sigma_x\)</span> is the
Gaussian RMS width in the semi-major axis direction, and <span class="math notranslate nohighlight">\(\sigma_x\)</span> is the  RMS width in the semi-minor axis
direction.</p>
<p>When creating an instance of this class you can specify either <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> or <code class="docutils literal notranslate"><span class="pre">sigma_x,</span> <span class="pre">sigma_y,</span> <span class="pre">theta</span></code> and the
class will convert and store appropriately.  This class also allows you to retrieve either <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> or
<code class="docutils literal notranslate"><span class="pre">sigma_x,</span> <span class="pre">sigma_y,</span> <span class="pre">theta</span></code>.</p>
<p>This class can be used for both estimating a Gaussian fit to an observed PSF (using the <a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian.fit" title="giant.point_spread_functions.GeneralizedGaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> class method to
create an instance) as well as for applying the represented PSF to 1D scan lines (using <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_1d)</span> <span class="pre">and</span> <span class="pre">2D</span>
<span class="pre">images</span> <span class="pre">(using</span> <span class="pre">the</span> <span class="pre">*call*</span> <span class="pre">capabilities</span> <span class="pre">of</span> <span class="pre">an</span> <span class="pre">instance</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">class).</span>&#160; <span class="pre">In</span> <span class="pre">addition,</span> <span class="pre">if</span> <span class="pre">generated</span> <span class="pre">from</span> <span class="pre">a</span> <span class="pre">fit</span> <span class="pre">to</span> <span class="pre">data,</span>
<span class="pre">this</span> <span class="pre">class</span> <span class="pre">will</span> <span class="pre">store</span> <span class="pre">the</span> <span class="pre">residuals</span> <span class="pre">and</span> <span class="pre">statistics</span> <span class="pre">about</span> <span class="pre">the</span> <span class="pre">residuals</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">fit</span> <span class="pre">if</span> <span class="pre">the</span> <span class="pre">class</span> <span class="pre">attribute</span>
<span class="pre">:attr:`save_residuals()</span></code> is set to True before calling <a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian.fit" title="giant.point_spread_functions.GeneralizedGaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a>.</p>
<p>This class can be used anywhere GIANT expects a point spread function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The a coefficient of the Gaussian polynomial</p></li>
<li><p><strong>b_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The b coefficient of the Gaussian polynomial</p></li>
<li><p><strong>c_coef</strong> (<em>float</em><em> | </em><em>None</em>) – The c coefficient of the Gaussian polynomial</p></li>
<li><p><strong>sigma_x</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS width in the x direction in pixels</p></li>
<li><p><strong>sigma_y</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS Width in the y direction in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> this is set to be
the same as <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code></p></li>
<li><p><strong>sigma_x</strong> – The angle between the x-axis and the principal axis of the Gaussian in radians.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when applying this PSF in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
computed based on the Gaussian RSM widths.</p></li>
<li><p><strong>amplitude</strong> (<em>float</em><em> | </em><em>None</em>) – The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code>
this will be computed so that the kernel does not increase/decrease the total signal.</p></li>
<li><p><strong>centroid_x</strong> (<em>float</em><em> | </em><em>None</em>) – The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em><em> | </em><em>None</em>) – The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>theta</strong> (<em>float</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.compute_jacobian">
<span class="sig-name descname"><span class="pre">compute_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#GeneralizedGaussian.compute_jacobian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.compute_jacobian" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the Jacobian of the PSF with respect to a change in the state.</p>
<p>This is used internally for computing the covariance.  It returns a 5xn matrix defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{J} = \left[\begin{array}{cccccc} \frac{\partial f}{\partial x_0} &amp;
\frac{\partial f}{\partial y_0} &amp;
\frac{\partial f}{\partial a} &amp;
\frac{\partial f}{\partial b} &amp;
\frac{\partial f}{\partial c} &amp;
\frac{\partial f}{\partial A} \end{array}\right]=\left[\begin{array}{c}
\left(2a(x-x_0)+2b(y-y_0)\right)f(x, y) \\
\left(2c(y-y_0)+2b(x-x_0)\right)f(x, y) \\
-(x-x_0)^2f(x, y) \\
-2(x-x_0)(y-y_0)f(x, y) \\
-(y-y_0)^2f(x, y) \\
\frac{f(x, y)}{A} \end{array}\right]^T\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>computed</strong> (<em>ndarray</em>) – The PSF evaluated at x and y as a length m array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian matrix as a 5xm numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.covariance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.covariance" title="Link to this definition">¶</a></dt>
<dd><p>The formal covariance of the PSF parameters after fitting this PSF model to data.</p>
<p>If this instance is not the result of a fit (<a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian.fit" title="giant.point_spread_functions.GeneralizedGaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a>) or if <code class="xref py py-attr docutils literal notranslate"><span class="pre">save_residuals</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> then this
will raise an assertion error</p>
<p>The order of the state vector (and thus the covariance matrix) is <span class="math notranslate nohighlight">\([x_0, y_0, a, b, c, A]\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#GeneralizedGaussian.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>This method evaluates the PSF at the given x and y.</p>
<p>This method is not intended to be used to apply the PSF for an image (use the callable capability of the class
instead for this).  Instead it simply computes the height of the PSF above the xy-plane at the requested
locations.</p>
<p>Specifically, this method computes</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x locations the height of the PSF is to be calculated at.</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y locations the height of the PSF is to be calculated at.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A numpy array containing the height of the PSF at the requested locations the same shape as x and y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#GeneralizedGaussian.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.fit" title="Link to this definition">¶</a></dt>
<dd><p>This fits a generalized (rotated) 2d gaussian function to a surface using least squares estimation.</p>
<p>The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the “height” of the gaussian
function).</p>
<p>The fit performed is for a generalized 2D gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}\]</div>
<p>The estimation in this function is performed by transforming the gaussian function into the logspace, which
allows us to perform a true linear least squares fit without iteration but overweights the tails of the
function.  Therefore, it is best to constrain the data you are fitting to be near the peak of the PSF to ensure
that too much noise is not being given extra weight in the fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data
will be set to np.nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the data the gaussian surface is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the data the gaussian surface is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values for the gaussian surface</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.html#giant.point_spread_functions.gaussians.GeneralizedGaussian" title="giant.point_spread_functions.gaussians.GeneralizedGaussian"><em>GeneralizedGaussian</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.update_state">
<span class="sig-name descname"><span class="pre">update_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#GeneralizedGaussian.update_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.update_state" title="Link to this definition">¶</a></dt>
<dd><p>Updates the current values based on the provided update vector.</p>
<p>The provided update vector is in the order of <span class="math notranslate nohighlight">\([x_0, y_0, a, b, c, A]\)</span>.</p>
<p>If the update vector is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> then sets everything to NaN to indicate a bad fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>update</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – The vector of additive updates to apply</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.a_coef">
<span class="sig-name descname"><span class="pre">a_coef</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.a_coef" title="Link to this definition">¶</a></dt>
<dd><p>The <span class="math notranslate nohighlight">\((x-x_0)^2\)</span> coefficient from the exponential component of the generalized 2D Gaussian.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.b_coef">
<span class="sig-name descname"><span class="pre">b_coef</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.b_coef" title="Link to this definition">¶</a></dt>
<dd><p>The <span class="math notranslate nohighlight">\((x-x_0)(y-y_0)\)</span> coefficient from the exponential component of the generalized 2D Gaussian.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.c_coef">
<span class="sig-name descname"><span class="pre">c_coef</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.c_coef" title="Link to this definition">¶</a></dt>
<dd><p>The <span class="math notranslate nohighlight">\((y-y_0)^2\)</span> coefficient from the exponential component of the generalized 2D Gaussian.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.sigma_x">
<span class="sig-name descname"><span class="pre">sigma_x</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.sigma_x" title="Link to this definition">¶</a></dt>
<dd><p>The RMS width in the semi-major axis direction.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.sigma_y">
<span class="sig-name descname"><span class="pre">sigma_y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.sigma_y" title="Link to this definition">¶</a></dt>
<dd><p>The RMS width in the semi-minor axis direction.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.GeneralizedGaussian.theta">
<span class="sig-name descname"><span class="pre">theta</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.GeneralizedGaussian.theta" title="Link to this definition">¶</a></dt>
<dd><p>The angle between the semi-major axis and the x axis</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGaussian">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">IterativeGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGaussian" title="Link to this definition">¶</a></dt>
<dd><p>A class for representing and fitting a standard (non-rotated) 2D Gaussian point spread function using iterative
non-linear least squares.</p>
<p>This class only differs from the <a class="reference internal" href="#giant.point_spread_functions.Gaussian" title="giant.point_spread_functions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gaussian</span></code></a> class in the way the <a class="reference internal" href="#giant.point_spread_functions.IterativeGaussian.fit" title="giant.point_spread_functions.IterativeGaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> class method works.  In this
version, the fit is performed using iterative non-linear least squares, which is typically more accurate than using
the logarithmic transformation to do linear least squares at the expense of more computation time.</p>
<p>For more details about the model this works with, see the <a class="reference internal" href="#giant.point_spread_functions.Gaussian" title="giant.point_spread_functions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gaussian</span></code></a> documentation.</p>
<p>This class can be used anywhere GIANT expects a point spread function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_x</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS width in the x direction in pixels</p></li>
<li><p><strong>sigma_y</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS Width in the y direction in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> this is set to be
the same as <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code></p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when applying this PSF in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
computed based on the Gaussian RSM widths.</p></li>
<li><p><strong>amplitude</strong> (<em>float</em><em> | </em><em>None</em>) – The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code>
this will be computed so that the kernel does not increase/decrease the total signal.</p></li>
<li><p><strong>centroid_x</strong> (<em>float</em><em> | </em><em>None</em>) – The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em><em> | </em><em>None</em>) – The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGaussian.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGaussian.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGaussian.fit" title="Link to this definition">¶</a></dt>
<dd><p>This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</p>
<p>The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the “height” of the gaussian
function).</p>
<p>The fit performed is for a 2D gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}\]</div>
<p>The estimation in this function is performed iteratively.  First, a transformed fit is performed using the
<a class="reference internal" href="#giant.point_spread_functions.Gaussian.fit" title="giant.point_spread_functions.Gaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Gaussian.fit()</span></code></a> method.  This initial fit is then refined using iterative non-linear least squares to
remove biases that can be introduced in the transformed fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data
will be set to np.nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussian.html#giant.point_spread_functions.gaussians.IterativeGaussian" title="giant.point_spread_functions.gaussians.IterativeGaussian"><em>IterativeGaussian</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGeneralizedGaussianWBackground">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">IterativeGeneralizedGaussianWBackground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_d_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGeneralizedGaussianWBackground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground" title="Link to this definition">¶</a></dt>
<dd><p>A class for representing and fitting the superposition of a standard (non-rotated) 2D Gaussian point spread function
and a linear background gradiant using iterative non-linear least squares.</p>
<p>This class differs from the <a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian" title="giant.point_spread_functions.GeneralizedGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedGaussian</span></code></a> class in the way the <a class="reference internal" href="#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.fit" title="giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> class method works and in
the fact that it adds a background gradient to the model.  In this version, the fit is performed using iterative
non-linear least squares, which is typically more accurate than using the logarithmic transformation to do linear
least squares at the expense of more computation time.</p>
<p>The specific model that is fit is given by</p>
<div class="math notranslate nohighlight">
\[f(x, y) = A e^{\left(-\left[a(x-x_0)^2+b(x-x_0)(y-y_0)+c(y-y_0)^2\right]\right)} + Bx+Cy+D\]</div>
<p>This class can be used anywhere GIANT expects a point spread function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a_coef</strong> (<em>float</em>) – The a coefficient of the Gaussian polynomial</p></li>
<li><p><strong>b_coef</strong> (<em>float</em>) – The b coefficient of the Gaussian polynomial</p></li>
<li><p><strong>c_coef</strong> (<em>float</em>) – The c coefficient of the Gaussian polynomial</p></li>
<li><p><strong>sigma_x</strong> (<em>float</em>) – The Gaussian RMS width in the x direction in pixels</p></li>
<li><p><strong>sigma_y</strong> (<em>float</em>) – The Gaussian RMS Width in the y direction in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> this is set to be
the same as <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code></p></li>
<li><p><strong>sigma_x</strong> – The angle between the x-axis and the principal axis of the Gaussian in radians.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when applying this PSF in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
computed based on the Gaussian RSM widths.</p></li>
<li><p><strong>amplitude</strong> (<em>float</em>) – The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code>
this will be computed so that the kernel does not increase/decrease the total signal.</p></li>
<li><p><strong>centroid_x</strong> (<em>float</em>) – The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em>) – The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>bg_b_coef</strong> (<em>float</em>) – The x slope of the background gradient</p></li>
<li><p><strong>bg_c_coef</strong> (<em>float</em>) – They y slope of the background gradient</p></li>
<li><p><strong>bg_d_coef</strong> (<em>float</em>) – The constant offset of the background gradient</p></li>
<li><p><strong>theta</strong> (<em>float</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.compute_jacobian">
<span class="sig-name descname"><span class="pre">compute_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGeneralizedGaussianWBackground.compute_jacobian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.compute_jacobian" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the Jacobian of the PSF with respect to a change in the state.</p>
<p>It returns a mx8 matrix defined as</p>
<div class="math notranslate nohighlight">
\[\mathbf{J} = \left[\begin{array}{cccccccc} \frac{\partial f}{\partial x_0} &amp;
\frac{\partial f}{\partial y_0} &amp;
\frac{\partial f}{\partial \sigma_x} &amp;
\frac{\partial f}{\partial \sigma_y} &amp;
\frac{\partial f}{\partial A} &amp;
\frac{\partial f}{\partial B} &amp;
\frac{\partial f}{\partial C} &amp;
\frac{\partial f}{\partial D}\end{array}\right]=\left[\begin{array}{cccccccc}
\frac{x-x_0}{\sigma_x^2}f(x, y) &amp;
\frac{y-y_0}{\sigma_y^2}f(x, y) &amp;
\frac{(x-x_0)^2}{\sigma_x^3}f(x, y) &amp;
\frac{(y-y_0)^2}{\sigma_y^3}f(x, y) &amp;
\frac{f(x, y)}{A} &amp;
x &amp; y &amp; 1\end{array}\right]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>computed</strong> (<em>ndarray</em>) – The PSF evaluated at x and y as a length m array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian matrix as a mx8 numpy array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGeneralizedGaussianWBackground.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.fit" title="Link to this definition">¶</a></dt>
<dd><p>This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</p>
<p>The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the “height” of the gaussian
function).</p>
<p>The fit performed is for a 2D gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}
+Bx+Cy+D\]</div>
<p>The estimation in this function is performed iteratively.  First, the rough background is estimated and removed.
Then, a transformed fit is performed using the super class’s fit method on the data with the rough background
removed.  This initial fit is then refined using iterative non-linear least squares on the original data to
remove biases that might have been introduced in the non-iterative fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data
will be set to np.nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.update_state">
<span class="sig-name descname"><span class="pre">update_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGeneralizedGaussianWBackground.update_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.update_state" title="Link to this definition">¶</a></dt>
<dd><p>Updates the current values based on the provided update vector.</p>
<p>The provided update vector is in the order of <span class="math notranslate nohighlight">\([x_0, y_0, \sigma_x, \sigma_y, A, B, C, D]\)</span>.</p>
<p>If the update vector is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> then sets everything to NaN to indicate a bad fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>update</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – The vector of additive updates to apply</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGeneralizedGaussian">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">IterativeGeneralizedGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGeneralizedGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGeneralizedGaussian" title="Link to this definition">¶</a></dt>
<dd><p>A class for representing and fitting a generalized (rotated) 2D Gaussian point spread function using iterative
non-linear least squares.</p>
<p>This class only differs from the <a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian" title="giant.point_spread_functions.GeneralizedGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedGaussian</span></code></a> class in the way the <a class="reference internal" href="#giant.point_spread_functions.IterativeGeneralizedGaussian.fit" title="giant.point_spread_functions.IterativeGeneralizedGaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> class method works.
In this version, the fit is performed using iterative non-linear least squares, which is typically more accurate
than using the logarithmic transformation to do linear least squares at the expense of more computation time.</p>
<p>For more details about the model this works with, see the <a class="reference internal" href="#giant.point_spread_functions.GeneralizedGaussian" title="giant.point_spread_functions.GeneralizedGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeneralizedGaussian</span></code></a> documentation.</p>
<p>This class can be used anywhere GIANT expects a point spread function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a_coef</strong> (<em>float</em>) – The a coefficient of the Gaussian polynomial</p></li>
<li><p><strong>b_coef</strong> (<em>float</em>) – The b coefficient of the Gaussian polynomial</p></li>
<li><p><strong>c_coef</strong> (<em>float</em>) – The c coefficient of the Gaussian polynomial</p></li>
<li><p><strong>sigma_x</strong> (<em>float</em>) – The Gaussian RMS width in the x direction in pixels</p></li>
<li><p><strong>sigma_y</strong> (<em>float</em>) – The Gaussian RMS Width in the y direction in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> this is set to be
the same as <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code></p></li>
<li><p><strong>sigma_x</strong> – The angle between the x-axis and the principal axis of the Gaussian in radians.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when applying this PSF in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
computed based on the Gaussian RSM widths.</p></li>
<li><p><strong>amplitude</strong> (<em>float</em>) – The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code>
this will be computed so that the kernel does not increase/decrease the total signal.</p></li>
<li><p><strong>centroid_x</strong> (<em>float</em>) – The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em>) – The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>theta</strong> (<em>float</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGeneralizedGaussian.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGeneralizedGaussian.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGeneralizedGaussian.fit" title="Link to this definition">¶</a></dt>
<dd><p>This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</p>
<p>The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the “height” of the gaussian
function).</p>
<p>The fit performed is for a 2D gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}\]</div>
<p>The estimation in this function is performed iteratively.  First, a transformed fit is performed using the
<a class="reference internal" href="#giant.point_spread_functions.Gaussian.fit" title="giant.point_spread_functions.Gaussian.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Gaussian.fit()</span></code></a> method.  This initial fit is then refined using iterative non-linear least squares to
remove biases that can be introduced in the transformed fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data
will be set to np.nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the data the gaussian surface is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the data the gaussian surface is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values for the gaussian surface</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGaussianWBackground">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">IterativeGaussianWBackground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_b_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_c_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_d_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGaussianWBackground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGaussianWBackground" title="Link to this definition">¶</a></dt>
<dd><p>A class for representing and fitting the superposition of a standard (non-rotated) 2D Gaussian point spread function
and a linear background gradiant using iterative non-linear least squares.</p>
<p>This class differs from the <a class="reference internal" href="#giant.point_spread_functions.Gaussian" title="giant.point_spread_functions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gaussian</span></code></a> class in the way the <a class="reference internal" href="#giant.point_spread_functions.IterativeGaussianWBackground.fit" title="giant.point_spread_functions.IterativeGaussianWBackground.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> class method works and in the fact
that it adds a background gradient to the model.  In this version, the fit is performed using iterative non-linear
least squares, which is typically more accurate than using the logarithmic transformation to do linear least squares
at the expense of more computation time.</p>
<p>The specific model that is fit is given by</p>
<div class="math notranslate nohighlight">
\[f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)} + Bx+Cy+D\]</div>
<p>This class can be used anywhere GIANT expects a point spread function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_x</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS width in the x direction in pixels</p></li>
<li><p><strong>sigma_y</strong> (<em>float</em><em> | </em><em>None</em>) – The Gaussian RMS Width in the y direction in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> this is set to be
the same as <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code></p></li>
<li><p><strong>size</strong> (<em>int</em>) – The size of the kernel to use when applying this PSF in pixels.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
computed based on the Gaussian RSM widths.</p></li>
<li><p><strong>amplitude</strong> (<em>float</em><em> | </em><em>None</em>) – The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or <code class="docutils literal notranslate"><span class="pre">None</span></code>
this will be computed so that the kernel does not increase/decrease the total signal.</p></li>
<li><p><strong>centroid_x</strong> (<em>float</em><em> | </em><em>None</em>) – The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em><em> | </em><em>None</em>) – The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the
PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</p></li>
<li><p><strong>bg_b_coef</strong> (<em>float</em>) – The x slope of the background gradient</p></li>
<li><p><strong>bg_c_coef</strong> (<em>float</em>) – They y slope of the background gradient</p></li>
<li><p><strong>bg_d_coef</strong> (<em>float</em>) – The constant offset of the background gradient</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGaussianWBackground.compute_jacobian">
<span class="sig-name descname"><span class="pre">compute_jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGaussianWBackground.compute_jacobian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGaussianWBackground.compute_jacobian" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the Jacobian of the PSF with respect to a change in the state.</p>
<p>It returns a mx8 matrix defined as</p>
<div class="math notranslate nohighlight">
\[\mathbf{J} = \left[\begin{array}{cccccccc} \frac{\partial f}{\partial x_0} &amp;
\frac{\partial f}{\partial y_0} &amp;
\frac{\partial f}{\partial \sigma_x} &amp;
\frac{\partial f}{\partial \sigma_y} &amp;
\frac{\partial f}{\partial A} &amp;
\frac{\partial f}{\partial B} &amp;
\frac{\partial f}{\partial C} &amp;
\frac{\partial f}{\partial D}\end{array}\right]=\left[\begin{array}{cccccccc}
\frac{x-x_0}{\sigma_x^2}f(x, y) &amp;
\frac{y-y_0}{\sigma_y^2}f(x, y) &amp;
\frac{(x-x_0)^2}{\sigma_x^3}f(x, y) &amp;
\frac{(y-y_0)^2}{\sigma_y^3}f(x, y) &amp;
\frac{f(x, y)}{A} &amp;
x &amp; y &amp; 1\end{array}\right]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values to evaluate the Jacobian at as a length m array</p></li>
<li><p><strong>computed</strong> (<em>ndarray</em>) – The PSF evaluated at x and y as a length m array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Jacobian matrix as a mx8 numpy array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGaussianWBackground.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGaussianWBackground.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGaussianWBackground.fit" title="Link to this definition">¶</a></dt>
<dd><p>This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</p>
<p>The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the “height” of the gaussian
function).</p>
<p>The fit performed is for a 2D gaussian function of the form</p>
<div class="math notranslate nohighlight">
\[z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}
+Bx+Cy+D\]</div>
<p>The estimation in this function is performed iteratively.  First, the rough background is estimated and removed.
Then, a transformed fit is performed using the super class’s fit method on the data with the rough background
removed.  This initial fit is then refined using iterative non-linear least squares on the original data to
remove biases that might have been introduced in the non-iterative fit.</p>
<p>If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data
will be set to np.nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The initialized PSF with values according to the fit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussianWBackground.html#giant.point_spread_functions.gaussians.IterativeGaussianWBackground" title="giant.point_spread_functions.gaussians.IterativeGaussianWBackground"><em>IterativeGaussianWBackground</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.IterativeGaussianWBackground.update_state">
<span class="sig-name descname"><span class="pre">update_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/gaussians.html#IterativeGaussianWBackground.update_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.IterativeGaussianWBackground.update_state" title="Link to this definition">¶</a></dt>
<dd><p>Updates the current values based on the provided update vector.</p>
<p>The provided update vector is in the order of <span class="math notranslate nohighlight">\([x_0, y_0, \sigma_x, \sigma_y, A, B, C, D]\)</span>.</p>
<p>If the update vector is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> then sets everything to NaN to indicate a bad fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>update</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – The vector of additive updates to apply</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.point_spread_functions.</span></span><span class="sig-name descname"><span class="pre">Moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">centroid_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment" title="Link to this definition">¶</a></dt>
<dd><p>This class implements a moment based (center of illumination) algorithm for locating the centroid of a PSF.</p>
<p>This class implements a fully functional PSF object for GIANT, however, because it does not actually model how light
is spread out, if applied to an image or scan lines it just returns the input unaltered.  Also, since this isn’t
actually an estimation, the covariance and residuals are undefined so these are always set to NaN.</p>
<dl class="field-list simple">
<dt class="field-odd">Note<span class="colon">:</span></dt>
<dd class="field-odd"><p>This object can be biased toward the center of an image if it is applied naively.  You must be careful in
selecting which points to pass to this function.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>centroid_x</strong> (<em>float</em><em> | </em><em>None</em>) – The x component of the centroid in pixels</p></li>
<li><p><strong>centroid_y</strong> (<em>float</em><em> | </em><em>None</em>) – The y component of the centroid in pixels</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.apply_1d">
<span class="sig-name descname"><span class="pre">apply_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment.apply_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment.apply_1d" title="Link to this definition">¶</a></dt>
<dd><p>Just returns the input scan lines as is.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_1d</strong> (<em>ndarray</em>) – the scan lines to apply the PSF to</p></li>
<li><p><strong>direction</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>Any</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarT</em><em>]</em><em>] </em><em>| </em><em>None</em>) – the direction of the scan lines</p></li>
<li><p><strong>step</strong> (<em>float</em>) – the step size of the scan lines</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the unaltered scan lines</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.centroid">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centroid</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.centroid" title="Link to this definition">¶</a></dt>
<dd><p>The location of the center of the PSF as an (x, y) length 2 numpy array.</p>
<p>This property is used to enable the PSF class to be used in identifying the center of
illumination in image processing (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">ImageProcessing.centroiding</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The (x, y) location of the peak of the PSF as a 1D numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.covariance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">_ScalarT</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.covariance" title="Link to this definition">¶</a></dt>
<dd><p>The covariance of the fit (undefined).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A 2x2 array of NaN or <code class="docutils literal notranslate"><span class="pre">None</span></code> since this is undefined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment.evaluate" title="Link to this definition">¶</a></dt>
<dd><p>Returns an array of zeros the same shape of <code class="docutils literal notranslate"><span class="pre">x</span></code>/<code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values to evaluate at</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values to evaluate at</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of zeros</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.fit">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment.fit" title="Link to this definition">¶</a></dt>
<dd><p>This function identifies the centroid of the PSF for the input data using a moment algorithm (center of
illumination).</p>
<div class="math notranslate nohighlight">
\[x_0 = \frac{\sum{\mathbf{x}\mathbf{I}}}{\sum{\mathbf{I}}} \qquad
y_0 = \frac{\sum{\mathbf{y}\mathbf{I}}}{\sum{\mathbf{I}}}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The x values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>y</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The y values underlying the surface the PSF is to be fit to</p></li>
<li><p><strong>z</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – The z or “height” values of the surface the PSF is to be fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the PSF that best fits the provided data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.generate_kernel">
<span class="sig-name descname"><span class="pre">generate_kernel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment.generate_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment.generate_kernel" title="Link to this definition">¶</a></dt>
<dd><p>Returns a 3x3 array of zeros except the center which is one because this does nothing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The nothing kernel</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.residual_mean">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">residual_mean</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.residual_mean" title="Link to this definition">¶</a></dt>
<dd><p>The mean of the residuals (undefined).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>NaN or <code class="docutils literal notranslate"><span class="pre">None</span></code> since this is undefined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.residual_rss">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">residual_rss</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.residual_rss" title="Link to this definition">¶</a></dt>
<dd><p>The rss of the residuals (undefined).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>NaN or <code class="docutils literal notranslate"><span class="pre">None</span></code> since this is undefined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.residual_std">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">residual_std</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.residual_std" title="Link to this definition">¶</a></dt>
<dd><p>The standard deviation of the residuals (undefined).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>NaN or <code class="docutils literal notranslate"><span class="pre">None</span></code> since this is undefined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.shift_centroid">
<span class="sig-name descname"><span class="pre">shift_centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment.shift_centroid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment.shift_centroid" title="Link to this definition">¶</a></dt>
<dd><p>Shift the centroid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shift</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>) – the shift to apply as a len array like x, y</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.volume">
<span class="sig-name descname"><span class="pre">volume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/point_spread_functions/moments.html#Moment.volume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.point_spread_functions.Moment.volume" title="Link to this definition">¶</a></dt>
<dd><p>The volume is undefined for a moment PSF so just return 0</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>0</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.centroid_x">
<span class="sig-name descname"><span class="pre">centroid_x</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.centroid_x" title="Link to this definition">¶</a></dt>
<dd><p>The x location of the centroid</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.point_spread_functions.Moment.centroid_y">
<span class="sig-name descname"><span class="pre">centroid_y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#giant.point_spread_functions.Moment.centroid_y" title="Link to this definition">¶</a></dt>
<dd><p>The y location of the centroid</p>
</dd></dl>

</dd></dl>

<p class="rubric">Modules</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/giant.point_spread_functions.psf_meta.html#module-giant.point_spread_functions.psf_meta" title="giant.point_spread_functions.psf_meta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psf_meta</span></code></a></p></td>
<td><p>Provides abstract base classes for the construction of Point Spread Function classes for GIANT.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/giant.point_spread_functions.moments.html#module-giant.point_spread_functions.moments" title="giant.point_spread_functions.moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moments</span></code></a></p></td>
<td><p>Defines a PSF object for estimating centroids using a moment (center-of-illumination) algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/giant.point_spread_functions.gaussians.html#module-giant.point_spread_functions.gaussians" title="giant.point_spread_functions.gaussians"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussians</span></code></a></p></td>
<td><p>Defines PSF subclasses for representing/fitting various forms of 2D Gaussian functions.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Concrete Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/moments/giant.point_spread_functions.moments.Moment.html#giant.point_spread_functions.moments.Moment" title="giant.point_spread_functions.moments.Moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Moment</span></code></a></p></td>
<td><p>This class implements a moment based (center of illumination) algorithm for locating the centroid of a PSF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.html#giant.point_spread_functions.gaussians.Gaussian" title="giant.point_spread_functions.gaussians.Gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Gaussian</span></code></a></p></td>
<td><p>A class for representing and fitting a standard (non-rotated) 2D gaussian point spread function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussian.html#giant.point_spread_functions.gaussians.IterativeGaussian" title="giant.point_spread_functions.gaussians.IterativeGaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeGaussian</span></code></a></p></td>
<td><p>A class for representing and fitting a standard (non-rotated) 2D Gaussian point spread function using iterative non-linear least squares.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussianWBackground.html#giant.point_spread_functions.gaussians.IterativeGaussianWBackground" title="giant.point_spread_functions.gaussians.IterativeGaussianWBackground"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeGaussianWBackground</span></code></a></p></td>
<td><p>A class for representing and fitting the superposition of a standard (non-rotated) 2D Gaussian point spread function and a linear background gradiant using iterative non-linear least squares.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.html#giant.point_spread_functions.gaussians.GeneralizedGaussian" title="giant.point_spread_functions.gaussians.GeneralizedGaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneralizedGaussian</span></code></a></p></td>
<td><p>A class for representing and fitting a generalized (rotated) 2D gaussian point spread function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussian.html#giant.point_spread_functions.gaussians.IterativeGeneralizedGaussian" title="giant.point_spread_functions.gaussians.IterativeGeneralizedGaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeGeneralizedGaussian</span></code></a></p></td>
<td><p>A class for representing and fitting a generalized (rotated) 2D Gaussian point spread function using iterative non-linear least squares.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground.html#giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground" title="giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeGeneralizedGaussianWBackground</span></code></a></p></td>
<td><p>A class for representing and fitting the superposition of a standard (non-rotated) 2D Gaussian point spread function and a linear background gradiant using iterative non-linear least squares.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Abstract Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.PointSpreadFunction.html#giant.point_spread_functions.psf_meta.PointSpreadFunction" title="giant.point_spread_functions.psf_meta.PointSpreadFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PointSpreadFunction</span></code></a></p></td>
<td><p>This abstract base class serves as the template for implementing a point spread function in GIANT.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.SizedPSF.html#giant.point_spread_functions.psf_meta.SizedPSF" title="giant.point_spread_functions.psf_meta.SizedPSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SizedPSF</span></code></a></p></td>
<td><p>This ABC adds common functionality for a PSF where the required size can be determine algorithmically.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.KernelBasedCallPSF.html#giant.point_spread_functions.psf_meta.KernelBasedCallPSF" title="giant.point_spread_functions.psf_meta.KernelBasedCallPSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KernelBasedCallPSF</span></code></a></p></td>
<td><p>This ABC adds concrete common functionality for applying the initialized PSF to 2D images to <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction" title="giant.point_spread_functions.PointSpreadFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSpreadFunction</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.KernelBasedApply1DPSF.html#giant.point_spread_functions.psf_meta.KernelBasedApply1DPSF" title="giant.point_spread_functions.psf_meta.KernelBasedApply1DPSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KernelBasedApply1DPSF</span></code></a></p></td>
<td><p>This ABC adds concrete common functionality for applying the initialized PSF to 1D scan lines to <a class="reference internal" href="#giant.point_spread_functions.PointSpreadFunction" title="giant.point_spread_functions.PointSpreadFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointSpreadFunction</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.IterativeNonlinearLSTSQPSF.html#giant.point_spread_functions.psf_meta.IterativeNonlinearLSTSQPSF" title="giant.point_spread_functions.psf_meta.IterativeNonlinearLSTSQPSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQPSF</span></code></a></p></td>
<td><p>This ABC defines common attributes, properties, and methods for Iterative Non-linear least squares estimation of a Point Spread function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.IterativeNonlinearLSTSQwBackground.html#giant.point_spread_functions.psf_meta.IterativeNonlinearLSTSQwBackground" title="giant.point_spread_functions.psf_meta.IterativeNonlinearLSTSQwBackground"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQwBackground</span></code></a></p></td>
<td><p>This class provides support for estimating the superposition of the PSF and a linear background gradient.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.InitialGuessIterativeNonlinearLSTSQPSF.html#giant.point_spread_functions.psf_meta.InitialGuessIterativeNonlinearLSTSQPSF" title="giant.point_spread_functions.psf_meta.InitialGuessIterativeNonlinearLSTSQPSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InitialGuessIterativeNonlinearLSTSQPSF</span></code></a></p></td>
<td><p>This class provides a fit class method which generates the initial guess from a subclass and then converges to a better solution using iterative Nonlinear LSTSQ.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="point_spread_functions/psf_meta/giant.point_spread_functions.psf_meta.InitialGuessIterativeNonlinearLSTSQPSFwBackground.html#giant.point_spread_functions.psf_meta.InitialGuessIterativeNonlinearLSTSQPSFwBackground" title="giant.point_spread_functions.psf_meta.InitialGuessIterativeNonlinearLSTSQPSFwBackground"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InitialGuessIterativeNonlinearLSTSQPSFwBackground</span></code></a></p></td>
<td><p>This class provides a fit class method which generates the initial guess from a subclass and then converges to a better solution using iterative Nonlinear LSTSQ including a background gradient.</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="image/giant.image.OpNavImage.parse_data.html" title="Previous document">OpNavImage.parse_data</a>
        </li>
        <li>
          <a href="point_spread_functions/giant.point_spread_functions.psf_meta.html" title="Next document">giant.point_spread_functions.psf_meta</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>