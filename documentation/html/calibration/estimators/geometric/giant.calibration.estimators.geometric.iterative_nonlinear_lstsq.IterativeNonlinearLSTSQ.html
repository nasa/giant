<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>IterativeNonlinearLSTSQ &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="next" title="IterativeNonlinearLSTSQ.compute_residuals" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals.html" />
    <link rel="prev" title="IterativeNonlinearLstSqOptions" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../giant.html">API Reference</a><ul>
  <li><a href="../../../giant.calibration.html">giant.calibration</a><ul>
  <li><a href="../../giant.calibration.estimators.html">giant.calibration.estimators</a><ul>
      <li>Previous: <a href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions.html" title="previous chapter">IterativeNonlinearLstSqOptions</a></li>
      <li>Next: <a href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals.html" title="next chapter">IterativeNonlinearLSTSQ.compute_residuals</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions.html" title="Previous document">IterativeNonlinearLstSqOptions</a>
        </li>
        <li>
          <a href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals.html" title="Next document">IterativeNonlinearLSTSQ.compute_residuals</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="iterativenonlinearlstsq">
<h1>IterativeNonlinearLSTSQ<a class="headerlink" href="#iterativenonlinearlstsq" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.</span></span><span class="sig-name descname"><span class="pre">IterativeNonlinearLSTSQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/giant/calibration/estimators/geometric/iterative_nonlinear_lstsq.html#IterativeNonlinearLSTSQ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ" title="Link to this definition">¶</a></dt>
<dd><p>This concrete estimator implements iterative non-linear least squares for estimating an updated camera model.</p>
<p>Iterative non-linear least squares estimation is done by estimating updates to the “state” vector (in this case the
camera model parameters being updated) iteratively.  At each step, the system is linearized about the current
estimate of the state and the additive update is estimated.  This iteration is repeated until convergence (or
divergence) based on the pre/post update residuals and the update vector itself.</p>
<p>The state vector that is being estimated by this class is controlled by the
<a class="reference internal" href="../../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute of the provided camera model.  This class does not actually use
the <a class="reference internal" href="../../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute since it is handled by the
<a class="reference internal" href="../../../camera_model/giant.camera_models.camera_model.CameraModel.compute_jacobian.html#giant.camera_models.camera_model.CameraModel.compute_jacobian" title="giant.camera_models.camera_model.CameraModel.compute_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.compute_jacobian()</span></code></a> and <a class="reference internal" href="../../../camera_model/giant.camera_models.camera_model.CameraModel.apply_update.html#giant.camera_models.camera_model.CameraModel.apply_update" title="giant.camera_models.camera_model.CameraModel.apply_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.apply_update()</span></code></a> methods of the provided camera model
internally, but it is mentioned here to show how to control what exactly is being estimated.</p>
<p>Because this class linearizes about the current estimate of the state, it requires an initial guess for the camera
model that is “close enough” to the actual model to ensure convergence.  Defining “close enough” in any broad sense
is impossible, but based on experience, using the manufacturer defined specs for focal length/pixel pitch and
assuming no distortion is generally “close enough” even for cameras with heavy distortion (star identification may
require a better initial model than this anyway).</p>
<p>As this class converges the state estimate, it updates the supplied camera model in place, therefore, if you wish to
keep a copy of the original camera model, you should manually create a copy of it before calling the
<a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method on this class.</p>
<p>In the <a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method, convergence is checked on both the sum of squares of the residuals and the update
vector for the state.  That is convergence is reached when either of</p>
<div class="math notranslate nohighlight">
\begin{gather*}
\left\|\mathbf{r}_{pre}^T\mathbf{r}_{pre} - \mathbf{r}_{post}^T\mathbf{r}_{post}\right\|
\le(a_r+r_r\mathbf{r}_{pre}^T\mathbf{r}_{pre}) \\
\text{all}\left[\left\|\mathbf{u}\right\|\le(a_s+r_s\mathbf{s}_{pre})\right]
\end{gather*}</div><p>is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Here <span class="math notranslate nohighlight">\(\mathbf{r}_{pre}\)</span> is the nx1 vector of residuals before the update is applied,
<span class="math notranslate nohighlight">\(\mathbf{r}_{post}\)</span> is the nx1 vector of residuals after the update is applied, <span class="math notranslate nohighlight">\(a_r\)</span> is the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">residual_atol</span></code> absolute residual tolerance, <span class="math notranslate nohighlight">\(r_r\)</span> is the <code class="xref py py-attr docutils literal notranslate"><span class="pre">residual_rtol</span></code> relative residual
tolerance, <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> is the update vector, <span class="math notranslate nohighlight">\(\text{all}\)</span> indicates that the contained expression is
<code class="docutils literal notranslate"><span class="pre">True</span></code> for all elements, <span class="math notranslate nohighlight">\(a_s\)</span> is the <code class="xref py py-attr docutils literal notranslate"><span class="pre">state_atol</span></code> absolute tolerance for the state vector,
<span class="math notranslate nohighlight">\(r_s\)</span> is the <code class="xref py py-attr docutils literal notranslate"><span class="pre">state_rtol</span></code> relative tolerance for the state vector, and <span class="math notranslate nohighlight">\(\mathbf{s}_{pre}\)</span> is the
state vector before the update is applied.  Divergence is only checked on the sum of squares of the residuals, that
is, divergence is occurring when</p>
<div class="math notranslate nohighlight">
\[\mathbf{r}_{pre}^T\mathbf{r}_{pre} &lt; \mathbf{r}_{post}^T\mathbf{r}_{post}\]</div>
<p>where all is as defined as before.  If a case is diverging then a warning will be printed, the iteration will cease,
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Typically this class is not used by the user, and instead it is used internally by the <a class="reference internal" href="../../calibration_class/giant.calibration.calibration_class.Calibration.html#giant.calibration.calibration_class.Calibration" title="giant.calibration.calibration_class.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class
which handles data preparation for you. If you wish to use this externally from the <a class="reference internal" href="../../calibration_class/giant.calibration.calibration_class.Calibration.html#giant.calibration.calibration_class.Calibration" title="giant.calibration.calibration_class.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class you
must first set</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code> <em>if</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code> <em>is</em> <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_state_covariance</span></code> <em>if</em> <a class="reference internal" href="../../../camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">use_a_priori</span></code></a> <em>is set to</em> <code class="docutils literal notranslate"><span class="pre">True</span></code> for the camera
model.</p></li>
</ul>
<p>according to their documentation.  Once those have been set, you can perform the estimation using <a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
which will iterate until convergence (or divergence).  If the fit successfully converges, <code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code> will be
set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code> will both return numpy
arrays instead of <code class="docutils literal notranslate"><span class="pre">None</span></code>.  If you wish to use the same instance of this class to do another estimation you should
call <a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.reset.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.reset" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> before setting the new data to ensure that data is not mixed between estimation runs and all
flags are set correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>ModelT</em>) – The camera model instance to be estimated set with an initial guess of the state.</p></li>
<li><p><strong>options</strong> (<a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions"><em>IterativeNonlinearLstSqOptions</em></a><em> | </em><em>None</em>) – the dataclass containing the options to configure the class with</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ.compute_residuals</span></code></a></p></td>
<td><p>This method computes the observed minus computed residuals for the current model (or an input model).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ.estimate</span></code></a></p></td>
<td><p>Estimates an updated camera model that better transforms the camera frame directions into pixel locations to minimize the residuals between the observed and the predicted star locations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.reset.html#giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.reset" title="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ.reset</span></code></a></p></td>
<td><p>This method resets all of the data attributes to their default values to prepare for another estimation.</p></td>
</tr>
</tbody>
</table>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLstSqOptions.html" title="Previous document">IterativeNonlinearLstSqOptions</a>
        </li>
        <li>
          <a href="giant.calibration.estimators.geometric.iterative_nonlinear_lstsq.IterativeNonlinearLSTSQ.compute_residuals.html" title="Next document">IterativeNonlinearLSTSQ.compute_residuals</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>