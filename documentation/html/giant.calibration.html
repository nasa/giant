
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>giant.calibration &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="_static/logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="giant.calibration.calibration_class" href="calibration/giant.calibration.calibration_class.html" />
    <link rel="prev" title="giant.catalogues.utilities.MJD_EPOCH" href="catalogues/utilities/giant.catalogues.utilities.MJD_EPOCH.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="giant.html">API Reference</a><ul>
      <li>Previous: <a href="catalogues/utilities/giant.catalogues.utilities.MJD_EPOCH.html" title="previous chapter">giant.catalogues.utilities.MJD_EPOCH</a></li>
      <li>Next: <a href="calibration/giant.calibration.calibration_class.html" title="next chapter">giant.calibration.calibration_class</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="catalogues/utilities/giant.catalogues.utilities.MJD_EPOCH.html" title="Previous document">giant.catalogues.utilities.MJD_EPOCH</a>
        </li>
        <li>
          <a href="calibration/giant.calibration.calibration_class.html" title="Next document">giant.calibration.calibration_class</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="module-giant.calibration">
<span id="giant-calibration"></span><h1>giant.calibration<a class="headerlink" href="#module-giant.calibration" title="Permalink to this headline">¶</a></h1>
<p>This package provides the required routines and objects to identify stars in an image and then estimate attitude, camera
pointing alignment, and geometric camera model calibration using the observed stars.</p>
<section id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>In GIANT, calibration refers primarily to the process of using identified stars in multiple images to estimate the
geometric camera calibration and camera frame alignment.  There are many different sub-steps that need to be performed
for this, particularly with respect to identifying the stars in the image, which can lead to cluttered scripts and hard
to maintain code when everything is thrown together manually.  Luckily, GIANT has done most of this nitty gritty work
for us by creating a simple, single interface in the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class.</p>
<p>The <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class is a subclass of the <a class="reference internal" href="stellar_opnav/stellar_class/giant.stellar_opnav.stellar_class.StellarOpNav.html#giant.stellar_opnav.stellar_class.StellarOpNav" title="giant.stellar_opnav.stellar_class.StellarOpNav"><code class="xref py py-class docutils literal notranslate"><span class="pre">StellarOpNav</span></code></a> class, which provides the functionality for
identifying stars and estimating updated attitude information for single images.  In addition to the
<a class="reference internal" href="stellar_opnav/stellar_class/giant.stellar_opnav.stellar_class.StellarOpNav.html#giant.stellar_opnav.stellar_class.StellarOpNav" title="giant.stellar_opnav.stellar_class.StellarOpNav"><code class="xref py py-class docutils literal notranslate"><span class="pre">StellarOpNav</span></code></a> functionality, the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class also provides the interfaces for using identified
stars in multiple images to estimate updates to geometric camera model (camera calibration,
<a class="reference internal" href="#giant.calibration.Calibration.estimate_calibration" title="giant.calibration.Calibration.estimate_calibration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_calibration()</span></code></a>) and the alignment between the camera frame and a base frame
(<a class="reference internal" href="#giant.calibration.Calibration.estimate_static_alignment" title="giant.calibration.Calibration.estimate_static_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_static_alignment()</span></code></a> and <a class="reference internal" href="#giant.calibration.Calibration.estimate_temperature_dependent_alignment" title="giant.calibration.Calibration.estimate_temperature_dependent_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_temperature_dependent_alignment()</span></code></a>).
While these methods make it easy to get everything packaged appropriately, GIANT also exposes all of the substeps to you
if you need them to do a more advanced analysis.</p>
<p>This package level documentation focuses specifically on using the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class along with tips for
successfully doing camera calibration and alignment.  For more details about what exactly is happening, refer to the
documentation for the submodules from this package.</p>
</section>
<section id="tuning-for-successful-calibration">
<h2>Tuning for Successful Calibration<a class="headerlink" href="#tuning-for-successful-calibration" title="Permalink to this headline">¶</a></h2>
<p>As with <a class="reference internal" href="giant.stellar_opnav.html#module-giant.stellar_opnav" title="giant.stellar_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stellar_opnav</span></code></a>, tuning the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class is both science and art.  Indeed, tuning for
calibration is nearly the same as tuning for stellar OpNav, therefore we urge you to start with the
<a class="reference internal" href="giant.stellar_opnav.html#module-giant.stellar_opnav" title="giant.stellar_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stellar_opnav</span></code></a> documentation before proceeding with this documentation.  Once you are familiar with tuning for
stellar OpNav, then tuning for calibration will be fairly straight forward.</p>
<p>There are 2 main differences between tuning for calibration and tuning for stellar OpNav.  First, with calibration we
typically are considering many different view conditions across various temperatures and with various amounts of stray
light, which may make it difficult to find a single tuning that works to ID stars in all images under consideration.
The best way to work around this issue is to group the images into similar exposure times, temperatures, and stray light
patterns and figure out tuning for each of these groups independently using the recommended steps in
<a class="reference internal" href="giant.stellar_opnav.html#module-giant.stellar_opnav" title="giant.stellar_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stellar_opnav</span></code></a>.  The <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class makes this process easy by providing the method
<a class="reference internal" href="calibration/calibration_class/giant.calibration.calibration_class.Calibration.add_images.html#giant.calibration.calibration_class.Calibration.add_images" title="giant.calibration.calibration_class.Calibration.add_images"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_images()</span></code></a> which, when coupled with calls to <a class="reference internal" href="camera/giant.camera.Camera.all_on.html#giant.camera.Camera.all_on" title="giant.camera.Camera.all_on"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Camera.all_on()</span></code></a> and <a class="reference internal" href="camera/giant.camera.Camera.all_off.html#giant.camera.Camera.all_off" title="giant.camera.Camera.all_off"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Camera.all_off()</span></code></a>
makes it easy to add/consider groups of images one by one, storing the results of images that have already been
processed.</p>
<p>The second main difference between calibration and stellar OpNav is that in calibration, particularly for the camera
model estimation, we typically want as many stars as possible extracted from each image instead of just finding the
brightest stars in the image.  The best way to handle this is to work iteratively, where you first tune for getting just
bright stars and estimate and update to the attitude (and possibly the camera model if it had a poor initial guess) and
then, when you have better a priori, turn off the RANSAC feature of the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class and identify dimmer
stars.  Once this has been done you can then re-estimate an update to the camera model (and maybe the pointing for each
image).</p>
<p>The only other real tuning that might need to be done is choosing which parameters are estimated as part of the
geometric camera model calibration, which is done through the <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute. For
many of the camera models, some of the parameters are highly correlated with each other and it is not recommended to
attempt to simultaneously estimate them unless you have a very large dataset to help break the correlation (for instance
misalignment and the principal point for the camera can be highly correlated unless you have a lot of images at
different viewing conditions).  Further details about good subsets of elements to estimate in calibration is included
with the documentation for the camera models provided with GIANT.</p>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Below shows how calibration can be used to id stars, estimate attitude corrections, estimate a camera model, and
estimate alignment.  It assumes that the <a class="reference internal" href="scripts/giant.scripts.generate_sample_data.html#module-giant.scripts.generate_sample_data" title="giant.scripts.generate_sample_data"><code class="xref py py-mod docutils literal notranslate"><span class="pre">generate_sample_data</span></code></a> script has already be run and that the
<code class="docutils literal notranslate"><span class="pre">sample_data</span></code> directory is in the current working directory.  For an in depth example using real images see the
tutorial.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># use pathlib and pickle to get the data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;sample_data&quot;</span> <span class="o">/</span> <span class="s2">&quot;camera.pickle&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">data</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pfile</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">camera</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># import the stellar opnav class</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">giant.calibration.calibration_class</span> <span class="kn">import</span> <span class="n">Calibration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># import the default catalogue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">giant.catalogues.giant_catalogue</span> <span class="kn">import</span> <span class="n">GIANTCatalogue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set the estimation parameters for the camera model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">estimation_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fx&quot;</span><span class="p">,</span> <span class="s2">&quot;fy&quot;</span><span class="p">,</span> <span class="s2">&quot;px&quot;</span><span class="p">,</span> <span class="s2">&quot;py&quot;</span><span class="p">,</span> <span class="s2">&quot;k1&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># form the calibration object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span> <span class="o">=</span> <span class="n">Calibration</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">image_processing_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;centroid_size&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;poi_threshold&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="n">star_identification_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;max_magnitude&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># identify stars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">id_stars</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">sid_summary</span><span class="p">()</span>  <span class="c1"># print a summary of the star id results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate an update the attitude for each image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">estimate_attitude</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># update the star id settings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">star_id</span><span class="o">.</span><span class="n">max_magnitude</span> <span class="o">=</span> <span class="mf">5.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">star_id</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">star_id</span><span class="o">.</span><span class="n">max_combos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># identify stars again to get dimmer stars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">id_stars</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># import the visualizer to look at the results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">giant.stellar_opnav.visualizer</span> <span class="kn">import</span> <span class="n">show_id_results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show_id_results</span><span class="p">(</span><span class="n">cal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate the geometric camera model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">estimate_calibration</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">calib_summary</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.Calibration">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">Calibration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">camera</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_processing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_processing_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_id_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment_base_frame_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attitude_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attitude_estimator_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_alignment_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_alignment_estimator_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature_dependent_alignment_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature_dependent_alignment_estimator_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibration_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibration_estimator_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="stellar_opnav/stellar_class/giant.stellar_opnav.stellar_class.StellarOpNav.html#giant.stellar_opnav.stellar_class.StellarOpNav" title="giant.stellar_opnav.stellar_class.StellarOpNav"><code class="xref py py-class docutils literal notranslate"><span class="pre">giant.stellar_opnav.stellar_class.StellarOpNav</span></code></a></p>
<p>This class serves as the main user interface for performing geometric camera calibration and camera frame attitude
alignment.</p>
<p>The class acts as a container for the <a class="reference internal" href="camera/giant.camera.Camera.html#giant.camera.Camera" title="giant.camera.Camera"><code class="xref py py-class docutils literal notranslate"><span class="pre">Camera</span></code></a>, <a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing" title="giant.image_processing.ImageProcessing"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageProcessing</span></code></a>, and
<a class="reference internal" href="stellar_opnav/giant.stellar_opnav.estimators.html#module-giant.stellar_opnav.estimators" title="giant.stellar_opnav.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stellar_opnav.estimators</span></code></a>, <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration.estimators</span></code></a> objects and also passes the correct and up-to-date
data from one object to the other. In general, this class will be the exclusive interface to the mentioned objects
and models for the user.</p>
<p>This class provides a number of features that make doing stellar OpNav and camera calibration/alignment easy.  The
first is it provides aliases to the image processing, star id, attitude estimation, calibration estimation, and
alignment estimation objects. These aliases make it easy to quickly change/update the various tuning parameters that
are necessary to make star identification and calibration a success. In addition to providing convenient access to
the underlying settings, some of these aliases also update internal flags that specify whether individual images
need to be reprocessed, saving computation time when you’re trying to find the best tuning.</p>
<p>This class also provides simple methods for performing star identification, attitude estimation, camera calibration,
and aligment estimation after you have set the tuning parameters. These methods (<code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">sid_summary()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_attitude()</span></code>, <a class="reference internal" href="#giant.calibration.Calibration.estimate_calibration" title="giant.calibration.Calibration.estimate_calibration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_calibration()</span></code></a>, <a class="reference internal" href="#giant.calibration.Calibration.calib_summary" title="giant.calibration.Calibration.calib_summary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calib_summary()</span></code></a>,
<a class="reference internal" href="#giant.calibration.Calibration.estimate_static_alignment" title="giant.calibration.Calibration.estimate_static_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_static_alignment()</span></code></a>, and <a class="reference internal" href="#giant.calibration.Calibration.estimate_temperature_dependent_alignment" title="giant.calibration.Calibration.estimate_temperature_dependent_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_temperature_dependent_alignment()</span></code></a>) combine all of the
required steps into a few simple calls, and pass the resulting data from one object to the next. They also store off
the results of the star identification in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_image_points</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_unit_vectors</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">ip_extracted_image_points</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ip_image_illums</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">ip_psfs</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">ip_stats</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">ip_snrs</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_image_points</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_image_illums</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_psfs</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_stats</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_snrs</span></code>
<code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_star_records</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_unit_vectors</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_extracted_image_points</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_image_points</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_image_illums</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_psfs</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_stats</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_snrs</span></code>
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_unit_vectors_inertial</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_unit_vectors_camera</span></code>, and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_extracted_image_points</span></code> attributes, enabling more advanced analysis to be performed external to the
class.</p>
<p>This class stores the updated attitude solutions in the image objects themselves, allowing you to directly
pass your images from stellar OpNav to the <a class="reference internal" href="giant.relative_opnav.html#module-giant.relative_opnav" title="giant.relative_opnav"><code class="xref py py-mod docutils literal notranslate"><span class="pre">relative_opnav</span></code></a> routines with updated attitude solutions. It also
stores the estimated camera model in the original camera model itself, and store the estimated alignments in the
<a class="reference internal" href="#giant.calibration.Calibration.static_alignment" title="giant.calibration.Calibration.static_alignment"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment</span></code></a> and <a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment" title="giant.calibration.Calibration.temperature_dependent_alignment"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment</span></code></a> attributes. Finally, this class
respects the <a class="reference internal" href="camera/giant.camera.Camera.html#giant.camera.Camera.image_mask" title="giant.camera.Camera.image_mask"><code class="xref py py-attr docutils literal notranslate"><span class="pre">image_mask</span></code></a> attribute of the <a class="reference internal" href="camera/giant.camera.Camera.html#giant.camera.Camera" title="giant.camera.Camera"><code class="xref py py-class docutils literal notranslate"><span class="pre">Camera</span></code></a> object, only considering images that are
currently turned on.</p>
<p>When initializing this class, most of the initial options can be set using the <code class="docutils literal notranslate"><span class="pre">*_kwargs</span></code> inputs with
dictionaries specifying the keyword arguments and values. Alternatively, you can provide already initialized
instances of the <a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing" title="giant.image_processing.ImageProcessing"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageProcessing</span></code></a>, <a class="reference internal" href="stellar_opnav/estimators/giant.stellar_opnav.estimators.AttitudeEstimator.html#giant.stellar_opnav.estimators.AttitudeEstimator" title="giant.stellar_opnav.estimators.AttitudeEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AttitudeEstimator</span></code></a>, <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a>,
<a class="reference internal" href="#giant.calibration.CalibrationEstimator" title="giant.calibration.CalibrationEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibrationEstimator</span></code></a>, <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator" title="giant.calibration.StaticAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticAlignmentEstimator</span></code></a>, or
<a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator" title="giant.calibration.TemperatureDependentAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemperatureDependentAlignmentEstimator</span></code></a> classes or subclasses
if you want a little more control.  You should see the documentation for these classes for more details on what you
can do with them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>camera</strong> (<a class="reference internal" href="camera/giant.camera.Camera.html#giant.camera.Camera" title="giant.camera.Camera"><em>giant.camera.Camera</em></a>) – The <a class="reference internal" href="camera/giant.camera.Camera.html#giant.camera.Camera" title="giant.camera.Camera"><code class="xref py py-class docutils literal notranslate"><span class="pre">Camera</span></code></a> object containing the camera model and images to be utilized</p></li>
<li><p><strong>use_weights</strong> (<em>bool</em>) – A flag specifying whether to use weighted estimation for attitude, alignment, and
calibration</p></li>
<li><p><strong>alignment_base_frame_func</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>]</em>) – A callable object which returns the orientation of the base frame with respect
to the inertial frame the alignment of the camera frame is to be done with
respect to for a given date.</p></li>
<li><p><strong>image_processing</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing" title="giant.image_processing.ImageProcessing"><em>giant.image_processing.ImageProcessing</em></a><em>]</em>) – An already initialized instance of <a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing" title="giant.image_processing.ImageProcessing"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageProcessing</span></code></a> (or a subclass).  If not
<code class="docutils literal notranslate"><span class="pre">None</span></code> then <code class="docutils literal notranslate"><span class="pre">image_processing_kwargs</span></code> are ignored.</p></li>
<li><p><strong>image_processing_kwargs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The keyword arguments to pass to the <a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing" title="giant.image_processing.ImageProcessing"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageProcessing</span></code></a> class
constructor.  These are ignored if argument <code class="docutils literal notranslate"><span class="pre">image_processing</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><strong>star_id</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.html#giant.stellar_opnav.star_identification.StarID" title="giant.stellar_opnav.star_identification.StarID"><em>giant.stellar_opnav.star_identification.StarID</em></a><em>]</em>) – An already initialized instance of <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> (or a subclass).  If not
<code class="docutils literal notranslate"><span class="pre">None</span></code> then <code class="docutils literal notranslate"><span class="pre">star_id_kwargs</span></code> are ignored.</p></li>
<li><p><strong>star_id_kwargs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The keyword arguments to pass to the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class constructor as
a dictionary.  These are ignored if argument <code class="docutils literal notranslate"><span class="pre">star_id</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>attitude_estimator</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="stellar_opnav/estimators/giant.stellar_opnav.estimators.AttitudeEstimator.html#giant.stellar_opnav.estimators.AttitudeEstimator" title="giant.stellar_opnav.estimators.AttitudeEstimator"><em>giant.stellar_opnav.estimators.AttitudeEstimator</em></a><em>]</em>) – An already initialized instance of <a class="reference internal" href="stellar_opnav/estimators/giant.stellar_opnav.estimators.AttitudeEstimator.html#giant.stellar_opnav.estimators.AttitudeEstimator" title="giant.stellar_opnav.estimators.AttitudeEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AttitudeEstimator</span></code></a> (or a subclass).  If
not <code class="docutils literal notranslate"><span class="pre">None</span></code> then <code class="docutils literal notranslate"><span class="pre">attitude_estimator_kwargs</span></code> are ignored.</p></li>
<li><p><strong>attitude_estimator_kwargs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The keyword arguments to pass to the <a class="reference internal" href="#giant.calibration.DavenportQMethod" title="giant.calibration.DavenportQMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">DavenportQMethod</span></code></a>
constructor as a dictionary.  If argument <code class="docutils literal notranslate"><span class="pre">attitude_estimator</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code> then this is ignored.</p></li>
<li><p><strong>static_alignment_estimator</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="calibration/estimators/giant.calibration.estimators.StaticAlignmentEstimator.html#giant.calibration.estimators.StaticAlignmentEstimator" title="giant.calibration.estimators.StaticAlignmentEstimator"><em>giant.calibration.estimators.StaticAlignmentEstimator</em></a><em>]</em>) – An already initialized instance of <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator" title="giant.calibration.StaticAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticAlignmentEstimator</span></code></a> (or a
subclass).  If not <code class="docutils literal notranslate"><span class="pre">None</span></code> then <code class="docutils literal notranslate"><span class="pre">static_alignment_estimator_kwargs</span></code> are
ignored.</p></li>
<li><p><strong>static_alignment_estimator_kwargs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The keyword arguments to pass to the
<a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator" title="giant.calibration.StaticAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticAlignmentEstimator</span></code></a> constructor as a dictionary.  If
argument <code class="docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code> then this is
ignored.</p></li>
<li><p><strong>temperature_dependent_alignment_estimator</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="calibration/estimators/giant.calibration.estimators.TemperatureDependentAlignmentEstimator.html#giant.calibration.estimators.TemperatureDependentAlignmentEstimator" title="giant.calibration.estimators.TemperatureDependentAlignmentEstimator"><em>giant.calibration.estimators.TemperatureDependentAlignmentEstimator</em></a><em>]</em>) – An already initialized instance of
<a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator" title="giant.calibration.TemperatureDependentAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemperatureDependentAlignmentEstimator</span></code></a> (or a
subclass).  If not <code class="docutils literal notranslate"><span class="pre">None</span></code> then
<code class="docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator_kwargs</span></code> are
ignored.</p></li>
<li><p><strong>temperature_dependent_alignment_estimator_kwargs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The keyword arguments to pass to the
<a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator" title="giant.calibration.TemperatureDependentAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemperatureDependentAlignmentEstimator</span></code></a>
constructor as a dictionary.  If argument
<code class="docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code> then this is ignored.</p></li>
<li><p><strong>calibration_estimator</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="calibration/estimators/giant.calibration.estimators.CalibrationEstimator.html#giant.calibration.estimators.CalibrationEstimator" title="giant.calibration.estimators.CalibrationEstimator"><em>giant.calibration.estimators.CalibrationEstimator</em></a><em>]</em>) – An already initialized instance of <a class="reference internal" href="#giant.calibration.CalibrationEstimator" title="giant.calibration.CalibrationEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibrationEstimator</span></code></a> (or a
subclass).  If not <code class="docutils literal notranslate"><span class="pre">None</span></code> then <code class="docutils literal notranslate"><span class="pre">calibration_estimator_kwargs</span></code> are ignored.</p></li>
<li><p><strong>calibration_estimator_kwargs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The keyword arguments to pass to the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ" title="giant.calibration.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a>
constructor as a dictionary.  If argument <code class="docutils literal notranslate"><span class="pre">static_alignment_estimator</span> <span class="pre">is</span>
<span class="pre">not</span> <span class="pre">``None</span></code> then this is ignored.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.Calibration.alignment_base_frame_func">
<span class="sig-name descname"><span class="pre">alignment_base_frame_func</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.Calibration.alignment_base_frame_func" title="Permalink to this definition">¶</a></dt>
<dd><p>A callable object which returns the orientation of the base frame with respect  
to the inertial frame the alignment of the camera frame is to be done with      
respect to for a given date.</p>
<p>This is used on calls to <a class="reference internal" href="#giant.calibration.Calibration.estimate_static_alignment" title="giant.calibration.Calibration.estimate_static_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_static_alignment()</span></code></a> and :meth`estimate_temperature_dependent_alignment` 
to determine the base frame the alignment is being done with respect to.  Typically this returns something like 
the spacecraft body frame with respect to the inertial frame (inertial to spacecraft body) or another camera 
frame.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.Calibration.static_alignment">
<span class="sig-name descname"><span class="pre">static_alignment</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Rotation</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.Calibration.static_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>The static alignment as a <a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object.</p>
<p>This will be none until the <a class="reference internal" href="#giant.calibration.Calibration.estimate_static_alignment" title="giant.calibration.Calibration.estimate_static_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_static_alignment()</span></code></a> method is called at which point it will contain 
the estimated alignment.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.Calibration.temperature_dependent_alignment">
<span class="sig-name descname"><span class="pre">temperature_dependent_alignment</span></span><em class="property"><span class="pre">:</span> <span class="pre">NONEARRAY</span></em><a class="headerlink" href="#giant.calibration.Calibration.temperature_dependent_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>The temperature dependent alignment as a 3x2 numpy array.</p>
<p>The temperature dependent alignment array is stored such that the first column is the
static offset for the alignment, the second column is the temperature dependent slope, and each row represents
the euler angle according to the requested order (so if the requested order is <code class="docutils literal notranslate"><span class="pre">'xyx'</span></code> then the rotation from
the base frame to the camera frame at temperature <code class="docutils literal notranslate"><span class="pre">t</span></code> can be computed using:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">giant.rotations</span> <span class="kn">import</span> <span class="n">euler_to_rotmat</span><span class="p">,</span> <span class="n">Rotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature_dependent_alignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># temp array just to demonstrate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mf">22.5</span>  <span class="c1"># temp temperature just to demonstrate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span><span class="n">temperature_dependent_alignment</span><span class="o">@</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;xyx&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotation_base_to_camera</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">euler_to_rotmat</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.Calibration.model">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">model</span></span><em class="property"><span class="pre">:</span> <span class="pre">giant.camera_models.camera_model.CameraModel</span></em><a class="headerlink" href="#giant.calibration.Calibration.model" title="Permalink to this definition">¶</a></dt>
<dd><p>This alias returns the current camera model from the camera attribute.</p>
<p>It is provided for convenience since the camera model is used frequently.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.Calibration.calibration_estimator">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">calibration_estimator</span></span><em class="property"><span class="pre">:</span> <span class="pre">giant.calibration.estimators.CalibrationEstimator</span></em><a class="headerlink" href="#giant.calibration.Calibration.calibration_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The calibration estimator to use when estimating the geometric calibration</p>
<p>This should typically be a subclass of the <a class="reference internal" href="#giant.calibration.CalibrationEstimator" title="giant.calibration.CalibrationEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibrationEstimator</span></code></a> meta class.</p>
<p>See the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">estimators</span></code></a> documentation for more details.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.Calibration.static_alignment_estimator">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">static_alignment_estimator</span></span><em class="property"><span class="pre">:</span> <span class="pre">giant.calibration.estimators.StaticAlignmentEstimator</span></em><a class="headerlink" href="#giant.calibration.Calibration.static_alignment_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The static alignment estimator to use when estimating the static alignment</p>
<p>This should typically be a subclass of the <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator" title="giant.calibration.StaticAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticAlignmentEstimator</span></code></a> class.</p>
<p>See the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">estimators</span></code></a> documentation for more details.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.Calibration.temperature_dependent_alignment_estimator">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">temperature_dependent_alignment_estimator</span></span><em class="property"><span class="pre">:</span> <span class="pre">giant.calibration.estimators.TemperatureDependentAlignmentEstimator</span></em><a class="headerlink" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The temperature_dependent_alignment estimator to use when estimating the temperature_dependent_alignment</p>
<p>This should typically be a subclass of the <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator" title="giant.calibration.TemperatureDependentAlignmentEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemperatureDependentAlignmentEstimator</span></code></a> class.</p>
<p>See the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">estimators</span></code></a> documentation for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.estimate_calibration">
<span class="sig-name descname"><span class="pre">estimate_calibration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.estimate_calibration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.estimate_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method estimates an updated camera model using all stars identified in all images that are turned on.</p>
<p>For each turned on image in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">camera</span></code> attribute, this method provides the <a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a>
with the <code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_extracted_image_points</span></code>, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_unit_vectors_camera</span></code>, and
optionally the <code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_weights_picture</span></code> if <a class="reference internal" href="#giant.calibration.Calibration.use_weights" title="giant.calibration.Calibration.use_weights"><code class="xref py py-attr docutils literal notranslate"><span class="pre">use_weights</span></code></a> is <code class="docutils literal notranslate"><span class="pre">True</span></code>. The
<a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method is then called and the resulting updated camera model is stored
in the <a class="reference internal" href="#giant.calibration.Calibration.model" title="giant.calibration.Calibration.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> attribute.  Finally, the updated camera model is used to update the following:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_image_points</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_image_points</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_image_points</span></code></p></li>
</ul>
<p>For a more thorough description of the calibration estimation routines see the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration.estimators</span></code></a>
documentation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method overwrites the camera model information in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">camera</span></code> attribute and
does not save old information anywhere.  If you want this information saved be sure to store it yourself.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.estimate_static_alignment">
<span class="sig-name descname"><span class="pre">estimate_static_alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.estimate_static_alignment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.estimate_static_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>This method estimates a static (not temeprature dependent) alignment between a base frame and the camera frame
over multiple images.</p>
<p>This method uses the <a class="reference internal" href="#giant.calibration.Calibration.alignment_base_frame_func" title="giant.calibration.Calibration.alignment_base_frame_func"><code class="xref py py-attr docutils literal notranslate"><span class="pre">alignment_base_frame_func</span></code></a> to retrieve the rotation from the inertial frame to the
base frame the alignment is to be done with respect to for each image time. The inertial matched catalogue unit
vectors are then rotated into the base frame. Then, the matched image points-of-interest are converted to unit
vectors in the camera frame. These 2 sets of unit vectors are then provided to the
<a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a> and its <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator.estimate" title="giant.calibration.StaticAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method is called to
estimate the alignment between the frames.  The resulting alignment is stored in the <a class="reference internal" href="#giant.calibration.Calibration.static_alignment" title="giant.calibration.Calibration.static_alignment"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment</span></code></a>
attribute.</p>
<p>Note that to do alignment, the base frame and the camera frame should generally be fixed with respect to one
another.  This means that you can’t do alignment with respect to something like the inertial frame in general,
unless your camera is magically fixed with respect to the inertial frame.</p>
<p>Generally, this method should be called after you have estimated the geometric camera model, because the
geometric camera model is used to convert the observed pixel locations in the image to unit vectors in the
camera frame (using <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.pixels_to_unit.html#giant.camera_models.camera_model.CameraModel.pixels_to_unit" title="giant.camera_models.camera_model.CameraModel.pixels_to_unit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pixels_to_unit()</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method will attempt to account for misalignment estimated along with the camera model when performing
the estimation; however, this is not recommended. Instead, once you have performed your camera model
calibration, you should consider resetting the camera model misalignment to 0 and then calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_attitude()</span></code> before a call to this function.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.Calibration.use_weights">
<span class="sig-name descname"><span class="pre">use_weights</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.Calibration.use_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag specifying whether to compute weights/use them in the attitude estimation routine</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.Calibration.process_stars">
<span class="sig-name descname"><span class="pre">process_stars</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.Calibration.process_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>This list contains a boolean specifying whether the corresponding image needs to be processed using image 
processing again.</p>
<p>This typically is automatically updated and you shouldn’t have to worry about it.  It is included for speed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.estimate_temperature_dependent_alignment">
<span class="sig-name descname"><span class="pre">estimate_temperature_dependent_alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.estimate_temperature_dependent_alignment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.estimate_temperature_dependent_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>This method estimates a temperature dependent (not static) alignment between a base frame and the camera frame
over multiple images.</p>
<p>This method uses the <a class="reference internal" href="#giant.calibration.Calibration.alignment_base_frame_func" title="giant.calibration.Calibration.alignment_base_frame_func"><code class="xref py py-attr docutils literal notranslate"><span class="pre">alignment_base_frame_func</span></code></a> to retrieve the rotation from the inertial frame to the
base frame the alignment is to be done with respect to for each image time. Then, the rotation from the
inertial frame to the camera frame is retrieved for each image from the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Image.rotation_inertial_to_camera</span></code> attribute for each image (which is updated by a call to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_attitude()</span></code>).  These frame definitions are then provided to the
<a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="giant.calibration.Calibration.temperature_dependent_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code></a> whose
<a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method is then called to estimate the temperature
dependent alignment.  The estimated alignment is then stored as a 3x2 numpy array where the first column is the
static offset for the alignment, the second column is the temperature dependent slope, and each row represents
the euler angle according to the requested order (so if the requested order is <code class="docutils literal notranslate"><span class="pre">'xyx'</span></code> then the rotation from
the base frame to the camera frame at temperature <code class="docutils literal notranslate"><span class="pre">t</span></code> can be computed using:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">giant.rotations</span> <span class="kn">import</span> <span class="n">euler_to_rotmat</span><span class="p">,</span> <span class="n">Rotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">giant.calibration.calibration_class</span> <span class="kn">import</span> <span class="n">Calibration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span> <span class="o">=</span> <span class="n">Calibration</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cal</span><span class="o">.</span><span class="n">estimate_temperature_dependent_alignment</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mf">22.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="n">cal</span><span class="o">.</span><span class="n">temperature_dependent_alignment</span><span class="o">@</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">order</span> <span class="o">=</span> <span class="n">cal</span><span class="o">.</span><span class="n">temperature_dependent_alignment_estimator</span><span class="o">.</span><span class="n">order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotation_base_to_camera</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">euler_to_rotmat</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
</pre></div>
</div>
<p>This example is obviously incomplete but gives the concept of how things could be used.</p>
<p>Note that to do alignment, the base frame and the camera frame should generally be fixed with respect to one
another (with the exception of small variations with temperature).  This means that you can’t do alignment with
respect to something like the inertial frame in general, unless your camera is magically fixed with respect to
the inertial frame.</p>
<p>Generally, this method should be called after you have estimated the attitude for each image, because the
estimated image pointing is used to estimate the alignment.  As such, only images where there are successfully
matched stars are used in the estimation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method will attempt to account for misalignment estimated along with the camera model when performing
the estimation; however, this is not recommended. Instead, once you have performed your camera model
calibration, you should consider resetting the camera model misalignment to 0 and then calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_attitude()</span></code> before a call to this function.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.reset_calibration_estimator">
<span class="sig-name descname"><span class="pre">reset_calibration_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.reset_calibration_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.reset_calibration_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>This method resets the existing calibration estimator instance with a new instance using the initial
<code class="docutils literal notranslate"><span class="pre">calibration_estimator_update</span></code> argument passed to the constructor.</p>
<p>A new instance of the object is created, therefore there is no backwards reference whatsoever to the state
before a call to this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.update_calibration_estimator">
<span class="sig-name descname"><span class="pre">update_calibration_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calibration_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.update_calibration_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.update_calibration_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>This method updates the attributes of the <a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a> attribute.</p>
<p>See the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration.estimators</span></code></a> documentation for accepted attribute values.</p>
<p>If a supplied attribute is not found in the <a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a> attribute then this will print a
warning and ignore the attribute. Any attributes that are not supplied are left alone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>calibration_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – A dictionary of attribute-&gt;value pairs to update the
<a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a> attribute with</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.reset_static_alignment_estimator">
<span class="sig-name descname"><span class="pre">reset_static_alignment_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.reset_static_alignment_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.reset_static_alignment_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>This method replaces the existing static alignment estimator instance with a new instance
using the initial <code class="docutils literal notranslate"><span class="pre">static_alignment_estimator_kwargs</span></code> argument passed to the constructor.</p>
<p>A new instance of the object is created, therefore there is no backwards reference whatsoever to the state
before a call to this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.update_static_alignment_estimator">
<span class="sig-name descname"><span class="pre">update_static_alignment_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alignment_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.update_static_alignment_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.update_static_alignment_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>This method updates the attributes of the <a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a> attribute.</p>
<p>See the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration.estimators</span></code></a> documentation for accepted attribute values.</p>
<p>If a supplied attribute is not found in the <a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a> attribute then this will print a
warning and ignore the attribute. Any attributes that are not supplied are left alone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>alignment_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – A dictionary of attribute-&gt;value pairs to update the
<a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a> attribute with</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.reset_temperature_dependent_alignment_estimator">
<span class="sig-name descname"><span class="pre">reset_temperature_dependent_alignment_estimator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.reset_temperature_dependent_alignment_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.reset_temperature_dependent_alignment_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>This method replaces the existing temperature_dependent_alignment estimator instance with a new instance
using the initial <code class="docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator_kwargs</span></code> argument passed to the constructor.</p>
<p>A new instance of the object is created, therefore there is no backwards reference whatsoever to the state
before a call to this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.update_temperature_dependent_alignment_estimator">
<span class="sig-name descname"><span class="pre">update_temperature_dependent_alignment_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">temperature_dependent_alignment_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.update_temperature_dependent_alignment_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.update_temperature_dependent_alignment_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>This method updates the attributes of the <a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="giant.calibration.Calibration.temperature_dependent_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code></a> attribute.</p>
<p>See the <a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">calibration.estimators</span></code></a> documentation for accepted attribute values.</p>
<p>If a supplied attribute is not found in the <a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="giant.calibration.Calibration.temperature_dependent_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code></a> attribute then 
this will print a warning and ignore the attribute. Any attributes that are not supplied are left alone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>temperature_dependent_alignment_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – A dictionary of attribute-&gt;value pairs to update the
<a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="giant.calibration.Calibration.temperature_dependent_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code></a> 
attribute with</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.reset_settings">
<span class="sig-name descname"><span class="pre">reset_settings</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.reset_settings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.reset_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>This method resets all settings to their initially provided values (at class construction)</p>
<p>Specifically, the following are reset</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">star_id</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">image_processing</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">attitude_estimator</span></code></p></li>
<li><p><a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="giant.calibration.Calibration.temperature_dependent_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code></a></p></li>
</ul>
<p>In each case, a new instance of the object is created supplying the corresponding <code class="docutils literal notranslate"><span class="pre">_kwargs</span></code> argument supplied
when this class what initialized.</p>
<p>This is simply a shortcut to calling the <code class="docutils literal notranslate"><span class="pre">reset_XXX`</span></code> methods individually.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.update_settings">
<span class="sig-name descname"><span class="pre">update_settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">star_id_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_processing_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attitude_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calibration_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_alignment_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature_dependent_alignment_estimator_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.update_settings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.update_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>This method updates all settings to their provided values</p>
<p>Specifically, the following are updated depending on the input</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">star_id</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">image_processing</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">attitude_estimator</span></code></p></li>
<li><p><a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a></p></li>
</ul>
<p>In each case, the existing instance is modified in place with the attributes provided.  Any attributes that are
not specified are left as is.</p>
<p>This is simply a shortcut to calling the <code class="docutils literal notranslate"><span class="pre">update_XXX</span></code> methods individually.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>star_id_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The updates to <code class="xref py py-attr docutils literal notranslate"><span class="pre">star_id</span></code>.</p></li>
<li><p><strong>attitude_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The updates to <code class="xref py py-attr docutils literal notranslate"><span class="pre">attitude_estimator</span></code>.</p></li>
<li><p><strong>image_processing_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The updates to <code class="xref py py-attr docutils literal notranslate"><span class="pre">image_processing</span></code>.</p></li>
<li><p><strong>calibration_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The updates to <a class="reference internal" href="#giant.calibration.Calibration.calibration_estimator" title="giant.calibration.Calibration.calibration_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">calibration_estimator</span></code></a>.</p></li>
<li><p><strong>static_alignment_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The updates to <a class="reference internal" href="#giant.calibration.Calibration.static_alignment_estimator" title="giant.calibration.Calibration.static_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">static_alignment_estimator</span></code></a>.</p></li>
<li><p><strong>temperature_dependent_alignment_estimator_update</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – The updates to
<a class="reference internal" href="#giant.calibration.Calibration.temperature_dependent_alignment_estimator" title="giant.calibration.Calibration.temperature_dependent_alignment_estimator"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature_dependent_alignment_estimator</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.calib_summary">
<span class="sig-name descname"><span class="pre">calib_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.calib_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.calib_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>This prints a summary of the results of calibration to the screen</p>
<p>The resulting summary displays the labeled covariance matrix, followed by the labeled correlation coefficients,
followed by the state parameters and their formal uncertainty.</p>
<p>One optional inputs can be used to specify the uncertainty on the measurements if weighted estimation wasn’t
already used to ensure the post-fit covariance
has the proper scaling.</p>
<p>Note that if multiple misalignments were estimated in the calibration, only the first is printed in the
correlation and covariance matrices.  For all misalignments, the values are replaced with NaN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>measurement_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>, </em><em>numbers.Real</em><em>]</em><em>]</em>) – The covariance for the measurements either as a nxn matrix or as a scalar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.Calibration.limit_magnitude">
<span class="sig-name descname"><span class="pre">limit_magnitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_magnitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_magnitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_place</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/calibration_class.html#Calibration.limit_magnitude"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.Calibration.limit_magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>This method removes stars from the <code class="docutils literal notranslate"><span class="pre">matched_...</span></code> attributes that are not within the provided magnitude bounds.</p>
<p>This method should be used rarely, as you can typically achieve the same functionality by use the
<a class="reference internal" href="#giant.calibration.StarID.max_magnitude" title="giant.calibration.StarID.max_magnitude"><code class="xref py py-attr docutils literal notranslate"><span class="pre">StarID.max_magnitude</span></code></a> and <a class="reference internal" href="#giant.calibration.StarID.min_magnitude" title="giant.calibration.StarID.min_magnitude"><code class="xref py py-attr docutils literal notranslate"><span class="pre">StarID.min_magnitude</span></code></a> attributes before calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code>.  The
most typical use case for this method is when you have already completed a full calibration and you now either
want to filter out some of the stars for plotting purposes, or you want to filter out some of the stars to do an
alignment analysis, where it is generally better to use only well exposed stars since fewer are needed to
fully define the alignment.</p>
<p>When you use this method, by default it will edit and return a copy of the current instance to preserve the
current instance.  if you are using many images with many stars in them this can use a large amount of memory;
however, so you can optionally specify <code class="docutils literal notranslate"><span class="pre">in_place=True</span></code> to modify the current instance in place.  Note however
that this not a reversible operation (that is you cannot get back to the original state) so be cautious about
using this option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_magnitude</strong> (<em>float</em>) – The minimum star magnitude to accept (recall that minimum magnitude limits the brightest
stars)</p></li>
<li><p><strong>max_magnitude</strong> (<em>float</em>) – The maximum star magnitude to accept (recall that maximum magnitude limits the dimmest
stars)</p></li>
<li><p><strong>in_place</strong> – A flag specifying whether to work on a copy or the original</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The edited Calibration instance (either a copy or a reference)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="calibration/calibration_class/giant.calibration.calibration_class.Calibration.html#giant.calibration.calibration_class.Calibration" title="giant.calibration.calibration_class.Calibration">giant.calibration.calibration_class.Calibration</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">DavenportQMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_frame_directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_frame_directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/estimators.html#DavenportQMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.DavenportQMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="stellar_opnav/estimators/giant.stellar_opnav.estimators.AttitudeEstimator.html#giant.stellar_opnav.estimators.AttitudeEstimator" title="giant.stellar_opnav.estimators.AttitudeEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">giant.stellar_opnav.estimators.AttitudeEstimator</span></code></a></p>
<p>This class estimates the rotation quaternion that best aligns unit vectors from one frame with unit vectors in
another frame using Davenport’s Q-Method solution to Wahba’s problem.</p>
<p>This class is relatively easy to use.  When you initialize the class, simply specify the
<a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> unit vectors (<span class="math notranslate nohighlight">\(\textbf{a}_i\)</span> from the <a class="reference internal" href="stellar_opnav/giant.stellar_opnav.estimators.html#module-giant.stellar_opnav.estimators" title="giant.stellar_opnav.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">estimators</span></code></a>
documentation) as a 3xn array of vectors (each column is a vector) and the <a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a> unit
vectors (<span class="math notranslate nohighlight">\(\textbf{b}_i\)</span> from the <a class="reference internal" href="stellar_opnav/giant.stellar_opnav.estimators.html#module-giant.stellar_opnav.estimators" title="giant.stellar_opnav.estimators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">estimators</span></code></a> documentation) as a 3xn array of
vectors  (each column is a vector).  Here the <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> unit vectors are expressed in the
end frame (the frame you want to rotate to) and the <a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a> unit vectors are expressed in
the starting frame (the frame you want to rotate from).  You can also leave these inputs to be <code class="docutils literal notranslate"><span class="pre">None</span></code> and then
set the attributes directly. Each column of <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> and <a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a> should
correspond to each other as a pair (i.e. column 1 in <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> is paired with column ` in
<a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a>.</p>
<p>Optionally, either at initialization or by setting the attributes, you can set the <a class="reference internal" href="#giant.calibration.DavenportQMethod.weighted_estimation" title="giant.calibration.DavenportQMethod.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> and
<a class="reference internal" href="#giant.calibration.DavenportQMethod.weights" title="giant.calibration.DavenportQMethod.weights"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weights</span></code></a> values to specify whether to use weighted estimation or not, and what weights to use if you are
using weighted estimation.  When performing weighted estimation you should set <a class="reference internal" href="#giant.calibration.DavenportQMethod.weighted_estimation" title="giant.calibration.DavenportQMethod.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> to
<code class="docutils literal notranslate"><span class="pre">True</span></code> and specify <a class="reference internal" href="#giant.calibration.DavenportQMethod.weights" title="giant.calibration.DavenportQMethod.weights"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weights</span></code></a> to be a length n array of the weights to apply to each unit vector pair.</p>
<p>Once the appropriate values are set, the <a class="reference internal" href="#giant.calibration.DavenportQMethod.estimate" title="giant.calibration.DavenportQMethod.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method can be called to compute the attitude quaternion
that best aligns the two frames.  When the <a class="reference internal" href="#giant.calibration.DavenportQMethod.estimate" title="giant.calibration.DavenportQMethod.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method completes, the solved for rotation can be found
as an <a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object in the <a class="reference internal" href="#giant.calibration.DavenportQMethod.rotation" title="giant.calibration.DavenportQMethod.rotation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rotation</span></code></a> attribute of the class.  In addition, the formal post fit
covariance matrix of the estimate can be found in the <a class="reference internal" href="#giant.calibration.DavenportQMethod.post_fit_covariance" title="giant.calibration.DavenportQMethod.post_fit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">post_fit_covariance</span></code></a> attribute.  Note that as will all
attitude quaternions, the post fit covariance matrix will be rank deficient since there are only 3 true degrees of
freedom.</p>
<p>A description of the math behind the DavenportQMethod Solution can be found
<a class="reference external" href="https://math.stackexchange.com/a/2275087/202119">here</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_frame_directions</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 3xn array of unit vectors expressed in the camera frame</p></li>
<li><p><strong>base_frame_directions</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 3xn array of unit vectors expressed in the catalogue frame corresponding the the
<code class="docutils literal notranslate"><span class="pre">target_frame_directions</span></code> unit vectors</p></li>
<li><p><strong>weighted_estimation</strong> (<em>bool</em>) – A flag specifying whether to weight the estimation routine by unit vector pairs</p></li>
<li><p><strong>weights</strong> (<em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>, </em><em>numbers.Real</em><em>]</em>) – The weights to apply to the unit vectors if the <code class="docutils literal notranslate"><span class="pre">weighted_estimation</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.target_frame_directions">
<span class="sig-name descname"><span class="pre">target_frame_directions</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>The unit vectors in the target frame as a 3xn array (<span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span>).</p>
<p>Each column should represent the pair of the corresponding column in <a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.base_frame_directions">
<span class="sig-name descname"><span class="pre">base_frame_directions</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>The unit vectors in the base frame as a 3xn array (<span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span>).</p>
<p>Each column should represent the pair of the corresponding column in <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.weights">
<span class="sig-name descname"><span class="pre">weights</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.DavenportQMethod.weights" title="Permalink to this definition">¶</a></dt>
<dd><p>A length n array of the weights to apply if weighted_estimation is True. (<span class="math notranslate nohighlight">\(w_i\)</span>)</p>
<p>Each element should represent the pair of the corresponding column in <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> and
<a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.weighted_estimation">
<span class="sig-name descname"><span class="pre">weighted_estimation</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.DavenportQMethod.weighted_estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag specifying whether to use weights in the estimation of the rotation.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><span class="pre">giant.rotations.Rotation</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.DavenportQMethod.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>The solved for rotation that best aligns the <a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a> and <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> 
after calling <a class="reference internal" href="#giant.calibration.DavenportQMethod.estimate" title="giant.calibration.DavenportQMethod.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
<p>This rotation goes go from the base frame to the target frame.</p>
<p>If <a class="reference internal" href="#giant.calibration.DavenportQMethod.estimate" title="giant.calibration.DavenportQMethod.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> has not been called yet then this will be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.compute_residuals">
<span class="sig-name descname"><span class="pre">compute_residuals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/estimators.html#DavenportQMethod.compute_residuals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.DavenportQMethod.compute_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the residuals between the aligned unit vectors according to Wahba’s problem definitions.</p>
<p>If the updated attitude has been estimated (<a class="reference internal" href="#giant.calibration.DavenportQMethod.rotation" title="giant.calibration.DavenportQMethod.rotation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rotation</span></code></a> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>) then this method computes the 
post-fit residuals.  If not then this method computes the pre-fit residuals.  The residuals are computed 
according to</p>
<div class="math notranslate nohighlight">
\[r_i=\frac{1}{2}\left\|\mathbf{a}_i-\mathbf{T}\mathbf{b}_i\right\|^2\]</div>
<p>where <span class="math notranslate nohighlight">\(r_i\)</span> is the residual, <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> is the camera direction unit vector,
<span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span> is the database direction unit vector, and <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is the solved for rotation 
matrix from the catalogue frame to the camera frame, or the identity matrix if the matrix hasn’t been solved for
yet.</p>
<p>The output will be a length n array with each element representing the residual for the correspond unit vector
pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The residuals between the aligned unit vectors</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/estimators.html#DavenportQMethod.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.DavenportQMethod.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>This method solves for the rotation matrix that best aligns the unit vectors in <a class="reference internal" href="#giant.calibration.DavenportQMethod.base_frame_directions" title="giant.calibration.DavenportQMethod.base_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">base_frame_directions</span></code></a>
with the unit vectors in <a class="reference internal" href="#giant.calibration.DavenportQMethod.target_frame_directions" title="giant.calibration.DavenportQMethod.target_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target_frame_directions</span></code></a> using Davenport’s Q-Method solution to Wahba’s Problem.</p>
<p>Once the appropriate attributes have been set, simply call this method with no arguments and the solved for
rotation will be stored in the <a class="reference internal" href="#giant.calibration.DavenportQMethod.rotation" title="giant.calibration.DavenportQMethod.rotation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rotation</span></code></a> attribute as an <a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.DavenportQMethod.post_fit_covariance">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">post_fit_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.DavenportQMethod.post_fit_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns the post-fit covariance after calling the <code class="docutils literal notranslate"><span class="pre">estimate</span></code> method as a 4x4 numpy array.</p>
<p>This should be only be called after the estimate method has been called, otherwise it raises a ValueError</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.StarID">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">StarID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extracted_image_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">catalogue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_magnitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_magnitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_combos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_priori_rotation_cat2camera</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ransac_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_closest_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_velocity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_mp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lost_in_space_catalogue_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The StarID class operates on the result of image processing algorithms to attempt to match image points of interest
with catalogue star records.</p>
<p>This is a necessary step in all forms of stellar OpNav and is a critical component of
GIANT.</p>
<p>In general, the user will not directly interface with the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class and instead will use the
<a class="reference internal" href="stellar_opnav/stellar_class/giant.stellar_opnav.stellar_class.StellarOpNav.html#giant.stellar_opnav.stellar_class.StellarOpNav" title="giant.stellar_opnav.stellar_class.StellarOpNav"><code class="xref py py-class docutils literal notranslate"><span class="pre">StellarOpNav</span></code></a> class.  Below we give a brief description of how to use this class directly for users who
are just curious or need more direct control over the class.</p>
<p>There are a couple things that the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class needs to operate.  The first is a camera model, which
should be a subclass of <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a>.  The camera model is used to both project catalogue star locations
onto the image, as well as generate unit vectors through the image points of interest in the camera frame.  The
next thing the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class needs is a star catalogue to query.  This should come from the
<a class="reference internal" href="giant.catalogues.html#module-giant.catalogues" title="giant.catalogues"><code class="xref py py-mod docutils literal notranslate"><span class="pre">catalogues</span></code></a> package and provides all of the necessary information for retrieving and projecting the expected
stars in an image. Both the star catalogue and camera model are generally set at the construction of the class
and apply to every image being considered, so they are rarely updated.  The camera model is stored in the
<a class="reference internal" href="#giant.calibration.StarID.model" title="giant.calibration.StarID.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> attribute and is also specified as the first positional argument for the class constructor.  The
catalogue is stored in the <a class="reference internal" href="#giant.calibration.StarID.catalogue" title="giant.calibration.StarID.catalogue"><code class="xref py py-attr docutils literal notranslate"><span class="pre">catalogue</span></code></a> attribute and can also be specified in the class constructor as a
keyword argument of the same name.</p>
<p>The <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class also needs some information about the current image being considered.  This information
includes points of interest for the image that need to be matched to stars, the <em>a priori</em> attitude of the image,
and the position/velocity of the camera at the time the image was captured.  The points of interest are generally
returned from the <a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing" title="giant.image_processing.ImageProcessing"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageProcessing</span></code></a> routines, although they don’t need to be.  The camera attitude,
position, and velocity are generally passed from the <a class="reference internal" href="image/giant.image.OpNavImage.html#giant.image.OpNavImage" title="giant.image.OpNavImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpNavImage</span></code></a> metadata.  The image attitude is used for
querying the catalogue and rotating the catalogue stars into the image frame.  The camera positions and velocity
are used for correcting the star locations for parallax and stellar aberration. The camera position and velocity are
not required but are generally recommended as they will give a more accurate representation.  All of these
attributes need to be updated for each new image being considered (the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class does not directly
operate on the <a class="reference internal" href="image/giant.image.OpNavImage.html#giant.image.OpNavImage" title="giant.image.OpNavImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpNavImage</span></code></a> objects).  The image points of interest are stored and updated in the
<a class="reference internal" href="#giant.calibration.StarID.extracted_image_points" title="giant.calibration.StarID.extracted_image_points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">extracted_image_points</span></code></a> attribute, the camera attitude is stored in the <a class="reference internal" href="#giant.calibration.StarID.a_priori_rotation_cat2camera" title="giant.calibration.StarID.a_priori_rotation_cat2camera"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_rotation_cat2camera</span></code></a>
attribute, and the camera position and velocity are stored in the <a class="reference internal" href="#giant.calibration.StarID.camera_position" title="giant.calibration.StarID.camera_position"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_position</span></code></a> and
<a class="reference internal" href="#giant.calibration.StarID.camera_velocity" title="giant.calibration.StarID.camera_velocity"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_velocity</span></code></a> attributes respectively.  They can also be specified in the class constructor as keyword
arguments of the same name.</p>
<p>Finally, there are a number of tuning parameters that need set.  These parameters are discussed in depth in the
<a class="reference internal" href="stellar_opnav/giant.stellar_opnav.star_identification.html#tuning-parameters-table"><span class="std std-ref">Tuning Parameters Table</span></a>.</p>
<p>When everything is correctly set in an instance of <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a>, then generally all that needs to be called
is the <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> method, which accepts the observation date of the image being considered as an
optional <code class="docutils literal notranslate"><span class="pre">epoch</span></code> keyword argument.  This method will go through the whole processed detailed above, storing the
results in a number of attributes that are detailed below.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This class will load data for the lost in space catalogue.  The lost is space catalogue is a pickle file. Pickle
files can be used to execute arbitrary code, so you should never open one from an untrusted source.  While this
code should only be reading pickle files generated by GIANT itself that are safe, you should verify that the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">lost_in_space_catalogue_file</span></code> and the file it points to have not been tampered with to be absolutely
sure.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><em>giant.camera_models.camera_model.CameraModel</em></a>) – The camera model to use to relate vectors in the camera frame with points on the image</p></li>
<li><p><strong>extracted_image_points</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 2xn array of the image points of interest to be identified.  The first row
should correspond to the y locations (rows) and the second row should correspond
to the x locations (columns).</p></li>
<li><p><strong>catalogue</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><em>giant.catalogues.meta_catalogue.Catalogue</em></a><em>]</em>) – The catalogue object to use to query for potential stars in an image.</p></li>
<li><p><strong>max_magnitude</strong> (<em>numbers.Real</em>) – the maximum magnitude to return when querying the star catalogue</p></li>
<li><p><strong>min_magnitude</strong> (<em>numbers.Real</em>) – the minimum magnitude to return when querying the star catalogue</p></li>
<li><p><strong>max_combos</strong> (<em>int</em>) – The maximum number of random samples to try in the RANSAC routine</p></li>
<li><p><strong>tolerance</strong> (<em>numbers.Real</em>) – The maximum distance between a catalogue star and a image point of interest for a potential
pair to be formed before the RANSAC algorithm</p></li>
<li><p><strong>a_priori_rotation_cat2camera</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><em>giant.rotations.Rotation</em></a><em>]</em>) – The rotation matrix to go from the inertial frame to the camera frame</p></li>
<li><p><strong>ransac_tolerance</strong> (<em>numbers.Real</em>) – The maximum distance between a catalogue star and an image point of interest after
correcting the attitude for a pair to be considered an inlier in the RANSAC algorithm.</p></li>
<li><p><strong>second_closest_check</strong> (<em>bool</em>) – A flag specifying whether to reject pairs where 2 catalogue stars are close to an
image point of interest</p></li>
<li><p><strong>camera_velocity</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – The velocity of the camera in km/s with respect to the solar system barycenter in the
inertial frame at the time the image was taken</p></li>
<li><p><strong>camera_position</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – The position of the camera in km with respect to the solar system barycenter in the
inertial frame at the time the image was taken</p></li>
<li><p><strong>unique_check</strong> (<em>bool</em>) – A flag specifying whether to allow a single catalogue star to be potentially paired with
multiple image points of interest</p></li>
<li><p><strong>use_mp</strong> (<em>bool</em>) – A flag specifying whether to use the multi-processing library to accelerate the RANSAC algorithm</p></li>
<li><p><strong>lost_in_space_catalogue_file</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>pathlib.Path</em><em>, </em><em>str</em><em>]</em><em>]</em>) – The file containing the lost in space catalogue</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.model">
<span class="sig-name descname"><span class="pre">model</span></span><em class="property"><span class="pre">:</span> <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><span class="pre">giant.camera_models.camera_model.CameraModel</span></a></em><a class="headerlink" href="#giant.calibration.StarID.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The camera model which relates points in the camera frame to points in the image and vice-versa.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.camera_position">
<span class="sig-name descname"><span class="pre">camera_position</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.StarID.camera_position" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of the camera with respect to the solar system barycenter in the inertial frame at the time the 
image was captured as a length 3 numpy array of floats.</p>
<p>Typically this is stored in the <a class="reference internal" href="image/giant.image.OpNavImage.html#giant.image.OpNavImage.position" title="giant.image.OpNavImage.position"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OpNavImage.position</span></code></a> attribute</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.camera_velocity">
<span class="sig-name descname"><span class="pre">camera_velocity</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.StarID.camera_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>The velocity of the camera with respect to the solar system barycenter in the inertial frame at the time the 
image was captured as a length 3 numpy array of floats.</p>
<p>Typically this is stored in the <a class="reference internal" href="image/giant.image.OpNavImage.html#giant.image.OpNavImage.velocity" title="giant.image.OpNavImage.velocity"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OpNavImage.velocity</span></code></a> attribute</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.extracted_image_points">
<span class="sig-name descname"><span class="pre">extracted_image_points</span></span><em class="property"><span class="pre">:</span> <span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#giant.calibration.StarID.extracted_image_points" title="Permalink to this definition">¶</a></dt>
<dd><p>a 2xn array of the image points of interest to be paired with catalogue stars.</p>
<p>the first row should correspond to the x locations (columns) and the second row should correspond
to the y locations (rows).</p>
<p>typically this is retrieved from a call to <a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.locate_subpixel_poi_in_roi.html#giant.image_processing.ImageProcessing.locate_subpixel_poi_in_roi" title="giant.image_processing.ImageProcessing.locate_subpixel_poi_in_roi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageProcessing.locate_subpixel_poi_in_roi()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.catalogue">
<span class="sig-name descname"><span class="pre">catalogue</span></span><em class="property"><span class="pre">:</span> <a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><span class="pre">giant.catalogues.meta_catalogue.Catalogue</span></a></em><a class="headerlink" href="#giant.calibration.StarID.catalogue" title="Permalink to this definition">¶</a></dt>
<dd><p>The star catalogue to use when pairing image points with star locations.</p>
<p>This typically should be a subclass of the <a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Catalogue</span></code></a> class.  It defaults to the 
<a class="reference internal" href="catalogues/giant_catalogue/giant.catalogues.giant_catalogue.GIANTCatalogue.html#giant.catalogues.giant_catalogue.GIANTCatalogue" title="giant.catalogues.giant_catalogue.GIANTCatalogue"><code class="xref py py-class docutils literal notranslate"><span class="pre">GIANTCatalogue</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.a_priori_rotation_cat2camera">
<span class="sig-name descname"><span class="pre">a_priori_rotation_cat2camera</span></span><em class="property"><span class="pre">:</span> <a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><span class="pre">giant.rotations.Rotation</span></a></em><a class="headerlink" href="#giant.calibration.StarID.a_priori_rotation_cat2camera" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the a priori rotation knowledge from the catalogue frame (typically the inertial frame) to the
camera frame at the time of the image.</p>
<p>This typically is stored as the <a class="reference internal" href="image/giant.image.OpNavImage.html#giant.image.OpNavImage.rotation_inertial_to_camera" title="giant.image.OpNavImage.rotation_inertial_to_camera"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OpNavImage.rotation_inertial_to_camera</span></code></a> attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.max_magnitude">
<span class="sig-name descname"><span class="pre">max_magnitude</span></span><em class="property"><span class="pre">:</span> <span class="pre">numbers.Real</span></em><a class="headerlink" href="#giant.calibration.StarID.max_magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum star magnitude to query from the star catalogue.</p>
<p>This specifies how dim stars are expected to be in the <a class="reference internal" href="#giant.calibration.StarID.extracted_image_points" title="giant.calibration.StarID.extracted_image_points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">extracted_image_points</span></code></a> data set.  This is 
typically dependent on both the detector and the exposure length of the image under consideration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.min_magnitude">
<span class="sig-name descname"><span class="pre">min_magnitude</span></span><em class="property"><span class="pre">:</span> <span class="pre">numbers.Real</span></em><a class="headerlink" href="#giant.calibration.StarID.min_magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum star magnitude to query from the star catalogue.</p>
<p>This specifies how dim stars are expected to be in the <a class="reference internal" href="#giant.calibration.StarID.extracted_image_points" title="giant.calibration.StarID.extracted_image_points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">extracted_image_points</span></code></a> data set.  This is 
typically dependent on both the detector and the exposure length of the image under consideration.</p>
<p>Generally this should be left alone unless you are worried about over exposed stars (in which case 
<a class="reference internal" href="image_processing/giant.image_processing.ImageProcessing.html#giant.image_processing.ImageProcessing.reject_saturation" title="giant.image_processing.ImageProcessing.reject_saturation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ImageProcessing.reject_saturation</span></code></a> may be more useful) or you are doing some special analysis.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.tolerance">
<span class="sig-name descname"><span class="pre">tolerance</span></span><em class="property"><span class="pre">:</span> <span class="pre">numbers.Real</span></em><a class="headerlink" href="#giant.calibration.StarID.tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum distance in units of pixels between a projected catalogue location and an extracted image point
for a possible pairing to be made for consideration in the RANSAC algorithm.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.max_combos">
<span class="sig-name descname"><span class="pre">max_combos</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#giant.calibration.StarID.max_combos" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of random combinations to try in the RANSAC algorithm.</p>
<p>If the total possible number of combinations is less than this attribute then an exhaustive search will be 
performed instead</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.ransac_tolerance">
<span class="sig-name descname"><span class="pre">ransac_tolerance</span></span><em class="property"><span class="pre">:</span> <span class="pre">numbers.Real</span></em><a class="headerlink" href="#giant.calibration.StarID.ransac_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>The tolerance that is required after correcting for attitude errors for a pair to be considered an inlier
in the RANSAC algorithm in units of pixels.</p>
<p>This should always be less than the <a class="reference internal" href="#giant.calibration.StarID.tolerance" title="giant.calibration.StarID.tolerance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tolerance</span></code></a> attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.second_closest_check">
<span class="sig-name descname"><span class="pre">second_closest_check</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.StarID.second_closest_check" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean specifying whether to ignore extracted image points where multiple catalogue points are within the
specified tolerance.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unique_check">
<span class="sig-name descname"><span class="pre">unique_check</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.StarID.unique_check" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean specifying whether to ignore possible catalogue to image point pairs where multiple image points are 
within the specified tolerance of a single catalogue point.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.use_mp">
<span class="sig-name descname"><span class="pre">use_mp</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.StarID.use_mp" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag specifying whether to use multi-processing to speed up the RANSAC process.</p>
<p>If this is set to True then all available CPU cores will be utilized to parallelize the RANSAC algorithm 
computations.  For small combinations, the overhead associated with this can swamp any benefit that may be 
realized.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.queried_catalogue_image_points">
<span class="sig-name descname"><span class="pre">queried_catalogue_image_points</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.queried_catalogue_image_points" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2xn numpy array of points containing the projected image points for all catalogue stars that were queried from 
the star catalogue  with x (columns) in the first row and y (rows) in the second row.</p>
<p>Each column corresponds to the same row in <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_star_records" title="giant.calibration.StarID.queried_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.project_stars" title="giant.calibration.StarID.project_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.queried_catalogue_star_records">
<span class="sig-name descname"><span class="pre">queried_catalogue_star_records</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">pandas.core.frame.DataFrame</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.queried_catalogue_star_records" title="Permalink to this definition">¶</a></dt>
<dd><p>A pandas DataFrame of all the catalogue star records that were queried.</p>
<p>See the <a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Catalogue</span></code></a> class for a description of the columns of the dataframe.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.project_stars" title="giant.calibration.StarID.project_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.queried_catalogue_unit_vectors">
<span class="sig-name descname"><span class="pre">queried_catalogue_unit_vectors</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.queried_catalogue_unit_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>A 3xn numpy array of unit vectors in the inertial frame for all catalogue stars that were queried from 
the star catalogue.</p>
<p>Each column corresponds to the same row in <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_star_records" title="giant.calibration.StarID.queried_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.project_stars" title="giant.calibration.StarID.project_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.queried_weights_inertial">
<span class="sig-name descname"><span class="pre">queried_weights_inertial</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.queried_weights_inertial" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the formal total uncertainty for each unit vector from the queried catalogue stars.</p>
<p>Each element in this array corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_star_records" title="giant.calibration.StarID.queried_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.queried_weights_picture">
<span class="sig-name descname"><span class="pre">queried_weights_picture</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.queried_weights_picture" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the formal total uncertainty for each projected pixel location from the queried catalogue stars in
units of pixels..</p>
<p>Each element in this array corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_star_records" title="giant.calibration.StarID.queried_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unmatched_catalogue_image_points">
<span class="sig-name descname"><span class="pre">unmatched_catalogue_image_points</span></span><a class="headerlink" href="#giant.calibration.StarID.unmatched_catalogue_image_points" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2xn numpy array of points containing the projected image points for all catalogue stars that not matched
with an extracted image point, with x (columns) in the first row and y (rows) in the second row.</p>
<p>Each column corresponds to the same row in <a class="reference internal" href="#giant.calibration.StarID.unmatched_catalogue_star_records" title="giant.calibration.StarID.unmatched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unmatched_catalogue_star_records">
<span class="sig-name descname"><span class="pre">unmatched_catalogue_star_records</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.unmatched_catalogue_star_records" title="Permalink to this definition">¶</a></dt>
<dd><p>A pandas DataFrame of all the catalogue star records that were not matched to an extracted image point in the 
star identification routine.</p>
<p>See the <a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Catalogue</span></code></a> class for a description of the columns of the dataframe.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unmatched_catalogue_unit_vectors">
<span class="sig-name descname"><span class="pre">unmatched_catalogue_unit_vectors</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.unmatched_catalogue_unit_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>A 3xn numpy array of unit vectors in the inertial frame for all catalogue stars that were not matched to an
extracted image point in the star identification routine.</p>
<p>Each column corresponds to the same row in <a class="reference internal" href="#giant.calibration.StarID.matched_catalogue_star_records" title="giant.calibration.StarID.matched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unmatched_extracted_image_points">
<span class="sig-name descname"><span class="pre">unmatched_extracted_image_points</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.unmatched_extracted_image_points" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2xn array of the image points of interest that were not paired with a catalogue star in the star 
identification routine.</p>
<p>The first row corresponds to the x locations (columns) and the second row corresponds to the y locations (rows).</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unmatched_weights_inertial">
<span class="sig-name descname"><span class="pre">unmatched_weights_inertial</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.unmatched_weights_inertial" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the formal total uncertainty for each unit vector from the queried catalogue stars
that were not matched with an extracted image point.</p>
<p>Each element in this array corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.unmatched_catalogue_star_records" title="giant.calibration.StarID.unmatched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_star_records</span></code></a>.</p>
<p>Until method <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.unmatched_weights_picture">
<span class="sig-name descname"><span class="pre">unmatched_weights_picture</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.unmatched_weights_picture" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the formal total uncertainty for each projected pixel location from the queried catalogue stars 
that were not matched with an extracted image point in units of pixels.</p>
<p>Each element in this array corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.unmatched_catalogue_star_records" title="giant.calibration.StarID.unmatched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unmatched_catalogue_star_records</span></code></a>.</p>
<p>Until method <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.matched_catalogue_image_points">
<span class="sig-name descname"><span class="pre">matched_catalogue_image_points</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.matched_catalogue_image_points" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2xn numpy array of points containing the projected image points for all catalogue stars that were matched
with an extracted image point, with x (columns) in the first row and y (rows) in the second row.</p>
<p>Each column corresponds to the same row in <a class="reference internal" href="#giant.calibration.StarID.matched_catalogue_star_records" title="giant.calibration.StarID.matched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.matched_catalogue_star_records">
<span class="sig-name descname"><span class="pre">matched_catalogue_star_records</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.matched_catalogue_star_records" title="Permalink to this definition">¶</a></dt>
<dd><p>A pandas DataFrame of all the catalogue star records that were matched to an extracted image point in the 
star identification routine.</p>
<p>See the <a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Catalogue</span></code></a> class for a description of the columns of the dataframe.</p>
<p>Each row of the dataframe corresponds to the same column index in the <a class="reference internal" href="#giant.calibration.StarID.matched_extracted_image_points" title="giant.calibration.StarID.matched_extracted_image_points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_extracted_image_points</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.matched_catalogue_unit_vectors">
<span class="sig-name descname"><span class="pre">matched_catalogue_unit_vectors</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.matched_catalogue_unit_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>A 3xn numpy array of unit vectors in the inertial frame for all catalogue stars that were matched to an
extracted image point in the star identification routine.</p>
<p>Each column corresponds to the same row in <a class="reference internal" href="#giant.calibration.StarID.matched_catalogue_star_records" title="giant.calibration.StarID.matched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code></a>.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.matched_extracted_image_points">
<span class="sig-name descname"><span class="pre">matched_extracted_image_points</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.matched_extracted_image_points" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2xn array of the image points of interest that were not paired with a catalogue star in the star 
identification routine.</p>
<p>The first row contains to the x locations (columns) and the second row contains to the y locations (rows).</p>
<p>Each column corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.matched_catalogue_star_records" title="giant.calibration.StarID.matched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code></a> for its pairing.</p>
<p>Until <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.matched_weights_inertial">
<span class="sig-name descname"><span class="pre">matched_weights_inertial</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.matched_weights_inertial" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the formal total uncertainty for each unit vector from the queried catalogue stars
that were matched with an extracted image point.</p>
<p>Each element in this array corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.matched_catalogue_star_records" title="giant.calibration.StarID.matched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code></a>.</p>
<p>Until methods <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.matched_weights_picture">
<span class="sig-name descname"><span class="pre">matched_weights_picture</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.matched_weights_picture" title="Permalink to this definition">¶</a></dt>
<dd><p>This contains the formal total uncertainty for each projected pixel location from the queried catalogue stars 
that were matched with an extracted image point in units of pixels.</p>
<p>Each element in this array corresponds to the same row in the <a class="reference internal" href="#giant.calibration.StarID.matched_catalogue_star_records" title="giant.calibration.StarID.matched_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">matched_catalogue_star_records</span></code></a>.</p>
<p>Until method <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> is called this will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StarID.lis_catalogue">
<span class="sig-name descname"><span class="pre">lis_catalogue</span></span><em class="property"><span class="pre">:</span> <span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">scipy.spatial.ckdtree.cKDTree</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StarID.lis_catalogue" title="Permalink to this definition">¶</a></dt>
<dd><p>The lost in space catalogue.</p>
<p>Contains a scipy cKDTree containing hash codes as the first element and a numpy array containing star ids
for each hash element for the second element.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The lost is space catalogue is a pickle file. Pickle files can be used to execute
arbitrary code, so you should never open one from an untrusted source.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.query_catalogue">
<span class="sig-name descname"><span class="pre">query_catalogue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">datetime.datetime(2000,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.query_catalogue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.query_catalogue" title="Permalink to this definition">¶</a></dt>
<dd><p>This method queries stars from the catalogue within the field of view.</p>
<p>The stars are queried such that any stars within 1.3*the <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.field_of_view" title="giant.camera_models.camera_model.CameraModel.field_of_view"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.field_of_view</span></code></a> value radial
distance of the camera frame z axis converted to right ascension and declination are returned between
<a class="reference internal" href="#giant.calibration.StarID.min_magnitude" title="giant.calibration.StarID.min_magnitude"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min_magnitude</span></code></a> and <a class="reference internal" href="#giant.calibration.StarID.max_magnitude" title="giant.calibration.StarID.max_magnitude"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_magnitude</span></code></a>.  The queried stars are updated to the <code class="docutils literal notranslate"><span class="pre">epoch</span></code> value
using proper motion.  They are stored in the <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_star_records" title="giant.calibration.StarID.queried_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code></a> attribute. The stars are
stored as a pandas DataFrame.  For more information about this format see the <a class="reference internal" href="catalogues/meta_catalogue/giant.catalogues.meta_catalogue.Catalogue.html#giant.catalogues.meta_catalogue.Catalogue" title="giant.catalogues.meta_catalogue.Catalogue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Catalogue</span></code></a> class
documentation.</p>
<p>The epoch input should either be a python datetime object representation of the UTC time or a float value of the
MJD years.</p>
<p>In general, this method does not need to be directly called by the user as it is automatically called in the
<a class="reference internal" href="#giant.calibration.StarID.project_stars" title="giant.calibration.StarID.project_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project_stars()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epoch</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>numbers.Real</em><em>]</em>) – The new epoch to move the stars to using proper motion</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.compute_pointing">
<span class="sig-name descname"><span class="pre">compute_pointing</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.compute_pointing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.compute_pointing" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the right ascension and declination of an axis of the camera frame in units of degrees.</p>
<p>The pointing is computed by extracting the camera frame z axis expressed in the inertial frame from the
<a class="reference internal" href="#giant.calibration.StarID.a_priori_rotation_cat2camera" title="giant.calibration.StarID.a_priori_rotation_cat2camera"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_rotation_cat2camera</span></code></a> and then converting that axis to a right ascension and declination.
The conversion to right ascension and declination is given as</p>
<div class="math notranslate nohighlight">
\[\begin{split}ra=\text{atan2}(\mathbf{c}_{yI}, \mathbf{c}_{xI})\\
dec=\text{asin}(\mathbf{c}_{zI})\end{split}\]</div>
<p>where atan2 is the quadrant aware arc tangent function, asin is the arc sin and <span class="math notranslate nohighlight">\(\mathbf{c}_{jI}\)</span> is the
<span class="math notranslate nohighlight">\(j^{th}\)</span> component of the camera frame axis expressed in the Inertial frame.</p>
<p>In general this method is not used by the user as it is automatically called in the <a class="reference internal" href="#giant.calibration.StarID.query_catalogue" title="giant.calibration.StarID.query_catalogue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query_catalogue()</span></code></a>
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The right ascension and declination of the specified axis in the inertial frame as a tuple (ra, dec)
in units of degrees.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.project_stars">
<span class="sig-name descname"><span class="pre">project_stars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">datetime.datetime(2000,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.project_stars"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.project_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>This method queries the star catalogue for predicted stars within the field of view and projects those stars
onto the image using the camera model.</p>
<p>The star catalogue is queried using the <a class="reference internal" href="#giant.calibration.StarID.query_catalogue" title="giant.calibration.StarID.query_catalogue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query_catalogue()</span></code></a> method and the stars are updated to the epoch
specified by <code class="docutils literal notranslate"><span class="pre">epoch</span></code> using the proper motion from the catalogue.  The <code class="docutils literal notranslate"><span class="pre">epoch</span></code> should be specified as either
a datetime object representing the UTC time the stars should be transformed to, or a float value representing
the MJD year.  The queried Pandas Dataframe containing the star catalogue records is stored in the
<a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_star_records" title="giant.calibration.StarID.queried_catalogue_star_records"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_star_records</span></code></a> attribute.</p>
<p>After the stars are queried from the catalogue, they are converted to inertial unit vectors and corrected for
stellar aberration and parallax using the <a class="reference internal" href="#giant.calibration.StarID.camera_position" title="giant.calibration.StarID.camera_position"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_position</span></code></a> and <a class="reference internal" href="#giant.calibration.StarID.camera_velocity" title="giant.calibration.StarID.camera_velocity"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_velocity</span></code></a> values.  The
corrected inertial vectors are stored in the <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_unit_vectors" title="giant.calibration.StarID.queried_catalogue_unit_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_unit_vectors</span></code></a>.</p>
<p>Finally, the unit vectors are rotated into the camera frame using the <a class="reference internal" href="#giant.calibration.StarID.a_priori_rotation_cat2camera" title="giant.calibration.StarID.a_priori_rotation_cat2camera"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_rotation_cat2camera</span></code></a>
attribute, and then projected onto the image using the <a class="reference internal" href="#giant.calibration.StarID.model" title="giant.calibration.StarID.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> attribute.  The projected points are stored
in the <a class="reference internal" href="#giant.calibration.StarID.queried_catalogue_image_points" title="giant.calibration.StarID.queried_catalogue_image_points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_catalogue_image_points</span></code></a> attribute.</p>
<p>If requested, the formal uncertainties for the catalogue unit vectors and pixel locations are computed and
stored in the <a class="reference internal" href="#giant.calibration.StarID.queried_weights_inertial" title="giant.calibration.StarID.queried_weights_inertial"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_weights_inertial</span></code></a> and <a class="reference internal" href="#giant.calibration.StarID.queried_weights_picture" title="giant.calibration.StarID.queried_weights_picture"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_weights_picture</span></code></a>.  These are computed by
transforming the formal uncertainty on the right ascension, declination, and proper motion specified in the
star catalogue into the proper frame.</p>
<p>In general this method is not called directly by the user and instead is called in the <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epoch</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>numbers.Real</em><em>]</em>) – The epoch to get the star locations for</p></li>
<li><p><strong>compute_weights</strong> (<em>bool</em>) – A boolean specifying whether to compute the formal uncertainties for the unit vectors
and the pixel locations of the catalogue stars.</p></li>
<li><p><strong>temperature</strong> (<em>numbers.Real</em>) – The temperature of the camera at the time of the image being processed</p></li>
<li><p><strong>image_number</strong> (<em>int</em>) – The number of the image being processed</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.solve_lis">
<span class="sig-name descname"><span class="pre">solve_lis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">datetime.datetime(2000,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.solve_lis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.solve_lis" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the lost in space problem (no a priori knowledge) for the orientation between the catalogue and camera
frames.</p>
<p>The lost in space problem is solved by first generating hash codes of observed possible star quads in an image
using  <code class="xref py py-meth docutils literal notranslate"><span class="pre">_generate_hash()</span></code>.  Given the hash codes, they are compared with a precomputed database of hash
codes (see <code class="xref py py-mod docutils literal notranslate"><span class="pre">build_lost_in_space_catalogue</span></code>) to identify the closest matches.  The closest matches are then
used to make a guess at the rotation from the catalogue frame to the camera frame, and the usual star ID
routines (<a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a>) are called using the guess as the a priori attitude knowledge.  The number of
identified stars found using the usual methods is then compared with the best number of stars found so far,
and if more stars are found the rotation is kept as the best available.  This is done using the settings already
provided to the class, so you need to ensure that you have a good setup even when solving the lost in space
problem.  This continues until all possible hash code pairs have been considered, or until a pair produces an
a priori attitude that successfully identifies half of the queried stars from the catalogue in the FOV of the
camera and one quarter of the possible stars.</p>
<p>The result is saved to the <a class="reference internal" href="#giant.calibration.StarID.a_priori_rotation_cat2camera" title="giant.calibration.StarID.a_priori_rotation_cat2camera"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_rotation_cat2camera</span></code></a> attribute and then the usual star ID routines
are run again to finish off the identification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epoch</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>numbers.Real</em><em>]</em>) – the epoch of the image</p></li>
<li><p><strong>temperature</strong> (<em>numbers.Real</em>) – the temperature of the camera at the time the image was captured</p></li>
<li><p><strong>image_number</strong> (<em>int</em>) – The number of the image being processed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean index into the image points that met the original pairing criterion, and a second boolean
index into the the result from the previous boolean index that extracts the image points that were
successfully matched in the RANSAC algorithms</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.id_stars">
<span class="sig-name descname"><span class="pre">id_stars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epoch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">datetime.datetime(2000,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lost_in_space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.id_stars"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.id_stars" title="Permalink to this definition">¶</a></dt>
<dd><p>This method attempts to match the image points of interest with catalogue stars.</p>
<p>The <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a> method is the primary interface of the <a class="reference internal" href="#giant.calibration.StarID" title="giant.calibration.StarID"><code class="xref py py-class docutils literal notranslate"><span class="pre">StarID</span></code></a> class.  It performs all the tasks of
querying the star catalogue, performing the initial pairing using a nearest neighbor search, refining the
initial pairings with the <a class="reference internal" href="#giant.calibration.StarID.second_closest_check" title="giant.calibration.StarID.second_closest_check"><code class="xref py py-attr docutils literal notranslate"><span class="pre">second_closest_check</span></code></a> and <a class="reference internal" href="#giant.calibration.StarID.unique_check" title="giant.calibration.StarID.unique_check"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_check</span></code></a>, and passing the refined
pairings to the RANSAC routines.  The matched and unmatched catalogue stars and image points of interest are
stored in the appropriate attributes.</p>
<p>This method also returns a boolean index in the image points of interest vector, which extracts the image points
that met the initial match criterion, and another boolean index into the image points of interest which
extracts the image points of interest that were matched by the RANSAC algorithms.  This can be used to select
the appropriate meta data about catalogue stars or stars found in an image that isn’t explicitly considered by
this class (as is done in the <a class="reference internal" href="stellar_opnav/stellar_class/giant.stellar_opnav.stellar_class.StellarOpNav.html#giant.stellar_opnav.stellar_class.StellarOpNav" title="giant.stellar_opnav.stellar_class.StellarOpNav"><code class="xref py py-class docutils literal notranslate"><span class="pre">StellarOpNav</span></code></a> class), but if you do not have extra information you need
to keep in sync, then you can ignore the output.</p>
<p>If requested, the formal uncertainties for the catalogue unit vectors and pixel locations are computed and
stored in the <a class="reference internal" href="#giant.calibration.StarID.queried_weights_inertial" title="giant.calibration.StarID.queried_weights_inertial"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_weights_inertial</span></code></a> and <a class="reference internal" href="#giant.calibration.StarID.queried_weights_picture" title="giant.calibration.StarID.queried_weights_picture"><code class="xref py py-attr docutils literal notranslate"><span class="pre">queried_weights_picture</span></code></a>.  These are computed by
transforming the formal uncertainty on the right ascension, declination, and proper motion specified in the
star catalogue into the proper frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epoch</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>numbers.Real</em><em>]</em>) – The new epoch to move the stars to using proper motion</p></li>
<li><p><strong>compute_weights</strong> (<em>bool</em>) – a flag specifying whether to compute weights for the attitude estimation and
calibration estimation.</p></li>
<li><p><strong>temperature</strong> (<em>numbers.Real</em>) – The temperature of the camera at the time of the image being processed</p></li>
<li><p><strong>image_number</strong> (<em>int</em>) – The number of the image being processed</p></li>
<li><p><strong>lost_in_space</strong> (<em>bool</em>) – A flag specifying whether the lost in space algorithm needs to be used</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The boolean index into the image points that met the original pairing criterion, and a second boolean
index into the the result from the previous boolean index that extracts the image points that were
successfully matched in the RANSAC algorithms</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.ransac">
<span class="sig-name descname"><span class="pre">ransac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_locs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">catalogue_dirs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_number</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.ransac"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.ransac" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs RANSAC on the image poi-catalogue location pairs.</p>
<p>The RANSAC algorithm is described below</p>
<ol class="arabic simple">
<li><p>The pairs are randomly sampled for 4 star pairs</p></li>
<li><p>The sample is used to estimate a new attitude for the image using the <a class="reference internal" href="#giant.calibration.DavenportQMethod" title="giant.calibration.DavenportQMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">DavenportQMethod</span></code></a> routines.</p></li>
<li><p>The new solved for attitude is used to re-rotate and project the catalogue stars onto the image.</p></li>
<li><p>The new projections are compared with their matched image points and the number of inlier pairs (pairs whose
distance is less than some ransac threshold) are counted.</p></li>
<li><p>The number of inliers is compared to the maximum number of inliers found by any sample to this point (set to
0 if this is the first sample) and:</p>
<ul class="simple">
<li><p>if there are more inliers</p>
<ul>
<li><p>the maximum number of inliers is set to the number of inliers generated for this sample</p></li>
<li><p>the inliers for this sample are stored as correctly identified stars</p></li>
<li><p>the sum of the squares of the distances between the inlier pairs for this sample is stored</p></li>
</ul>
</li>
<li><p>if there are an equivalent number of inliers to the previous maximum number of inliers then the sum of the
squares of the distance between the pairs of inliers is compared to the sum of the squares of the previous
inliers and if the new sum of squares is less than the old sum of squares</p>
<ul>
<li><p>the maximum number of inliers is set to the number of inliers generated for this sample</p></li>
<li><p>the inliers are stored as correctly identified stars</p></li>
<li><p>the sum of the squares of the distances between the inlier pairs is stored</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Steps 1-5 are repeated for a number of iterations, and the final set of stars stored as correctly identified
stars become the identified stars for the image.</p></li>
</ol>
<p>In order to use this method, the <code class="docutils literal notranslate"><span class="pre">image_locs</span></code> input and the <code class="docutils literal notranslate"><span class="pre">catalogue_dirs</span></code> input should represent the
initial pairings between the image points found using image processing and the predicted catalogue star unit
vectors in the inertial frame. The columns in these 2 arrays should represent the matched pairs (that is column
10 of <code class="docutils literal notranslate"><span class="pre">image_locs</span></code> should correspond to column 10 in <code class="docutils literal notranslate"><span class="pre">catalogue_dirs</span></code>).</p>
<p>This method returns the paired image locations and catalogue directions from the best RANSAC iteration
and the boolean index into the input arrays that extract these values.</p>
<p>In general this method is not used directly by the user and instead is called as part of the <a class="reference internal" href="#giant.calibration.StarID.id_stars" title="giant.calibration.StarID.id_stars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id_stars()</span></code></a>
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_locs</strong> (<em>numpy.ndarray</em>) – The image points of interest that met the initial matching criteria as a 2xn array</p></li>
<li><p><strong>catalogue_dirs</strong> (<em>numpy.ndarray</em>) – The catalogue inertial unit vectors that met the initial matching criteria in the same
order as the <code class="docutils literal notranslate"><span class="pre">image_locs</span></code> input as a 3xn array.</p></li>
<li><p><strong>temperature</strong> (<em>numbers.Real</em>) – The temperature of the camera at the time of the image being processed</p></li>
<li><p><strong>image_number</strong> (<em>int</em>) – The number of the image being processed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The matched image points of interest, the matched catalogue unit vectors, and the boolean index that
represents these arrays</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StarID.ransac_iter_test">
<span class="sig-name descname"><span class="pre">ransac_iter_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_num</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/stellar_opnav/star_identification.html#StarID.ransac_iter_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StarID.ransac_iter_test" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs a single ransac iteration.</p>
<p>See the <a class="reference internal" href="#giant.calibration.StarID.ransac" title="giant.calibration.StarID.ransac"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ransac()</span></code></a> method for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iter_num</strong> (<em>int</em>) – the iteration number for retrieving the combination to try</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the number of inliers for this iteration, the image location inliers for this iteration, the
catalogue direction inliers for this iteration, the boolean index for the inliers for this iteration,
and the sum of the squares of the residuals for this iteration</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[int, Optional[Union[Sequence, numpy.ndarray]], Optional[Union[Sequence, numpy.ndarray]], Optional[Union[Sequence, numpy.ndarray]], Optional[Union[Sequence, numpy.ndarray]]]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">CalibrationEstimator</span></span><a class="reference internal" href="_modules/giant/calibration/estimators.html#CalibrationEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.CalibrationEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This abstract base class serves as the template for implementing a class for doing camera model estimation in
GIANT.</p>
<p>Camera model estimation in GIANT is primarily handled by the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class, which does the steps of
extracting observed stars in an image, pairing the observed stars with a star catalogue, and then passing the
observed star-catalogue star pairs to a subclass of this meta-class, which estimates an update to the camera model
in place (the input camera model is modified, not a copy).  In order for this to work, this ABC defines the minimum
required interfaces that the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class expects for an estimator.</p>
<p>The required interface that the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class expects consists of a few readable/writeable properties,
and a couple of standard methods, as defined below.  Beyond that the implementation is left to the user.</p>
<p>If you are just doing a typical calibration, then you probably need not worry about this ABC and instead can use one
of the 2 concrete classes defined in this module, which work well in nearly all cases.  If you do have a need to
implement your own estimator, then you should subclass this ABC, and study the concrete classes from this module for
an example of what needs to be done.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because this is an ABC, you cannot create an instance of this class (it will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>)</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.model">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">model</span></span><em class="property"><span class="pre">:</span> <span class="pre">giant.camera_models.camera_model.CameraModel</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The camera model that is being estimated.</p>
<p>Typically this should be a subclass of <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a>.</p>
<p>This should be a read/write property</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.successful">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">successful</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.successful" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag indicating whether the fit was successful or not.</p>
<p>If the fit was successful this should return <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> if otherwise.</p>
<p>This should be a read-only property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.weighted_estimation">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">weighted_estimation</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.weighted_estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag specifying whether to do weighted estimation.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the estimator should use the provided measurement weights in <a class="reference internal" href="#giant.calibration.CalibrationEstimator.measurement_covariance" title="giant.calibration.CalibrationEstimator.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a>
during the estimation process.  If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, then no measurement weights should be considered.</p>
<p>This should be a read/write property</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.measurement_covariance">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">measurement_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray,</span> <span class="pre">numbers.Real]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.measurement_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the measurements.</p>
<p>If <a class="reference internal" href="#giant.calibration.CalibrationEstimator.weighted_estimation" title="giant.calibration.CalibrationEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then this property will contain the measurement covariance
matrix as a square, full rank, numpy array.  If <a class="reference internal" href="#giant.calibration.CalibrationEstimator.weighted_estimation" title="giant.calibration.CalibrationEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> then this
property may be <code class="docutils literal notranslate"><span class="pre">None</span></code> and should be ignored.</p>
<p>This should be a read/write property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.a_priori_state_covariance">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">a_priori_state_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.a_priori_state_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the a priori estimate of the state vector.</p>
<p>This is only considered if <a class="reference internal" href="#giant.calibration.CalibrationEstimator.weighted_estimation" title="giant.calibration.CalibrationEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and if
<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise it is ignored.  If both are set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then
this should be set to a square, full rank, lxl numpy array where <code class="docutils literal notranslate"><span class="pre">l=len(model.state_vector)</span></code> containing the
covariance matrix for the a priori state vector.  The order of the parameters in the state vector can be
determined from <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.get_state_labels.html#giant.camera_models.camera_model.CameraModel.get_state_labels" title="giant.camera_models.camera_model.CameraModel.get_state_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.get_state_labels()</span></code></a>.</p>
<p>This should be a read/write property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.measurements">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">measurements</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>A nx2 numpy array of the observed pixel locations for stars across all images</p>
<p>Each column of this array will correspond to the same column of the <a class="reference internal" href="#giant.calibration.CalibrationEstimator.camera_frame_directions" title="giant.calibration.CalibrationEstimator.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> concatenated
down the last axis. (That is <code class="docutils literal notranslate"><span class="pre">measurements[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span></code>)</p>
<p>This will always be set before a call to <a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
<p>This should be a read/write property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.camera_frame_directions">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">camera_frame_directions</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[List[Union[numpy.ndarray,</span> <span class="pre">List[List]]]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.camera_frame_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of unit vectors in the camera frame as numpy arrays for m images corresponding to the
<a class="reference internal" href="#giant.calibration.CalibrationEstimator.measurements" title="giant.calibration.CalibrationEstimator.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> attribute.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.CalibrationEstimator.temperatures" title="giant.calibration.CalibrationEstimator.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a> list. Each column of this concatenated array will correspond to
the same column of the <a class="reference internal" href="#giant.calibration.CalibrationEstimator.measurements" title="giant.calibration.CalibrationEstimator.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> array. (That is
<code class="docutils literal notranslate"><span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">measurements[:,</span> <span class="pre">i]</span></code>).</p>
<p>Any images for which no stars were identified (due to any number of reasons) will have a list of empty arrays in
the corresponding element of this list (that is <code class="docutils literal notranslate"><span class="pre">camera_frame_directions[i]</span> <span class="pre">==</span> <span class="pre">[[],</span> <span class="pre">[],</span> <span class="pre">[]]</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is an
image with no measurements identified).  These will be automatically dropped by numpy’s concatenate, but are
included to notify the user which temperatures to use.</p>
<p>This will always be set before a call to <a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
<p>This should be a read/write property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.temperatures">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">temperatures</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[List[numbers.Real]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.temperatures" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of temperatures of the camera for each image being considered in estimation.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.CalibrationEstimator.camera_frame_directions" title="giant.calibration.CalibrationEstimator.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> list.</p>
<p>This will always be set before a call to <a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> (although sometimes it may be a list of all zeros if
temperature data is not available for the camera).</p>
<p>This should be a read/write property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.postfit_covariance">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">postfit_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.postfit_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit state covariance matrix, taking into account the measurement covariance matrix (if applicable).</p>
<p>This returns the post-fit state covariance matrix after a call to <a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  The covariance matrix will
be in the order according to <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">estimation_parameters</span></code></a> and if <a class="reference internal" href="#giant.calibration.CalibrationEstimator.weighted_estimation" title="giant.calibration.CalibrationEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> will return the state covariance matrix taking into account the measurement covariance matrix.  If
<a class="reference internal" href="#giant.calibration.CalibrationEstimator.weighted_estimation" title="giant.calibration.CalibrationEstimator.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then this will return the post-fit state covariance matrix assuming no
measurement weighting (that is a measurement covariance matrix of the identity matrix).  If <a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
has not been called yet then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<p>This is a read only property</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.postfit_residuals">
<em class="property"><span class="pre">abstract</span> <span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">postfit_residuals</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.CalibrationEstimator.postfit_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit observed-computed measurement residuals as a 2xn numpy array.</p>
<p>This returns the post-fit observed minus computed measurement residuals after a call to <a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  If
<a class="reference internal" href="#giant.calibration.CalibrationEstimator.estimate" title="giant.calibration.CalibrationEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> has not been called yet then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>This is a read only property</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.estimate">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#CalibrationEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.CalibrationEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates an updated camera model that better transforms the camera frame directions into pixel locations to
minimize the residuals between the observed and the predicted star locations.</p>
<p>Typically, upon successful completion, the updated camera model is stored in the <a class="reference internal" href="#giant.calibration.CalibrationEstimator.model" title="giant.calibration.CalibrationEstimator.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> attribute, the
<a class="reference internal" href="#giant.calibration.CalibrationEstimator.successful" title="giant.calibration.CalibrationEstimator.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> should return <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <a class="reference internal" href="#giant.calibration.CalibrationEstimator.postfit_residuals" title="giant.calibration.CalibrationEstimator.postfit_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code></a> and <a class="reference internal" href="#giant.calibration.CalibrationEstimator.postfit_covariance" title="giant.calibration.CalibrationEstimator.postfit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code></a> should
both be not None.  If estimation is unsuccessful, then <a class="reference internal" href="#giant.calibration.CalibrationEstimator.successful" title="giant.calibration.CalibrationEstimator.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> should be set to <code class="docutils literal notranslate"><span class="pre">False</span></code> and
everything else will be ignored so you can do whatever you want with it.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.CalibrationEstimator.reset">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#CalibrationEstimator.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.CalibrationEstimator.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>This method resets all of the data attributes to their default values to prepare for another estimation.</p>
<p>This should reset</p>
<ul class="simple">
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.successful" title="giant.calibration.CalibrationEstimator.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.measurement_covariance" title="giant.calibration.CalibrationEstimator.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.a_priori_state_covariance" title="giant.calibration.CalibrationEstimator.a_priori_state_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_state_covariance</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.measurements" title="giant.calibration.CalibrationEstimator.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.camera_frame_directions" title="giant.calibration.CalibrationEstimator.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.temperatures" title="giant.calibration.CalibrationEstimator.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.postfit_covariance" title="giant.calibration.CalibrationEstimator.postfit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.CalibrationEstimator.postfit_residuals" title="giant.calibration.CalibrationEstimator.postfit_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code></a></p></li>
</ul>
<p>to their default values (typically <code class="docutils literal notranslate"><span class="pre">None</span></code>) to ensure that data from one estimation doesn’t get mixed with data
from a subsequent estimation.  You may also choose to reset some other attributes depending on the
implementation of the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">IterativeNonlinearLSTSQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_frame_directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_priori_state_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#IterativeNonlinearLSTSQ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="calibration/estimators/giant.calibration.estimators.CalibrationEstimator.html#giant.calibration.estimators.CalibrationEstimator" title="giant.calibration.estimators.CalibrationEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">giant.calibration.estimators.CalibrationEstimator</span></code></a></p>
<p>This concrete estimator implements iterative non-linear least squares for estimating an updated camera model.</p>
<p>Iterative non-linear least squares estimation is done by estimating updates to the “state” vector (in this case the
camera model parameters being updated) iteratively.  At each step, the system is linearized about the current
estimate of the state and the additive update is estimated.  This iteration is repeated until convergence (or
divergence) based on the pre/post update residuals and the update vector itself.</p>
<p>The state vector that is being estimated by this class is controlled by the
<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute of the provided camera model.  This class does not actually use
the <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a> attribute since it is handled by the
<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.compute_jacobian.html#giant.camera_models.camera_model.CameraModel.compute_jacobian" title="giant.camera_models.camera_model.CameraModel.compute_jacobian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.compute_jacobian()</span></code></a> and <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.apply_update.html#giant.camera_models.camera_model.CameraModel.apply_update" title="giant.camera_models.camera_model.CameraModel.apply_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.apply_update()</span></code></a> methods of the provided camera model
internally, but it is mentioned here to show how to control what exactly is being estimated.</p>
<p>Because this class linearizes about the current estimate of the state, it requires an initial guess for the camera
model that is “close enough” to the actual model to ensure convergence.  Defining “close enough” in any broad sense
is impossible, but based on experience, using the manufacturer defined specs for focal length/pixel pitch and
assuming no distortion is generally “close enough” even for cameras with heavy distortion (star identification may
require a better initial model than this anyway).</p>
<p>As this class converges the state estimate, it updates the supplied camera model in place, therefore, if you wish to
keep a copy of the original camera model, you should manually create a copy of it before calling the
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method on this class.</p>
<p>In the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> method, convergence is checked on both the sum of squares of the residuals and the update
vector for the state.  That is convergence is reached when either of</p>
<div class="math notranslate nohighlight">
\begin{gather*}
\left\|\mathbf{r}_{pre}^T\mathbf{r}_{pre} - \mathbf{r}_{post}^T\mathbf{r}_{post}\right\|
\le(a_r+r_r\mathbf{r}_{pre}^T\mathbf{r}_{pre}) \\
\text{all}\left[\left\|\mathbf{u}\right\|\le(a_s+r_s\mathbf{s}_{pre})\right]
\end{gather*}</div><p>is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Here <span class="math notranslate nohighlight">\(\mathbf{r}_{pre}\)</span> is the nx1 vector of residuals before the update is applied,
<span class="math notranslate nohighlight">\(\mathbf{r}_{post}\)</span> is the nx1 vector of residuals after the update is applied, <span class="math notranslate nohighlight">\(a_r\)</span> is the
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.residual_atol" title="giant.calibration.IterativeNonlinearLSTSQ.residual_atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">residual_atol</span></code></a> absolute residual tolerance, <span class="math notranslate nohighlight">\(r_r\)</span> is the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.residual_rtol" title="giant.calibration.IterativeNonlinearLSTSQ.residual_rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">residual_rtol</span></code></a> relative residual
tolerance, <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> is the update vector, <span class="math notranslate nohighlight">\(\text{all}\)</span> indicates that the contained expression is
<code class="docutils literal notranslate"><span class="pre">True</span></code> for all elements, <span class="math notranslate nohighlight">\(a_s\)</span> is the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.state_atol" title="giant.calibration.IterativeNonlinearLSTSQ.state_atol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_atol</span></code></a> absolute tolerance for the state vector,
<span class="math notranslate nohighlight">\(r_s\)</span> is the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.state_rtol" title="giant.calibration.IterativeNonlinearLSTSQ.state_rtol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_rtol</span></code></a> relative tolerance for the state vector, and <span class="math notranslate nohighlight">\(\mathbf{s}_{pre}\)</span> is the
state vector before the update is applied.  Divergence is only checked on the sum of squares of the residuals, that
is, divergence is occurring when</p>
<div class="math notranslate nohighlight">
\[\mathbf{r}_{pre}^T\mathbf{r}_{pre} &lt; \mathbf{r}_{post}^T\mathbf{r}_{post}\]</div>
<p>where all is as defined as before.  If a case is diverging then a warning will be printed, the iteration will cease,
and <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="giant.calibration.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Typically this class is not used by the user, and instead it is used internally by the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class
which handles data preparation for you. If you wish to use this externally from the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class you
must first set</p>
<ul class="simple">
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.model" title="giant.calibration.IterativeNonlinearLSTSQ.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a> <em>if</em> <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> <em>is</em> <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.a_priori_state_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.a_priori_state_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_state_covariance</span></code></a> <em>if</em> <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">use_a_priori</span></code></a> <em>is set to</em> <code class="docutils literal notranslate"><span class="pre">True</span></code> for the camera
model.</p></li>
</ul>
<p>according to their documentation.  Once those have been set, you can perform the estimation using <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
which will iterate until convergence (or divergence).  If the fit successfully converges, <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="giant.calibration.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be
set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and attributes <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code></a> and <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals" title="giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code></a> will both return numpy
arrays instead of <code class="docutils literal notranslate"><span class="pre">None</span></code>.  If you wish to use the same instance of this class to do another estimation you should
call <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.reset" title="giant.calibration.IterativeNonlinearLSTSQ.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> before setting the new data to ensure that data is not mixed between estimation runs and all
flags are set correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><em>giant.camera_models.camera_model.CameraModel</em></a><em>]</em>) – The camera model instance to be estimated set with an initial guess of the state.</p></li>
<li><p><strong>weighted_estimation</strong> (<em>bool</em>) – A boolean flag specifying whether to do weighted estimation.  <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates
that the measurement weights (and a priori state covariance if applicable) should be
used in the estimation.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – The maximum number of iteration steps to attempt to reach convergence.  If convergence has not
been reached after attempting <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> steps, a warning will be raised that the model has
not converged and <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="giant.calibration.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>residual_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>residual_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>state_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>state_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>measurements</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 2xn numpy array of measurement pixel locations to be fit to</p></li>
<li><p><strong>camera_frame_directions</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Union</em><em>[</em><em>numpy.ndarray</em><em>, </em><em>List</em><em>[</em><em>List</em><em>]</em><em>]</em><em>]</em><em>]</em>) – A length m list of 3xj numpy arrays or empty 3x1 list of empty lists where m is
the number of unique images the data comes from (and is the same length as
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a>) and j is the number of measurements from each image.  A
list of empty lists indicates that no measurements were identified for the
corresponding image.</p></li>
<li><p><strong>measurement_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>, </em><em>numbers.Real</em><em>]</em><em>]</em>) – An optional nxn numpy array containing the covariance matrix for the ravelled
measurement vector (in fortran order such that the ravelled measurement vector is
[x1, y1, x2, y2, … xk, yk] where k=n//2)</p></li>
<li><p><strong>a_priori_state_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – An optional lxl numpy array containing the a priori covariance matrix for the
a priori estimate of the state, where l is the number of parameters in the
state vector.  This is used only if <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>.  The length of the state vector can be determined by
<code class="docutils literal notranslate"><span class="pre">len(</span></code><a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.state_vector" title="giant.camera_models.camera_model.CameraModel.state_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.state_vector</span></code></a><code class="docutils literal notranslate"><span class="pre">)</span></code></p></li>
<li><p><strong>temperatures</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>numbers.Real</em><em>]</em><em>]</em>) – A length m list of floats containing the camera temperature at the time of each
corresponding image.  These may be used by the <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a> to perform temperature
dependent estimation of parameters like the focal length, depending on what is set for
<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.max_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of iteration steps to attempt for convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.residual_atol">
<span class="sig-name descname"><span class="pre">residual_atol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.residual_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute tolerance for the sum of square of the residuals to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.residual_rtol">
<span class="sig-name descname"><span class="pre">residual_rtol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.residual_rtol" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative tolerance for the sum of square of the residuals to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.state_atol">
<span class="sig-name descname"><span class="pre">state_atol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.state_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute tolerance for the state vector to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.state_rtol">
<span class="sig-name descname"><span class="pre">state_rtol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.state_rtol" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative tolerance for the state vector to indicate convergence</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.model">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">model</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[giant.camera_models.camera_model.CameraModel]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The camera model that is being estimated.</p>
<p>Typically this should be a subclass of <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.successful">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">successful</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag indicating whether the fit was successful or not.</p>
<p>If the fit was successful this should return <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> if otherwise.  A fit is defined as
successful if convergence criteria were reached before the maximum number of iterations.  Divergence and
non-convergence are both considered an unsuccessful fit resulting in this being set to <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">weighted_estimation</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean flag specifying whether to do weighted estimation.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the estimator will use the provided measurement weights in <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a>
during the estimation process.  If set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, then no measurement weights will be considered.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">measurement_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray,</span> <span class="pre">numbers.Real]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the measurements or a scalar containing the variance
for all of the measurements.</p>
<p>If <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then this property will contain the measurement covariance
matrix as a square, full rank, numpy array or the measurement variance as a scalar float.  If
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> then this property may be <code class="docutils literal notranslate"><span class="pre">None</span></code> and will be ignored.</p>
<p>If specified as a scalar, it is treated as the <strong>variance</strong> for each measurement (that is <code class="docutils literal notranslate"><span class="pre">cov</span> <span class="pre">=</span> <span class="pre">v*I(n,n)</span></code>
where <code class="docutils literal notranslate"><span class="pre">cov</span></code> is the covariance matrix, <code class="docutils literal notranslate"><span class="pre">v</span></code> is the specified scalar variance, and <code class="docutils literal notranslate"><span class="pre">I(n,n)</span></code> is a nxn identity
matrix) in a memory efficient way.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – When attempting to set an array that does not have the proper shape for the
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.a_priori_state_covariance">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">a_priori_state_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.a_priori_state_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>A square numpy array containing the covariance matrix for the a priori estimate of the state vector.</p>
<p>This is only considered if <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and if
<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise it is ignored.  If both are set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then
this should be set to a square, full rank, lxl numpy array where <code class="docutils literal notranslate"><span class="pre">l=len(model.state_vector)</span></code> containing the
covariance matrix for the a priori state vector.  The order of the parameters in the state vector can be
determined from <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.get_state_labels.html#giant.camera_models.camera_model.CameraModel.get_state_labels" title="giant.camera_models.camera_model.CameraModel.get_state_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CameraModel.get_state_labels()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the shape of the input matrix is not appropriate for the size of the state vector</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.measurements">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">measurements</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>A nx2 numpy array of the observed pixel locations for stars across all images</p>
<p>Each column of this array corresponds to the same column of the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> concatenated
down the last axis. (That is <code class="docutils literal notranslate"><span class="pre">measurements[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span></code>)</p>
<p>This must always be set before a call to <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">camera_frame_directions</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[List[Union[numpy.ndarray,</span> <span class="pre">List[List]]]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of unit vectors in the camera frame as numpy arrays for m images corresponding to the
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> attribute.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a> list. Each column of this concatenated array will correspond to
the same column of the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a> array. (That is
<code class="docutils literal notranslate"><span class="pre">np.concatenate(camera_frame_directions,</span> <span class="pre">axis=-1)[:,</span> <span class="pre">i]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">measurements[:,</span> <span class="pre">i]</span></code>).</p>
<p>Any images for which no stars were identified (due to any number of reasons) will have a list of empty arrays in
the corresponding element of this list (that is <code class="docutils literal notranslate"><span class="pre">camera_frame_directions[i]</span> <span class="pre">==</span> <span class="pre">[[],</span> <span class="pre">[],</span> <span class="pre">[]]</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is an
image with no measurements identified).  These will be automatically dropped by numpy’s concatenate, but are
included to notify the which temperatures/misalignments to use.</p>
<p>This must always be set before a call to <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.temperatures">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">temperatures</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[List[numbers.Real]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.temperatures" title="Permalink to this definition">¶</a></dt>
<dd><p>A length m list of temperatures of the camera for each image being considered in estimation.</p>
<p>Each element of this list corresponds to a unique image that is being considered for estimation and the
subsequent element in the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> list.</p>
<p>This must always be set before a call to <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> (although sometimes it may be a list of all zeros if
temperature data is not available for the camera).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">postfit_covariance</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit state covariance matrix, taking into account the measurement covariance matrix (if applicable).</p>
<p>This returns the post-fit state covariance matrix after a call to <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  The covariance matrix will
be in the order according to <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">estimation_parameters</span></code></a> and if <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> will return the state covariance matrix taking into account the measurement covariance matrix.  If
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation" title="giant.calibration.IterativeNonlinearLSTSQ.weighted_estimation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">weighted_estimation</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then this will return the post-fit state covariance matrix assuming no
measurement weighting (that is a measurement covariance matrix of the identity matrix).  If <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>
has not been called yet or the fit was unsuccessful then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">postfit_residuals</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[Union[Sequence,</span> <span class="pre">numpy.ndarray]]</span></em><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>The post-fit observed-computed measurement residuals as a 2xn numpy array.</p>
<p>This returns the post-fit observed minus computed measurement residuals after a call to <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  If
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="giant.calibration.IterativeNonlinearLSTSQ.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> has not been called yet or the fit was unsuccessful then this will return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#IterativeNonlinearLSTSQ.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>This method resets all of the data attributes to their default values to prepare for another estimation.</p>
<p>Specifically</p>
<ul class="simple">
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="giant.calibration.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.measurement_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurement_covariance</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.a_priori_state_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.a_priori_state_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">a_priori_state_covariance</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.temperatures" title="giant.calibration.IterativeNonlinearLSTSQ.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code></a></p></li>
<li><p><a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals" title="giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code></a></p></li>
</ul>
<p>are reset to their default values (typically <code class="docutils literal notranslate"><span class="pre">None</span></code>).  This also clears the caches for some internally used
attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.compute_residuals">
<span class="sig-name descname"><span class="pre">compute_residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#IterativeNonlinearLSTSQ.compute_residuals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.compute_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the observed minus computed residuals for the current model (or an input model).</p>
<p>The residuals are returned as a 2xn numpy array where n is the number of stars observed with units of pixels.</p>
<p>The computed values are determined by calls to <code class="docutils literal notranslate"><span class="pre">model.project_onto_image</span></code> for the
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> for each image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><em>giant.camera_models.camera_model.CameraModel</em></a><em>]</em>) – An optional model to compute the residuals using.  If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then will use <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.model" title="giant.calibration.IterativeNonlinearLSTSQ.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The observed minus computed residuals as a numpy array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.IterativeNonlinearLSTSQ.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#IterativeNonlinearLSTSQ.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.IterativeNonlinearLSTSQ.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates an updated camera model that better transforms the camera frame directions into pixel locations to
minimize the residuals between the observed and the predicted star locations.</p>
<p>Upon successful completion, the updated camera model is stored in the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.model" title="giant.calibration.IterativeNonlinearLSTSQ.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> attribute, the
<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="giant.calibration.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals" title="giant.calibration.IterativeNonlinearLSTSQ.postfit_residuals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_residuals</span></code></a> and <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance" title="giant.calibration.IterativeNonlinearLSTSQ.postfit_covariance"><code class="xref py py-attr docutils literal notranslate"><span class="pre">postfit_covariance</span></code></a> should
both be not None.  If estimation is unsuccessful, then <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.successful" title="giant.calibration.IterativeNonlinearLSTSQ.successful"><code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code></a> should be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The estimation is done using nonlinear iterative least squares, as discussed in the class documentation
(<a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ" title="giant.calibration.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.model" title="giant.calibration.IterativeNonlinearLSTSQ.model"><code class="xref py py-attr docutils literal notranslate"><span class="pre">model</span></code></a>, <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.measurements" title="giant.calibration.IterativeNonlinearLSTSQ.measurements"><code class="xref py py-attr docutils literal notranslate"><span class="pre">measurements</span></code></a>, or <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions" title="giant.calibration.IterativeNonlinearLSTSQ.camera_frame_directions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_frame_directions</span></code></a> are <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">LMAEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_divergence_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_frame_directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measurement_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_priori_state_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#LMAEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.LMAEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="calibration/estimators/giant.calibration.estimators.IterativeNonlinearLSTSQ.html#giant.calibration.estimators.IterativeNonlinearLSTSQ" title="giant.calibration.estimators.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">giant.calibration.estimators.IterativeNonlinearLSTSQ</span></code></a></p>
<p>This implements a Levenberg-Marquardt Algorithm estimator, which is analogous to a damped iterative non-linear
least squares.</p>
<p>This class is nearly exactly the same as the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ" title="giant.calibration.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a> except that it adds damping to the
update step of the iterative non-linear least squares algorithm and allows a few diverging steps in a row where the
damping parameter is updated before failing.  The number of diverging steps that are allowed is controlled by the
<a class="reference internal" href="#giant.calibration.LMAEstimator.max_divergence_steps" title="giant.calibration.LMAEstimator.max_divergence_steps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_divergence_steps</span></code></a> setting.  This represents only difference from the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ" title="giant.calibration.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a>
interface from the user’s perspective.</p>
<p>In general, this algorithm will result in the same answer as the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ" title="giant.calibration.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a> algorithm but at a
slower convergence rate.  In a few cases however, this estimator can be more robust to initial guess errors,
achieving convergence when the standard iterative nonlinear least squares diverges.  Therefore, it is likely best to
start with the <a class="reference internal" href="#giant.calibration.IterativeNonlinearLSTSQ" title="giant.calibration.IterativeNonlinearLSTSQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeNonlinearLSTSQ</span></code></a> class an only switch to this if you experience convergence issues.</p>
<p>The implementation of the LMA in this class is inspired by
<a class="reference external" href="https://link.springer.com/article/10.1007/s40295-016-0091-3">https://link.springer.com/article/10.1007/s40295-016-0091-3</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><em>giant.camera_models.camera_model.CameraModel</em></a><em>]</em>) – The camera model instance to be estimated set with an initial guess of the state.</p></li>
<li><p><strong>weighted_estimation</strong> (<em>bool</em>) – A boolean flag specifying whether to do weighted estimation.  <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates
that the measurement weights (and a priori state covariance if applicable) should be
used in the estimation.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – The maximum number of iteration steps to attempt to reach convergence.  If convergence has not
been reached after attempting <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> steps, a warning will be raised that the model has
not converged and <code class="xref py py-attr docutils literal notranslate"><span class="pre">successful</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>residual_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>residual_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the sum of squares of the residuals</p></li>
<li><p><strong>state_atol</strong> (<em>float</em>) – The absolute convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>state_rtol</strong> (<em>float</em>) – The relative convergence tolerance criteria for the elements of the state vector</p></li>
<li><p><strong>max_divergence_steps</strong> (<em>int</em>) – The maximum number of steps in a row that can diverge before breaking iteration</p></li>
<li><p><strong>measurements</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – A 2xn numpy array of measurement pixel locations to be fit to</p></li>
<li><p><strong>camera_frame_directions</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Union</em><em>[</em><em>numpy.ndarray</em><em>, </em><em>List</em><em>[</em><em>List</em><em>]</em><em>]</em><em>]</em><em>]</em>) – A length m list of 3xj numpy arrays or empty 3x1 list of empty lists where m is
the number of unique images the data comes from (and is the same length as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code>) and j is the number of measurements from each image.  A
list of empty lists indicates that no measurements were identified for the
corresponding image.</p></li>
<li><p><strong>measurement_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>, </em><em>numbers.Real</em><em>]</em><em>]</em>) – An optional nxn numpy array containing the covariance matrix for the ravelled
measurement vector (in fortran order such that the ravelled measurement vector is
[x1, y1, x2, y2, … xk, yk] where k=n//2)</p></li>
<li><p><strong>a_priori_state_covariance</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – An optional lxl numpy array containing the a priori covariance matrix for the
a priori estimate of the state, where l is the number of parameters in the
state vector.  This is used only if <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.use_a_priori" title="giant.camera_models.camera_model.CameraModel.use_a_priori"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.use_a_priori</span></code></a> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>.  The length of the state vector can be determined by
<code class="docutils literal notranslate"><span class="pre">len(</span></code><a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.state_vector" title="giant.camera_models.camera_model.CameraModel.state_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.state_vector</span></code></a><code class="docutils literal notranslate"><span class="pre">)</span></code></p></li>
<li><p><strong>temperatures</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>numbers.Real</em><em>]</em><em>]</em>) – A length m list of floats containing the camera temperature at the time of each
corresponding image.  These may be used by the <a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel" title="giant.camera_models.camera_model.CameraModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CameraModel</span></code></a> to perform temperature
dependent estimation of parameters like the focal length, depending on what is set for
<a class="reference internal" href="camera_model/giant.camera_models.camera_model.CameraModel.html#giant.camera_models.camera_model.CameraModel.estimation_parameters" title="giant.camera_models.camera_model.CameraModel.estimation_parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CameraModel.estimation_parameters</span></code></a></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.max_iter">
<span class="sig-name descname"><span class="pre">max_iter</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#giant.calibration.LMAEstimator.max_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of iteration steps to attempt for convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.residual_atol">
<span class="sig-name descname"><span class="pre">residual_atol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.LMAEstimator.residual_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute tolerance for the sum of square of the residuals to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.residual_rtol">
<span class="sig-name descname"><span class="pre">residual_rtol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.LMAEstimator.residual_rtol" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative tolerance for the sum of square of the residuals to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.state_atol">
<span class="sig-name descname"><span class="pre">state_atol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.LMAEstimator.state_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute tolerance for the state vector to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.state_rtol">
<span class="sig-name descname"><span class="pre">state_rtol</span></span><em class="property"><span class="pre">:</span> <span class="pre">float</span></em><a class="headerlink" href="#giant.calibration.LMAEstimator.state_rtol" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative tolerance for the state vector to indicate convergence</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.max_divergence_steps">
<span class="sig-name descname"><span class="pre">max_divergence_steps</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#giant.calibration.LMAEstimator.max_divergence_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of steps in a row that can diverge before breaking iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.LMAEstimator.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#LMAEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.LMAEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>This method estimates the postfit residuals based on the model, weight matrix, lma coefficient, etc.
Convergence is achieved once the standard deviation of the computed residuals is less than the absolute
tolerance or the difference between the prefit and postfit residuals is less than the relative tolerance.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.StaticAlignmentEstimator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">StaticAlignmentEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame1_unit_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame2_unit_vecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#StaticAlignmentEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StaticAlignmentEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class estimates a static attitude alignment between one frame and another.</p>
<p>The static alignment is estimated using Davenport’s Q-Method solution to Wahba’s problem, using the
<a class="reference internal" href="#giant.calibration.DavenportQMethod" title="giant.calibration.DavenportQMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">DavenportQMethod</span></code></a> class.  To use, simply specify the unit vectors from the base frame and the unit vectors
from the target frame, and then call <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator.estimate" title="giant.calibration.StaticAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a>.  The estimated alignment from frame 1 to frame 2 will
be stored as a <a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object in <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator.alignment" title="giant.calibration.StaticAlignmentEstimator.alignment"><code class="xref py py-attr docutils literal notranslate"><span class="pre">alignment</span></code></a>.</p>
<p>In general this class should not be used by the user, and instead you should use the <a class="reference internal" href="#giant.calibration.Calibration" title="giant.calibration.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Calibration</span></code></a> class and
its <a class="reference internal" href="#giant.calibration.Calibration.estimate_static_alignment" title="giant.calibration.Calibration.estimate_static_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate_static_alignment()</span></code></a> method which will handle set up and tear down of this class for
you.</p>
<p>For more details about the algorithm used see the <a class="reference internal" href="#giant.calibration.DavenportQMethod" title="giant.calibration.DavenportQMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">DavenportQMethod</span></code></a> documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame1_unit_vecs</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – Unit vectors in the base frame as a 3xn array where each column is a unit vector.</p></li>
<li><p><strong>frame2_unit_vecs</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>, </em><em>numpy.ndarray</em><em>]</em><em>]</em>) – Unit vectors in the destination (camera) frame as a 3xn array where each column is a
unit vector</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StaticAlignmentEstimator.frame1_unit_vecs">
<span class="sig-name descname"><span class="pre">frame1_unit_vecs</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StaticAlignmentEstimator.frame1_unit_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>The base frame unit vectors.</p>
<p>Each column of this 3xn matrix should correspond to the same column in the <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator.frame2_unit_vecs" title="giant.calibration.StaticAlignmentEstimator.frame2_unit_vecs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">frame2_unit_vecs</span></code></a> attribute.</p>
<p>Typically this data should come from multiple images to ensure a good alignment can be estimated over 
time.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StaticAlignmentEstimator.frame2_unit_vecs">
<span class="sig-name descname"><span class="pre">frame2_unit_vecs</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StaticAlignmentEstimator.frame2_unit_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>The target frame unit vectors.</p>
<p>Each column of this 3xn matrix should correspond to the same column in the <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator.frame1_unit_vecs" title="giant.calibration.StaticAlignmentEstimator.frame1_unit_vecs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">frame1_unit_vecs</span></code></a> attribute.</p>
<p>Typically this data should come from multiple images to ensure a good alignment can be estimated over 
time.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.StaticAlignmentEstimator.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><span class="pre">giant.rotations.Rotation</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.StaticAlignmentEstimator.alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>The location where the estimated alignment is stored</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.StaticAlignmentEstimator.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#StaticAlignmentEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.StaticAlignmentEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the static alignment between the frame 1 and frame 2 using Davenport’s Q Method Solution.</p>
<p>The estimated alignment is stored in the <a class="reference internal" href="#giant.calibration.StaticAlignmentEstimator.alignment" title="giant.calibration.StaticAlignmentEstimator.alignment"><code class="xref py py-attr docutils literal notranslate"><span class="pre">alignment</span></code></a> attribute.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">giant.calibration.</span></span><span class="sig-name descname"><span class="pre">TemperatureDependentAlignmentEstimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_1_rotations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_2_rotations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#TemperatureDependentAlignmentEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class estimates a temperature dependent attitude alignment between one frame and another.</p>
<p>The temperature dependent alignment is found by fitting linear temperature dependent euler angles (or
Tait-Bryan angles) to transform from the first frame to the second.  That is</p>
<div class="math notranslate nohighlight">
\[\mathbf{T}_B=\mathbf{R}_m(\theta_m(t))\mathbf{R}_n(\theta_n(t))\mathbf{R}_p(\theta_p(t))\mathbf{T}_A\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{T}_B\)</span> is the target frame, <span class="math notranslate nohighlight">\(\mathbf{R}_i\)</span> is the rotation matrix about the <span class="math notranslate nohighlight">\(i^{th}\)</span>
axis, <span class="math notranslate nohighlight">\(\mathbf{T}_A\)</span> is the base frame, and <span class="math notranslate nohighlight">\(\theta_i(t)\)</span> are the linear angles.</p>
<p>This fit is done in a least squares sense by computing the values for <span class="math notranslate nohighlight">\(\theta_i(t)\)</span> across a range of
temperatures (by estimating the attitude for multiple single images) and then solving the system</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{cc} 1 &amp; t_1 \\ 1 &amp; t_2 \\ \vdots &amp; \vdots \\ 1 &amp; t_n \end{array}\right]
\left[\begin{array}{ccc} \theta_{m0} &amp; \theta_{n0} &amp; \theta_{p0} \\
\theta_{m1} &amp; \theta_{n1} &amp; \theta_{p1}\end{array}\right] =
\left[\begin{array}{ccc}\vphantom{\theta}^0\theta_m &amp;\vphantom{\theta}^0\theta_n &amp;\vphantom{\theta}^0\theta_p\\
\vdots &amp; \vdots &amp; \vdots \\
\vphantom{\theta}^k\theta_m &amp;\vphantom{\theta}^k\theta_n &amp;\vphantom{\theta}^k\theta_p\end{array}\right]\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\vphantom{\theta}^k\theta_i\)</span> is the measured Euler/Tait-Bryan angle for the <span class="math notranslate nohighlight">\(k^{th}\)</span> image.</p>
<p>In general a user should not use this class and instead the
<a class="reference internal" href="#giant.calibration.Calibration.estimate_temperature_dependent_alignment" title="giant.calibration.Calibration.estimate_temperature_dependent_alignment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Calibration.estimate_temperature_dependent_alignment()</span></code></a> should be used which handles the proper setup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_1_rotations</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><em>giant.rotations.Rotation</em></a><em>]</em><em>]</em>) – The rotation objects from the inertial frame to the base frame</p></li>
<li><p><strong>frame_2_rotations</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><em>giant.rotations.Rotation</em></a><em>]</em><em>]</em>) – The rotation objects from the inertial frame to the target frame</p></li>
<li><p><strong>temperatures</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>numbers.Real</em><em>]</em><em>]</em>) – The temperature of the camera corresponding to the times the input rotations were
estimated.</p></li>
<li><p><strong>order</strong> (<em>str</em>) – The order of the rotations to perform according to the convention in <a class="reference internal" href="rotations/giant.rotations.quaternion_to_euler.html#giant.rotations.quaternion_to_euler" title="giant.rotations.quaternion_to_euler"><code class="xref py py-func docutils literal notranslate"><span class="pre">quaternion_to_euler()</span></code></a></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.frame_1_rotations">
<span class="sig-name descname"><span class="pre">frame_1_rotations</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><span class="pre">giant.rotations.Rotation</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.frame_1_rotations" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterable containing the rotations from the inertial frame to the base frame for each image under 
consideration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.frame_2_rotations">
<span class="sig-name descname"><span class="pre">frame_2_rotations</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="rotations/giant.rotations.Rotation.html#giant.rotations.Rotation" title="giant.rotations.Rotation"><span class="pre">giant.rotations.Rotation</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.frame_2_rotations" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterable containing the rotations from the inertial frame to the target frame for each image under 
consideration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.temperatures">
<span class="sig-name descname"><span class="pre">temperatures</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numbers.Real</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.temperatures" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing the temperatures of the camera for each image under consideration</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.order">
<span class="sig-name descname"><span class="pre">order</span></span><em class="property"><span class="pre">:</span> <span class="pre">str</span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.order" title="Permalink to this definition">¶</a></dt>
<dd><p>The order of the Euler angles according to the convention in <a class="reference internal" href="rotations/giant.rotations.quaternion_to_euler.html#giant.rotations.quaternion_to_euler" title="giant.rotations.quaternion_to_euler"><code class="xref py py-func docutils literal notranslate"><span class="pre">quaternion_to_euler()</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.angle_m_offset">
<span class="sig-name descname"><span class="pre">angle_m_offset</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.angle_m_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated constant angle offset for the m rotation axis in radians.</p>
<p>This will be <code class="docutils literal notranslate"><span class="pre">None</span></code> until <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> is called.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.angle_m_slope">
<span class="sig-name descname"><span class="pre">angle_m_slope</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.angle_m_slope" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated angle temperature slope for the m rotation axis in radians.</p>
<p>This will be <code class="docutils literal notranslate"><span class="pre">None</span></code> until <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> is called.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.angle_n_offset">
<span class="sig-name descname"><span class="pre">angle_n_offset</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.angle_n_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated constant angle offset for the n rotation axis in radians.</p>
<p>This will be <code class="docutils literal notranslate"><span class="pre">None</span></code> until <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> is called.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.angle_n_slope">
<span class="sig-name descname"><span class="pre">angle_n_slope</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.angle_n_slope" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated angle temperature slope for the n rotation axis in radians.</p>
<p>This will be <code class="docutils literal notranslate"><span class="pre">None</span></code> until <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> is called.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.angle_p_offset">
<span class="sig-name descname"><span class="pre">angle_p_offset</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.angle_p_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated constant angle offset for the p rotation axis in radians.</p>
<p>This will be <code class="docutils literal notranslate"><span class="pre">None</span></code> until <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> is called.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.angle_p_slope">
<span class="sig-name descname"><span class="pre">angle_p_slope</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.angle_p_slope" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated angle temperature slope for the p rotation axis in radians.</p>
<p>This will be <code class="docutils literal notranslate"><span class="pre">None</span></code> until <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="giant.calibration.TemperatureDependentAlignmentEstimator.estimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code></a> is called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="giant.calibration.TemperatureDependentAlignmentEstimator.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/giant/calibration/estimators.html#TemperatureDependentAlignmentEstimator.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#giant.calibration.TemperatureDependentAlignmentEstimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>This method estimates the linear temperature dependent alignment as 3 linear temperature dependent euler
angles according to <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.order" title="giant.calibration.TemperatureDependentAlignmentEstimator.order"><code class="xref py py-attr docutils literal notranslate"><span class="pre">order</span></code></a>.</p>
<p>This is done by first converting the relative rotation from the base frame to the target frame into euler angles
for each image under consideration, and then performing a linear least squares estimate of the temperature
dependence.  The resulting fit is store in the <code class="docutils literal notranslate"><span class="pre">angle_..._...</span></code> attributes in units of radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if any of <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.temperatures" title="giant.calibration.TemperatureDependentAlignmentEstimator.temperatures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">temperatures</span></code></a>, <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.frame_1_rotations" title="giant.calibration.TemperatureDependentAlignmentEstimator.frame_1_rotations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">frame_1_rotations</span></code></a>, <a class="reference internal" href="#giant.calibration.TemperatureDependentAlignmentEstimator.frame_2_rotations" title="giant.calibration.TemperatureDependentAlignmentEstimator.frame_2_rotations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">frame_2_rotations</span></code></a> are
still <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<p class="rubric">Modules</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="calibration/giant.calibration.calibration_class.html#module-giant.calibration.calibration_class" title="giant.calibration.calibration_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calibration_class</span></code></a></p></td>
<td><p>This module provides a subclass of the <a class="reference internal" href="opnav_class/giant.opnav_class.OpNav.html#giant.opnav_class.OpNav" title="giant.opnav_class.OpNav"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpNav</span></code></a> class for performing stellar OpNav and camera calibration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="calibration/giant.calibration.estimators.html#module-giant.calibration.estimators" title="giant.calibration.estimators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimators</span></code></a></p></td>
<td><p>This module provides the ability to estimate geometric camera models as well as static and temperature dependent attitude alignment based off of observations of stars in monocular images.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="calibration/giant.calibration.visualizer.html#module-giant.calibration.visualizer" title="giant.calibration.visualizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualizer</span></code></a></p></td>
<td><p>This module provides utilities for visually inspecting calibration and alignment results.</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="catalogues/utilities/giant.catalogues.utilities.MJD_EPOCH.html" title="Previous document">giant.catalogues.utilities.MJD_EPOCH</a>
        </li>
        <li>
          <a href="calibration/giant.calibration.calibration_class.html" title="Next document">giant.calibration.calibration_class</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/giant.calibration.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>