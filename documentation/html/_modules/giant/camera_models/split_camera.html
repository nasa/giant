<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.camera_models.split_camera &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.camera_models.split_camera</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides the SplitCamera class, which allows for combining two different camera models into a single model.</span>

<span class="sd">The SplitCamera class is useful when dealing with cameras that have different properties or behaviors in different</span>
<span class="sd">regions of the image or camera frame. It allows you to specify two different camera models and define how to split</span>
<span class="sd">between them based on either the camera frame coordinates or the image plane coordinates.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">To use the SplitCamera class, you need to provide two camera models and specify how to split between them:</span>

<span class="sd">    &gt;&gt;&gt; from giant.camera_models import PinholeModel, SplitCamera</span>
<span class="sd">    &gt;&gt;&gt; model1 = PinholeModel(...)</span>
<span class="sd">    &gt;&gt;&gt; model2 = PinholeModel(...)</span>
<span class="sd">    &gt;&gt;&gt; split_camera = SplitCamera(model1, model2, camera_frame_split_axis=CameraFrameSplitAxis.X,</span>
<span class="sd">    ...                            camera_frame_split_threshold=0.0)</span>

<span class="sd">The SplitCamera will then use model1 for points where the X coordinate in the camera frame is less than or equal to 0.0,</span>
<span class="sd">and model2 for points where the X coordinate is greater than 0.0.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">importlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">import_module</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntEnum</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Self</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lxml.etree</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">etree</span>  <span class="c1"># nosec</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">DTypeLike</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera_models.camera_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">CameraModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">F_SCALAR_OR_ARRAY</span><span class="p">,</span> <span class="n">NONENUM</span><span class="p">,</span> <span class="n">F_ARRAY_LIKE</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>


<div class="viewcode-block" id="CameraFrameSplitAxis">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.CameraFrameSplitAxis.html#giant.camera_models.split_camera.CameraFrameSplitAxis">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CameraFrameSplitAxis</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An enumeration specifying the axis to use for splitting in the camera frame.</span>

<span class="sd">    This enum is used to define which axis in the camera frame should be used to determine</span>
<span class="sd">    which of the two camera models to use for a given point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split along the X-axis of the camera frame&quot;&quot;&quot;</span>

    <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split along the Y-axis of the camera frame&quot;&quot;&quot;</span>

    <span class="n">Z</span> <span class="o">=</span> <span class="mi">2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split along the Z-axis of the camera frame&quot;&quot;&quot;</span></div>

    

<div class="viewcode-block" id="ImagePlaneSplitAxis">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.ImagePlaneSplitAxis.html#giant.camera_models.split_camera.ImagePlaneSplitAxis">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ImagePlaneSplitAxis</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An enumeration specifying the axis to use for splitting in the image plane.</span>

<span class="sd">    This enum is used to define which axis in the image plane should be used to determine</span>
<span class="sd">    which of the two camera models to use for a given pixel location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split along the X-axis (columns) of the image plane&quot;&quot;&quot;</span>

    <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split along the Y-axis (rows) of the image plane&quot;&quot;&quot;</span></div>




<div class="viewcode-block" id="SplitCamera">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.html#giant.camera_models.split_camera.SplitCamera">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SplitCamera</span><span class="p">(</span><span class="n">CameraModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A camera model that combines two different camera models for different regions of the detector.</span>

<span class="sd">    This class allows for the creation of a hybrid camera model that uses two different camera models for different</span>
<span class="sd">    regions of the detector. The split is defined in both the camera frame (using</span>
<span class="sd">    camera_frame_split_axis and camera_frame_split_threshold) and in the image plane (using image_plane_split_axis</span>
<span class="sd">    and image_plane_split_threshold).</span>

<span class="sd">    The SplitCamera inherits from the CameraModel base class and implements all required methods, delegating to</span>
<span class="sd">    either model1 or model2 based on the defined split.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model1</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">model2</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> 
                 <span class="n">camera_frame_split_axis</span><span class="p">:</span> <span class="n">CameraFrameSplitAxis</span> <span class="o">=</span> <span class="n">CameraFrameSplitAxis</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">camera_frame_split_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> 
                 <span class="n">image_plane_split_axis</span><span class="p">:</span> <span class="n">ImagePlaneSplitAxis</span> <span class="o">=</span> <span class="n">ImagePlaneSplitAxis</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">image_plane_split_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">field_of_view</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">use_a_priori</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a new SplitCamera instance.</span>

<span class="sd">        :param model1: The first camera model to use</span>
<span class="sd">        :param model2: The second camera model to use</span>
<span class="sd">        :param camera_frame_split_axis: The axis in the camera frame to use for splitting</span>
<span class="sd">        :param camera_frame_split_threshold: The threshold value for splitting in the camera frame</span>
<span class="sd">        :param image_plane_split_axis: The axis in the image plane to use for splitting</span>
<span class="sd">        :param image_plane_split_threshold: The threshold value for splitting in the image plane</span>
<span class="sd">        :param field_of_view: The field of view of the camera in degrees</span>
<span class="sd">        :param n_rows: The number of rows in the image</span>
<span class="sd">        :param n_cols: The number of columns in the image</span>
<span class="sd">        :param use_a_priori: Whether to use a priori information in calibration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">field_of_view</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">use_a_priori</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span> <span class="o">=</span> <span class="n">model1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span> <span class="o">=</span> <span class="n">model2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">camera_frame_split_axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_threshold</span> <span class="o">=</span> <span class="n">camera_frame_split_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">image_plane_split_axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_threshold</span> <span class="o">=</span> <span class="n">image_plane_split_threshold</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">important_attributes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;camera_frame_split_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;camera_frame_split_threshold&#39;</span><span class="p">,</span> <span class="s1">&#39;image_plane_split_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;image_plane_split_threshold&#39;</span><span class="p">])</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraModel</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the first camera model.</span>

<span class="sd">        :return: The first camera model used in the split camera</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraModel</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the second camera model.</span>

<span class="sd">        :return: The second camera model used in the split camera</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span><span class="w"> </span><span class="nf">camera_frame_split_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CameraFrameSplitAxis</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the axis used for splitting in the camera frame.</span>

<span class="sd">        :return: The CameraFrameSplitAxis enum value representing the split axis in the camera frame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CameraFrameSplitAxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_axis</span><span class="p">)</span>
    
    <span class="nd">@camera_frame_split_axis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">camera_frame_split_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">CameraFrameSplitAxis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the axis used for splitting in the camera frame.</span>

<span class="sd">        :param val: The CameraFrameSplitAxis enum value representing the new split axis in the camera frame</span>
<span class="sd">        :raises ValueError: If the provided value is not a valid CameraFrameSplitAxis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verify its a valid axis</span>
        <span class="n">CameraFrameSplitAxis</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>    
        
    <span class="nd">@property</span> 
    <span class="k">def</span><span class="w"> </span><span class="nf">image_plane_split_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ImagePlaneSplitAxis</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the axis used for splitting in the image plane.</span>

<span class="sd">        :return: The ImagePlaneSplitAxis enum value representing the split axis in the image plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ImagePlaneSplitAxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_axis</span><span class="p">)</span>
    
    <span class="nd">@image_plane_split_axis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">image_plane_split_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ImagePlaneSplitAxis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the axis used for splitting in the image plane.</span>

<span class="sd">        :param val: The ImagePlaneSplitAxis enum value representing the new split axis in the image plane</span>
<span class="sd">        :raises ValueError: If the provided value is not a valid ImagePlaneSplitAxis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verify its a valid axis</span>
        <span class="n">ImagePlaneSplitAxis</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>    
    
    <span class="nd">@property</span> 
    <span class="k">def</span><span class="w"> </span><span class="nf">estimation_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the list of parameters to be estimated during calibration.</span>

<span class="sd">        This property combines the estimation parameters from both component camera models,</span>
<span class="sd">        prefixing them with &#39;m1_&#39; and &#39;m2_&#39; to distinguish between the two models.</span>

<span class="sd">        :return: A list of strings representing the parameters to be estimated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;m1_</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;m2_</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">]</span>
    
    <span class="nd">@estimation_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimation_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the list of parameters to be estimated during calibration.</span>

<span class="sd">        This method splits the provided list into two separate lists for each component camera model,</span>
<span class="sd">        removing the &#39;m1_&#39; and &#39;m2_&#39; prefixes.</span>
<span class="sd">        </span>
<span class="sd">        Anything that doesn&#39;t have a m1_ or m2_ prefix will be applied to both models</span>

<span class="sd">        :param val: A list of strings representing the parameters to be estimated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>
        <span class="n">common</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">val</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m1_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m2_&quot;</span><span class="p">))]</span>
        <span class="n">m1_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">val</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m1_&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">common</span>
        <span class="n">m2_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">val</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m2_&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">common</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">estimation_parameters</span> <span class="o">=</span> <span class="n">m1_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">estimation_parameters</span> <span class="o">=</span> <span class="n">m2_params</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span><span class="w"> </span><span class="nf">state_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the current state vector of the camera model.</span>

<span class="sd">        This property combines the state vectors from both component camera models.</span>

<span class="sd">        :return: A list of float numbers representing the current state of the camera model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">state_vector</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">state_vector</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_state_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of estimation parameters into state label names.</span>

<span class="sd">        This method interprets the list of estimation parameters (:attr:`estimation_parameters`) into human readable</span>
<span class="sd">        state labels for pretty printing calibration results and for knowing the order of the state vector.</span>
<span class="sd">        It combines the state labels from both component camera models, prefixing them with &#39;m1_&#39; and &#39;m2_&#39; respectively.</span>

<span class="sd">        :return: The list of state names corresponding to estimation parameters in order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;m1_</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">get_state_labels</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;m2_</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">get_state_labels</span><span class="p">()]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_split_logic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">method1</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">method2</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> 
                           <span class="n">output_leading_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">output_trailing_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span> 
                           <span class="n">frame</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;cf&#39;</span><span class="p">,</span> <span class="s1">&#39;if&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cf&#39;</span><span class="p">,</span> <span class="n">output_dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the split logic to determine which component model to use for a given set of points.</span>

<span class="sd">        This internal method is the core of the SplitCamera&#39;s functionality. It decides whether to use model1 or model2</span>
<span class="sd">        based on the defined split axis and threshold, either in the camera frame or image plane. It then applies the</span>
<span class="sd">        appropriate method (method1 or method2) to the points that fall within each model&#39;s domain.</span>

<span class="sd">        :param points: The input points to be processed, either in the camera frame or image plane</span>
<span class="sd">        :param method1: The method to apply for points that fall within model1&#39;s domain</span>
<span class="sd">        :param method2: The method to apply for points that fall within model2&#39;s domain</span>
<span class="sd">        :param args: Additional arguments to be passed to method1 and method2</span>
<span class="sd">        :param output_leading_shape: The expected leading shape of the output array</span>
<span class="sd">        :param output_trailing_shape: The expected trailing shape of the output array</span>
<span class="sd">        :param frame: Specifies whether the points are in the camera frame (&#39;cf&#39;) or image plane (&#39;if&#39;)</span>
<span class="sd">        :param output_dtype: The desired data type of the output array</span>
<span class="sd">        :return: An array containing the results of applying method1 or method2 to the appropriate points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;cf&quot;</span><span class="p">:</span>
            <span class="n">sa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_axis</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_threshold</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_axis</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_threshold</span>
            
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">m1_check</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">sa</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">st</span>
            <span class="n">m2_check</span> <span class="o">=</span> <span class="o">~</span><span class="n">m1_check</span>
            
            <span class="n">m1_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">m1_check</span><span class="p">]</span>
            <span class="n">m2_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">m2_check</span><span class="p">]</span>
            
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_leading_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="n">output_trailing_shape</span><span class="p">,</span> <span class="n">output_dtype</span><span class="p">)</span>
            
            <span class="n">leading_slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_leading_shape</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">m1_points</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="o">*</span><span class="n">leading_slices</span><span class="p">,</span> <span class="n">m1_check</span><span class="p">]</span> <span class="o">=</span> <span class="n">method1</span><span class="p">(</span><span class="n">m1_points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m2_points</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="o">*</span><span class="n">leading_slices</span><span class="p">,</span> <span class="n">m2_check</span><span class="p">]</span> <span class="o">=</span> <span class="n">method2</span><span class="p">(</span><span class="n">m2_points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">out</span>
        
        <span class="k">elif</span> <span class="n">points</span><span class="p">[</span><span class="n">sa</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">st</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">method1</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">method2</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    
<div class="viewcode-block" id="SplitCamera.project_onto_image">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.project_onto_image.html#giant.camera_models.split_camera.SplitCamera.project_onto_image">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_onto_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method transforms 3D points (or directions) expressed in the camera frame into the corresponding 2D image</span>
<span class="sd">        locations.</span>
<span class="sd">        </span>
<span class="sd">        The points input should be either 1 or 2 dimensional, with the first axis being length 3 (each point </span>
<span class="sd">        (direction) in the camera frame is specified as a column).</span>
<span class="sd">        </span>
<span class="sd">        The optional ``image`` key word argument specifies the index of the image you are projecting onto (this only </span>
<span class="sd">        applies if you have a separate misalignment for each image)</span>

<span class="sd">        The optional ``temperature`` key word argument specifies the temperature to use when projecting the points into</span>
<span class="sd">        the image. This only applies when your focal length has a temperature dependence</span>
<span class="sd">        </span>
<span class="sd">        :param points_in_camera_frame: a shape (3,) or shape (3, n) array of points to project</span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :param temperature: The temperature of the camera to use for the projection</span>
<span class="sd">        :return: A shape (2,) or shape (2, n) numpy array of image points (with units of pixels)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">points_in_camera_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SplitCamera.project_directions">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.project_directions.html#giant.camera_models.split_camera.SplitCamera.project_directions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directions_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method transforms 3D directions expressed in the camera frame into the corresponding 2D image</span>
<span class="sd">        directions.</span>

<span class="sd">        The direction input should be either 1 or 2 dimensional, with the first axis being length 3 (each direction</span>
<span class="sd">        in the camera frame is specified as a column).</span>

<span class="sd">        The optional ``image`` key word argument specifies the index of the image you are projecting onto (this only</span>
<span class="sd">        applies if you have a separate misalignment for each image)</span>

<span class="sd">        This method is different from method :meth:`project_onto_image` in that it only projects the direction component</span>
<span class="sd">        perpendicular to the optical axis of the camera (x, y axes of the camera frame) into a unit vector in the image</span>
<span class="sd">        plane. Therefore, you do not get a location in the image out of this, rather a unitless direction in the image.</span>

<span class="sd">        :param directions_in_camera_frame: a shape (3,) or shape (3, n) array of points to project</span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :return: A shape (2,) or shape (2, n) numpy array of image direction unit vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">directions_in_camera_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">project_directions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">project_directions</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SplitCamera.compute_jacobian">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.compute_jacobian.html#giant.camera_models.split_camera.SplitCamera.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_vectors_in_camera_frame</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]],</span> 
                         <span class="n">temperature</span><span class="p">:</span> <span class="n">F_SCALAR_OR_ARRAY</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian matrix :math:`\partial\mathbf{x}_P/\partial\mathbf{c}` where</span>
<span class="sd">        :math:`\mathbf{c}` is a vector of camera model parameters.</span>
<span class="sd">        </span>
<span class="sd">        The vector of camera model parameters contains things like the focal length, the pixel pitch, the distortion</span>
<span class="sd">        coefficients, and a misalignment vector. The ``unit_vectors_in_camera_frame`` should be a shape (m, 3, n) array</span>
<span class="sd">        of unit vectors expressed in the camera frame that you wish to calculate the Jacobian for where m is the number</span>
<span class="sd">        of images being calibrated. (These unit vectors should correspond to the pixel locations of the measurements</span>
<span class="sd">        when projected through the model).</span>
<span class="sd">        </span>
<span class="sd">        In general this method will not be used by the user and instead is used internally by the calibration estimators</span>
<span class="sd">        in :mod:`.calibration`.</span>
<span class="sd">        </span>
<span class="sd">        :param unit_vectors_in_camera_frame: A (m, 3, n) array of unit vectors expressed in the camera frame</span>
<span class="sd">        :param temperature: The temperature of the camera to use for computing the Jacobian matrix.</span>
<span class="sd">                            If temperature is an array it must be the same length as the first axis of the</span>
<span class="sd">                            ``unit_vectors_in_camera_frame`` input.</span>
<span class="sd">        :return: A (n*2, o) (where o is the length of :math:`\mathbf{c}`) array containing the Jacobian matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="n">model_1_vectors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_2_vectors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_1_checks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_2_checks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vectors</span> <span class="ow">in</span> <span class="n">unit_vectors_in_camera_frame</span><span class="p">:</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">m1_check</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_axis</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_threshold</span>
                <span class="n">model_1_checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m1_check</span><span class="p">)</span>
                <span class="n">m2_check</span> <span class="o">=</span> <span class="o">~</span><span class="n">m1_check</span>
                <span class="n">model_2_checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m2_check</span><span class="p">)</span>
                <span class="n">model_1_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">[:,</span> <span class="n">m1_check</span><span class="p">])</span>
                <span class="n">model_2_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">[:,</span> <span class="n">m2_check</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_1_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">([[],</span> <span class="p">[]])</span>
                <span class="n">model_2_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">([[],</span> <span class="p">[]])</span>
                <span class="n">model_1_checks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">model_2_checks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        
        <span class="n">m1_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">model_1_vectors</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        <span class="n">m2_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">model_2_vectors</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m1_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">m2_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m1_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m2_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="n">image_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m1_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m2_start</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">m1check</span><span class="p">,</span> <span class="n">m2check</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model_1_checks</span><span class="p">,</span> <span class="n">model_2_checks</span><span class="p">):</span>
            <span class="n">m1_obs_indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">m1check</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">m1_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m1_obs_indicies</span><span class="p">,</span> <span class="n">m1_obs_indicies</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">+</span><span class="n">image_start</span>
            
            <span class="n">m2_obs_indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">m2check</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">m2_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m2_obs_indicies</span><span class="p">,</span> <span class="n">m2_obs_indicies</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">+</span><span class="n">image_start</span>
            
            <span class="n">m1_count</span> <span class="o">=</span> <span class="n">m1check</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span>
            <span class="n">m2_count</span> <span class="o">=</span> <span class="n">m2check</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span>
            
            <span class="n">out</span><span class="p">[</span><span class="n">m1_indices</span><span class="p">,</span> <span class="p">:</span><span class="n">m1_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">m1_res</span><span class="p">[</span><span class="n">m1_start</span><span class="p">:</span><span class="n">m1_start</span><span class="o">+</span><span class="n">m1_count</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">m2_indices</span><span class="p">,</span> <span class="n">m1_res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">m2_res</span><span class="p">[</span><span class="n">m2_start</span><span class="p">:</span><span class="n">m2_start</span><span class="o">+</span><span class="n">m2_count</span><span class="p">]</span>
            
            <span class="n">m1_start</span> <span class="o">+=</span> <span class="n">m1_count</span>
            <span class="n">m2_start</span> <span class="o">+=</span> <span class="n">m2_count</span>
            
            <span class="n">image_start</span> <span class="o">+=</span> <span class="n">m1_count</span> <span class="o">+</span> <span class="n">m2_count</span>
            
        <span class="k">return</span> <span class="n">out</span></div>

    
<div class="viewcode-block" id="SplitCamera.compute_pixel_jacobian">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.compute_pixel_jacobian.html#giant.camera_models.split_camera.SplitCamera.compute_pixel_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pixel_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian matrix :math:`\partial\mathbf{x}_P/\partial\mathbf{x}_C` where</span>
<span class="sd">        :math:`\mathbf{x}_C` is a vector in the camera frame that projects to :math:`\mathbf{x}_P` which is the</span>
<span class="sd">        pixel location.</span>

<span class="sd">        This method is used in the :class:`.LimbScanning` process in order to predict the change in a projected pixel</span>
<span class="sd">        location with respect to a change in the projected vector. The ``vectors_in_camera_frame`` input should</span>
<span class="sd">        be a 3xn array of vectors which the Jacobian is to be computed for.</span>

<span class="sd">        :param vectors_in_camera_frame: The vectors to compute the Jacobian at</span>
<span class="sd">        :param image: The image number to compute the the Jacobian for</span>
<span class="sd">        :param temperature: The temperature of the camera at the time the image was taken</span>
<span class="sd">        :return: The Jacobian matrix as a nx2x3 array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">vectors_in_camera_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">compute_pixel_jacobian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">compute_pixel_jacobian</span><span class="p">,</span> 
                                       <span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">output_leading_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">output_trailing_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="SplitCamera.compute_unit_vector_jacobian">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.compute_unit_vector_jacobian.html#giant.camera_models.split_camera.SplitCamera.compute_unit_vector_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_unit_vector_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel_locations</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian matrix :math:`\partial\mathbf{x}_C/\partial\mathbf{x}_P` where</span>
<span class="sd">        :math:`\mathbf{x}_C` is a vector in the camera frame that projects to :math:`\mathbf{x}_P` which is the</span>
<span class="sd">        pixel location.</span>

<span class="sd">        This method is used in the :class:`.LimbScanning` process in order to predict the change in the unit vector that</span>
<span class="sd">        projects to a pixel location with respect to a change in the pixel location. The</span>
<span class="sd">        ``pixel_locations`` input should be a 2xn array of vectors which the Jacobian is to be computed for.</span>

<span class="sd">        :param pixel_locations: The pixel locations to compute the Jacobian at</span>
<span class="sd">        :param image: The image number to compute the the Jacobian for</span>
<span class="sd">        :param temperature: The temperature of the camera at the time the image was taken</span>
<span class="sd">        :return: The Jacobian matrix as a nx3x2 array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">pixel_locations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">compute_unit_vector_jacobian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">compute_unit_vector_jacobian</span><span class="p">,</span> 
                                       <span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">output_leading_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">output_trailing_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;if&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SplitCamera.apply_update">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.apply_update.html#giant.camera_models.split_camera.SplitCamera.apply_update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_vec</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes in a delta update to camera parameters (:math:`\Delta\mathbf{c}`) and applies the update</span>
<span class="sd">        to the current instance in place.</span>
<span class="sd">        </span>
<span class="sd">        In general the delta update is calculated in the estimators in the :mod:`.calibration` subpackage and this</span>
<span class="sd">        method is not used by the user.</span>
<span class="sd">        </span>
<span class="sd">        The update vector is an array like object where each element corresponds to a specific camera parameter,</span>
<span class="sd">        corresponding to the element represented by each column coming from the :meth:`~CameraModel.compute_jacobian`</span>
<span class="sd">        method. For the SplitCamera, the update vector is split between the two component models and applied to each.</span>

<span class="sd">        :param update_vec: delta updates to the model parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model_1_elems</span> <span class="o">=</span> <span class="n">update_vec</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">state_vector_length</span><span class="p">]</span>
        <span class="n">model_2_elems</span> <span class="o">=</span> <span class="n">update_vec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">state_vector_length</span><span class="p">:]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">apply_update</span><span class="p">(</span><span class="n">model_1_elems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">apply_update</span><span class="p">(</span><span class="n">model_2_elems</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SplitCamera.pixels_to_unit">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.pixels_to_unit.html#giant.camera_models.split_camera.SplitCamera.pixels_to_unit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pixels_to_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert pixel image locations to unit vectors expressed in the camera frame.</span>

<span class="sd">        This method delegates the conversion to either model1 or model2 based on the defined split logic.</span>
<span class="sd">        The pixel locations should be expressed as a shape (2,) or (2, n) array. They are converted</span>
<span class="sd">        to unit vectors by first going through the inverse distortion model (see :meth:`undistort_pixels`) and then </span>
<span class="sd">        being converted to unit vectors in the camera frame according to the definitions of the current model (also </span>
<span class="sd">        including any misalignment terms).</span>

<span class="sd">        :param pixels: The image points to be converted to unit vectors in the camera frame as a shape (2,) or (2, n) </span>
<span class="sd">                       array</span>
<span class="sd">        :param temperature: The temperature to use for the undistortion</span>
<span class="sd">        :param image: The image index that the pixels belong to (only important if there are multiple misalignments)</span>
<span class="sd">        :return: The unit vectors corresponding to the image locations expressed in the camera frame as a shape (3,) or</span>
<span class="sd">                 (3, n) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">,</span> 
                                       <span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">output_leading_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">output_trailing_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;if&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SplitCamera.undistort_pixels">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.undistort_pixels.html#giant.camera_models.split_camera.SplitCamera.undistort_pixels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">undistort_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute undistorted pixel locations (gnomic/pinhole locations) for given distorted pixel locations.</span>

<span class="sd">        This method delegates the undistortion to either model1 or model2 based on the defined split logic.</span>
<span class="sd">        The ``pixels`` input should be specified as a shape (2,) or (2, n) array of image locations with units of </span>
<span class="sd">        pixels. The return will be an array of the same shape as ``pixels`` with units of pixels but with distortion</span>
<span class="sd">        removed.</span>

<span class="sd">        :param pixels: The image points to be converted to gnomic (pinhole) locations as a shape (2,) or (2, n) array</span>
<span class="sd">        :param temperature: The temperature to use for the undistortion</span>
<span class="sd">        :return: The undistorted (gnomic) locations corresponding to the distorted pixel locations as an array of</span>
<span class="sd">                 the same shape as ``pixels``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">undistort_pixels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">undistort_pixels</span><span class="p">,</span> 
                                       <span class="n">temperature</span><span class="p">,</span> <span class="n">output_leading_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">output_trailing_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;if&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SplitCamera.distort_pixels">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.distort_pixels.html#giant.camera_models.split_camera.SplitCamera.distort_pixels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distort_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply distortion to gnomic pixel locations.</span>

<span class="sd">        This method delegates the distortion application to either model1 or model2 based on the defined split logic.</span>
<span class="sd">        It takes gnomic pixel locations in units of pixels and applies the appropriate distortion to them.</span>
<span class="sd">        This method is used in the :meth:`distortion_map` method to generate the distortion values for each pixel.</span>

<span class="sd">        :param pixels: The pinhole location pixel locations the distortion is to be applied to as a shape (2,) or (2, n) array</span>
<span class="sd">        :param temperature: The temperature to use for the distortion</span>
<span class="sd">        :return: The distorted pixel locations in units of pixels as an array of the same shape as ``pixels``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">distort_pixels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">distort_pixels</span><span class="p">,</span> 
                                       <span class="n">temperature</span><span class="p">,</span> <span class="n">output_leading_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">output_trailing_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;if&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SplitCamera.overwrite">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.overwrite.html#giant.camera_models.split_camera.SplitCamera.overwrite">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">overwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s1">&#39;CameraModel&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace self with the properties of ``model`` in place.</span>

<span class="sd">        This method overwrites the properties of both component models (model1 and model2) with the corresponding</span>
<span class="sd">        properties from the input model. It is primarily used in the calibration classes to maintain the link between</span>
<span class="sd">        the internal and external camera models.</span>

<span class="sd">        :param model: The SplitCamera model to overwrite self with</span>
<span class="sd">        :raises ValueError: When ``model`` is not an instance of SplitCamera</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span> <span class="s2">&quot;Must be a split camera model&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_model1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_model2</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SplitCamera.to_elem">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.to_elem.html#giant.camera_models.split_camera.SplitCamera.to_elem">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store this camera model in an :class:`lxml.etree.SubElement` object for saving in a GIANT xml file.</span>

<span class="sd">        This method extends the base :meth:`CameraModel.to_elem` method to include both component models (model1 and</span>
<span class="sd">        model2) in the XML structure. It creates separate subelements for each component model and stores their</span>
<span class="sd">        attributes using their respective :meth:`to_elem` methods.</span>

<span class="sd">        :param elem: The :class:`lxml.etree.SubElement` class to store this camera model in</span>
<span class="sd">        :param kwargs: Additional keyword arguments to pass to the component models&#39; :meth:`to_elem` methods</span>
<span class="sd">        :return: The :class:`lxml.etree.SubElement` for this model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">elem</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">model1_elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;model1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model1_elem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model1_elem</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="s2">&quot;model1&quot;</span><span class="p">,</span> <span class="n">attrib</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                                                                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">to_elem</span><span class="p">(</span><span class="n">model1_elem</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">model2_elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;model2&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model2_elem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model2_elem</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="s2">&quot;model2&quot;</span><span class="p">,</span> <span class="n">attrib</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                                                                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">to_elem</span><span class="p">(</span><span class="n">model2_elem</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">elem</span></div>

    
<div class="viewcode-block" id="SplitCamera.from_elem">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.from_elem.html#giant.camera_models.split_camera.SplitCamera.from_elem">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_elem</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SplitCamera&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new instance of SplitCamera from an :class:`etree._Element` object.</span>

<span class="sd">        This class method extends the base :meth:`CameraModel.from_elem` method to handle the reconstruction of both</span>
<span class="sd">        component models (model1 and model2) from the XML structure. It retrieves the necessary information for each</span>
<span class="sd">        component model, imports the appropriate classes, and initializes them using their respective :meth:`from_elem`</span>
<span class="sd">        methods.</span>

<span class="sd">        :param elem: The element containing the attribute information for the instance to be created</span>
<span class="sd">        :return: An initialized instance of SplitCamera with both component models properly set</span>
<span class="sd">        :raises KeyError: If the required nodes for model1 or model2 are missing in the XML element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">inst</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">SplitCamera</span><span class="p">,</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
        
        <span class="c1"># find and update model1</span>
        <span class="n">model1_node</span><span class="p">:</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;model1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model1_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Missing node for model1&quot;</span><span class="p">)</span>
        
        <span class="n">m1mod</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">model1_node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">))</span>

        <span class="n">m1cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">CameraModel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m1mod</span><span class="p">,</span> <span class="n">model1_node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">))</span>
        
        <span class="n">model1</span> <span class="o">=</span> <span class="n">m1cls</span><span class="o">.</span><span class="n">from_elem</span><span class="p">(</span><span class="n">model1_node</span><span class="p">)</span>
            
        <span class="c1"># find and update model2</span>
        <span class="n">model2_node</span><span class="p">:</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;model2&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model2_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Missing node for model2&quot;</span><span class="p">)</span>
        
        <span class="n">m2mod</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">model2_node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">))</span>

        <span class="n">m2cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m2mod</span><span class="p">,</span> <span class="n">model2_node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">))</span>
        
        <span class="n">model2</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">CameraModel</span><span class="p">]</span> <span class="o">=</span> <span class="n">m2cls</span><span class="o">.</span><span class="n">from_elem</span><span class="p">(</span><span class="n">model2_node</span><span class="p">)</span>
        
        <span class="n">inst</span><span class="o">.</span><span class="n">_model1</span> <span class="o">=</span> <span class="n">model1</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_model2</span> <span class="o">=</span> <span class="n">model2</span>
        
        <span class="k">return</span> <span class="n">inst</span></div>

    
<div class="viewcode-block" id="SplitCamera.check_in_fov">
<a class="viewcode-back" href="../../../split_camera/giant.camera_models.split_camera.SplitCamera.check_in_fov.html#giant.camera_models.split_camera.SplitCamera.check_in_fov">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_in_fov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if any points in the array are within the field of view of the camera.</span>
<span class="sd">        </span>
<span class="sd">        This method delegates the field of view check to either model1 or model2 based on the defined split logic.</span>
<span class="sd">        It checks whether the given vertices are within the field of view of the appropriate camera model.</span>


<span class="sd">        :param vectors: Vectors to check if they are in the field of view of the camera expressed as a shape (3, n) array in the camera frame.  </span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :param temperature: The temperature of the camera to use for the projection</span>
<span class="sd">        :return: A boolean array the same length as the number of columns of vectors. False by default, True if the point is in the FOV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_split_logic</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model1</span><span class="o">.</span><span class="n">check_in_fov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model2</span><span class="o">.</span><span class="n">check_in_fov</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">output_leading_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">output_trailing_shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">output_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span></div>

            
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation of the SplitCamera object.</span>

<span class="sd">        This method provides a human-readable description of the SplitCamera, including string representations</span>
<span class="sd">        of both component models (model1 and model2).</span>

<span class="sd">        :return: A string describing the SplitCamera and its component models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;SplitCamera:</span><span class="se">\n\n</span><span class="s1">Model 1:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model1</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="si">}</span><span class="se">\n\n</span><span class="s1">Model 2:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model2</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation of the SplitCamera object that can be used to recreate the object.</span>

<span class="sd">        This method returns a string that, when passed to eval(), would create a new instance of the SplitCamera</span>
<span class="sd">        with the same parameters as the current instance. It includes representations of both component models</span>
<span class="sd">        and all the split parameters.</span>

<span class="sd">        :return: A string representation of the SplitCamera that can be used to recreate the object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SplitCamera(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model1</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model2</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="si">}</span><span class="s1">, &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;camera_frame_split_axis=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_axis</span><span class="si">}</span><span class="s1">, camera_frame_split_threshold=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_camera_frame_split_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;image_plane_split_axis=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_axis</span><span class="si">}</span><span class="s1">, image_plane_split_threshold=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_plane_split_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;field_of_view=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">field_of_view</span><span class="si">}</span><span class="s1">, n_rows=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="si">}</span><span class="s1">, n_cols=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="si">}</span><span class="s1">, use_a_prior=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">use_a_priori</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span></div>

    
        
            
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>