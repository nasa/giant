<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.camera_models.pinhole_model &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.camera_models.pinhole_model</h1><div class="highlight"><pre>
<span></span>


<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a subclass of :class:`.CameraModel` that implements the distortion free Pinhole camera model.</span>

<span class="sd">Theory</span>
<span class="sd">______</span>

<span class="sd">Recall the experiment that you can use to observe a solar eclipse without damaging your eyes.  You take a piece of</span>
<span class="sd">paper, place a small hole in it, and hold it some distance above another sheet of paper.  The sun is then projected onto</span>
<span class="sd">the lower piece of paper showing how much is currently obscured by the moon.  The sun on the paper appears much smaller</span>
<span class="sd">than the sun in the world because the distance between the two sheets of paper is much smaller than the distance</span>
<span class="sd">between the top sheet of paper and the sun.  This is an example of a Pinhole camera, which assumes similar triangles to</span>
<span class="sd">relate points in the 3D world.  This is demonstrated in the following diagram.</span>

<span class="sd">.. figure:: images/pinholecamera.png</span>
<span class="sd">   :alt: The pinhole camera model</span>
<span class="sd">   :target: _downloads/cameraModels.pdf</span>

<span class="sd">   The pinhole camera model describes a gnomic projection from 3 space to 2 space.</span>

<span class="sd">In the above figure, point :math:`\mathbf{x}_B` is rotated and translated to be expressed in the camera frame as point</span>
<span class="sd">:math:`\mathbf{x}_C` and this is then projected through the pinhole camera model to point :math:`\mathbf{x}_P` in the</span>
<span class="sd">image.  Mathematically this is given as</span>

<span class="sd">.. math::</span>
<span class="sd">    :nowrap:</span>

<span class="sd">    \begin{gather}</span>
<span class="sd">    &amp;\mathbf{x}_I = (1+a_1T+a_2T^2+a_3T^3)\frac{f}{z_C}\left[\begin{array}{c}x_C\\y_C\end{array}\right]\\</span>
<span class="sd">    &amp;\mathbf{x}_P = \left[\begin{array}{ccc} k_x &amp; 0 &amp; p_x \\ 0 &amp; k_y &amp; p_y\end{array}\right]</span>
<span class="sd">    \left[\begin{array}{c} \mathbf{x}_I \\ 1 \end{array}\right]</span>
<span class="sd">    \end{gather}</span>

<span class="sd">where :math:`f` is the focal length of the camera (the distance between the 2 sheets of paper in our example),</span>
<span class="sd">:math:`a_{1-3}` are polynomial coefficients for a temperature dependence on focal length (the camera dimensions may</span>
<span class="sd">change due to thermal expansion), :math:`T` is the temperature the projection is occurring at, :math:`k_x` and</span>
<span class="sd">:math:`k_y` are one over the pixel pitch values in units of pixels/distance in the :math:`x` and :math:`y` directions</span>
<span class="sd">respectively (cameras are not continuous but have discrete receptors for light to enter), and :math:`p_x` and</span>
<span class="sd">:math:`p_y` are the location of the principal point of the camera in the image expressed in units of pixels (typically</span>
<span class="sd">at the center of the pixel array).</span>

<span class="sd">Speeding up the camera model</span>
<span class="sd">----------------------------</span>

<span class="sd">One of the most common functions of the camera model is to relate pixels in a camera to unit vectors in the 3D camera</span>
<span class="sd">frame.  This is done extensively throughout GIANT, particularly when ray tracing.  Unfortunately, this transformation is</span>
<span class="sd">iterative (there isn&#39;t an analytic solution), which can make things a little slow, particularly when you need to do the</span>
<span class="sd">transformation for many pixel locations.</span>

<span class="sd">In order to speed up this transformation we can precompute it for each pixel in an detector and for a range of</span>
<span class="sd">temperatures specified by a user and then use bilinear interpolation to compute the location of future pixel/temperature</span>
<span class="sd">combinations we need.  While this is an approximation, it saves significant time rather than going through the full</span>
<span class="sd">iterative transformation, and based on testing, it is accurate to a few thousandths of a pixel, which is more than</span>
<span class="sd">sufficient for nearly every use case.  The :class:`.PinholeModel` and its subclasses make precomputing the</span>
<span class="sd">transformation, and using the precomputed transformation, as easy as calling :meth:`~PinholeModel.prepare_interp`</span>
<span class="sd">once.  Future calls to any method that then needs the transformation from pixels to gnomic locations (on the way to</span>
<span class="sd">unit vectors) will then use the precomputed transformation unless specifically requested otherwise.  In addition,</span>
<span class="sd">once the :meth:`~PinholeModel.prepare_interp` method has been called, if the resulting camera object is then saved to</span>
<span class="sd">a file either using the :mod:`.camera_model`</span>
<span class="sd">:func:`~giant.camera_models.camera_model.save`/:func:`~giant.camera_models.camera_model.load` functions  or another</span>
<span class="sd">serialization method like pickle/dill, then the precomputed transformation will also be saved and loaded so that it</span>
<span class="sd">truly only needs to be computed once.</span>

<span class="sd">Since precomputing the transformation can take a somewhat long time, it is not always smart to do so.  Typically if you</span>
<span class="sd">have a camera model that you will be using again and again (as is typical in most operations and analysis cases) then</span>
<span class="sd">you *should* precompute the transformation and save the resulting camera object to a file that is then used for future</span>
<span class="sd">work.  This is usually best done at the end of a calibration script (for a real camera) or in a stand-alone script that</span>
<span class="sd">defines the camera, precomputes the transformation, and then saves it off for a synthetic camera for analysis.  If you</span>
<span class="sd">are just doing a quick analysis and don&#39;t need the camera model repeatedly or for any heavy duty ray tracing then it is</span>
<span class="sd">recommended that you *not precompute* the transformation.</span>

<span class="sd">Whether you precompute the transformation or not, the use of the camera model should appear unchanged beyond computation</span>
<span class="sd">time.</span>

<span class="sd">Use</span>
<span class="sd">___</span>

<span class="sd">This is a concrete implementation of a :class:`.CameraModel`, therefore to use this class you simply need to initialize</span>
<span class="sd">it with the proper values.  Typically these values come from either the physical dimensions of the camera, or from</span>
<span class="sd">a camera calibration routine performed to refine the values using observed data (see the :mod:`.calibration` sub-package</span>
<span class="sd">for details).  For instance, say we have a camera which has an effective focal length of 10 mm, a pix pitch of 2.2 um,</span>
<span class="sd">and a detector size of 1024x1024.  We could then create a model for this camera as</span>

<span class="sd">    &gt;&gt;&gt; from giant.camera_models import PinholeModel</span>
<span class="sd">    &gt;&gt;&gt; model = PinholeModel(focal_length=10, kx=1/2.2e-3, ky=1/2.2e-3,</span>
<span class="sd">    ...                      n_rows=1024, n_cols=1024, px=(1024-1)/2, py=(1024-1)/2)</span>

<span class="sd">Note that we did not set the field of view, but it is automatically computed for us based off of the prescribed camera</span>
<span class="sd">model.</span>

<span class="sd">    &gt;&gt;&gt; model.field_of_view</span>
<span class="sd">    9.050999753955251</span>

<span class="sd">In addition, we can now use our model to project points</span>

<span class="sd">    &gt;&gt;&gt; model.project_onto_image([0, 0, 1])</span>
<span class="sd">    array([511.5, 511.5])</span>

<span class="sd">or to determine the unit vector through a pixel</span>

<span class="sd">    &gt;&gt;&gt; model.pixels_to_unit([[0, 500], [0, 100]])</span>
<span class="sd">    array([[-0.11113154, -0.00251969],</span>
<span class="sd">           [-0.11113154, -0.090161  ],</span>
<span class="sd">           [ 0.98757256,  0.99592402]])</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">cast</span>

<span class="c1"># from warnings import warn</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">RegularGridInterpolator</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>

<span class="c1"># the risk of XML is addressed with warnings in the save/load documentation</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lxml.etree</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">etree</span>  <span class="c1"># nosec</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera_models.camera_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">CameraModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="kn">import</span> <span class="n">rotvec_to_rotmat</span><span class="p">,</span> <span class="n">skew</span><span class="p">,</span> <span class="n">Rotation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">SCALAR_OR_ARRAY</span><span class="p">,</span> <span class="n">NONENUM</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">F_SCALAR_OR_ARRAY</span><span class="p">,</span> <span class="n">F_ARRAY_LIKE</span>


<span class="n">MISALIGNMENT_TYPE</span> <span class="o">=</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
<span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">A type alias for the misalignment input to the PinholeModel class</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PinholeModel">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.html#giant.camera_models.pinhole_model.PinholeModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PinholeModel</span><span class="p">(</span><span class="n">CameraModel</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class provides an implementation of the pinhole camera model for projecting 3d points onto images.</span>

<span class="sd">    The :class:`PinholeModel` class is a subclass of :class:`CameraModel`.  This means that it includes implementations</span>
<span class="sd">    for all of the abstract methods defined in the :class:`CameraModel` class.  This also means that it can be used</span>
<span class="sd">    throughout GIANT as the primary camera model, including within the :mod:`calibration` subpackage.  If this class is</span>
<span class="sd">    going to be used with the :mod:`calibration` subpackage, the user can set which parameters are estimated and which</span>
<span class="sd">    are held fixed by using the ``estimation_parameters`` keyword argument when creating an instance of the class or by</span>
<span class="sd">    adjusting the :attr:`estimation_parameters` instance variable on an instance of the class.  The</span>
<span class="sd">    ``estimation_parameters`` input/attribute is a string or list of strings specifying which parameters to estimate.</span>
<span class="sd">    This means that :attr:`estimation_parameters` could be something like ``&#39;basic&#39;`` which would indicate to estimate</span>
<span class="sd">    just the usual parameters, or something like ``[&#39;focal_length&#39;, &#39;ky&#39;, &#39;px&#39;, &#39;py&#39;]`` to estimate just the terms</span>
<span class="sd">    included in the list.</span>

<span class="sd">    In addition to the standard set of methods for a :class:`CameraModel` subclass, the :class:`PinholeModel` class</span>
<span class="sd">    provides the following additional methods which may or may not be useful to some people:</span>

<span class="sd">    =================================  =================================================================================</span>
<span class="sd">    Method                             Use</span>
<span class="sd">    =================================  =================================================================================</span>
<span class="sd">    :meth:`get_projections`            computes the pinhole, image frame, and pixel locations of a 3D point</span>
<span class="sd">    :meth:`pixels_to_gnomic`           removes distortion from a point to get the corresponding pinhole location in</span>
<span class="sd">                                       units of distance</span>
<span class="sd">    =================================  =================================================================================</span>

<span class="sd">    The Pinhole model also provides the following additional properties for easy getting/setting:</span>

<span class="sd">    ============================  ======================================================================================</span>
<span class="sd">    Property                      Description</span>
<span class="sd">    ============================  ======================================================================================</span>
<span class="sd">    :attr:`field_of_view`         the diagonal field of view of the camera in units of degrees</span>
<span class="sd">    :attr:`focal_length`          the diagonal focal length of the camera in units of distance</span>
<span class="sd">    :attr:`kx`                    :math:`k_x`, the inverse of the pixel pitch in the x direction in units of</span>
<span class="sd">                                  pixels/distance</span>
<span class="sd">    :attr:`ky`                    :math:`k_y`, the inverse of the pixel pitch in the y direction in units of</span>
<span class="sd">                                  pixels/distance</span>
<span class="sd">    :attr:`px`                    :math:`p_{x}`, the x axis pixel location of the principal point of the camera in units</span>
<span class="sd">                                  of pixels</span>
<span class="sd">    :attr:`py`                    :math:`p_{y}`, the y axis pixel location of the principal point of the camera in units</span>
<span class="sd">                                  of pixels</span>
<span class="sd">    :attr:`a1`                    :math:`a_1`, the linear coefficient for focal length dependent focal length</span>
<span class="sd">    :attr:`a2`                    :math:`a_2`, the quadratic coefficient for focal length dependent focal length</span>
<span class="sd">    :attr:`a3`                    :math:`a_3`, the cubic coefficient for focal length dependent focal length</span>
<span class="sd">    :attr:`intrinsic_matrix_inv`  The inverse of the intrinsic matrix</span>
<span class="sd">    ============================  ======================================================================================</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intrinsic_matrix</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">focal_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
                 <span class="n">field_of_view</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_a_priori</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">misalignment</span><span class="p">:</span> <span class="n">MISALIGNMENT_TYPE</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">estimation_parameters</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;basic&#39;</span><span class="p">,</span>
                 <span class="n">kx</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ky</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">px</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">py</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">n_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temperature_coefficients</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">a1</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">a2</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">a3</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param intrinsic_matrix: the intrinsic matrix for the camera as a numpy shape (2, 3) array.  Note that this is</span>
<span class="sd">                                 overwritten if ``kx``, ``ky``, ``px``, ``py`` are also specified.</span>
<span class="sd">        :param focal_length: The focal length of the camera in units of distance.</span>
<span class="sd">        :param field_of_view: The field of view of the camera in units of degrees.</span>
<span class="sd">        :param use_a_priori: A flag to indicate whether to include the *a priori* state vector in the Jacobian matrix</span>
<span class="sd">                             when performing a calibration</span>
<span class="sd">        :param misalignment: either a numpy array of shape (3,) or a list of numpy arrays of shape(3,) with each array</span>
<span class="sd">                             corresponding to a single image (the list of numpy arrays is only valid when estimating</span>
<span class="sd">                             multiple misalignments)</span>
<span class="sd">        :param estimation_parameters: A string or list of strings specifying which model parameters to include in the</span>
<span class="sd">                                      calibration</span>
<span class="sd">        :param kx: The inverse of the pixel pitch along the x axis in units of pixel/distance</span>
<span class="sd">        :param ky: The inverse of the pixel pitch along the y axis in units of pixel/distance</span>
<span class="sd">        :param px: the x component of the pixel location of the principal point in the image in units of pixels</span>
<span class="sd">        :param py: the y component of the pixel location of the principal point in the image in units of pixels</span>
<span class="sd">        :param temperature_coefficients: The temperature polynomial coefficients as a length 3 Sequence</span>
<span class="sd">        :param a1: the linear coefficient of the focal length temperature dependence</span>
<span class="sd">        :param a2: the quadratic coefficient of the focal length temperature dependence</span>
<span class="sd">        :param a3: the cubic coefficient of the focal length temperature dependence</span>
<span class="sd">        :param n_rows: the number of rows of the active image array</span>
<span class="sd">        :param n_cols: the number of columns in the active image array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;focal_length&#39;</span><span class="p">,</span> <span class="s1">&#39;kx&#39;</span><span class="p">,</span> <span class="s1">&#39;ky&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;px&#39;</span><span class="p">,</span> <span class="s1">&#39;py&#39;</span><span class="p">,</span> <span class="s1">&#39;a1&#39;</span><span class="p">,</span> <span class="s1">&#39;a2&#39;</span><span class="p">,</span> <span class="s1">&#39;a3&#39;</span><span class="p">,</span> <span class="s1">&#39;misalignment&#39;</span><span class="p">]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of state labels that correspond to the attributes of this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># store the element dict for indices into the state vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;basic&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="s1">&#39;intrinsic&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="s1">&#39;basic intrinsic&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="s1">&#39;temperature dependence&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
            <span class="s1">&#39;focal_length&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;kx&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;ky&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s1">&#39;px&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="s1">&#39;py&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="s1">&#39;a1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span>
            <span class="s1">&#39;a2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span>
            <span class="s1">&#39;a3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span>
            <span class="s1">&#39;single misalignment&#39;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="s1">&#39;multiple misalignments&#39;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># set the focal length property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_focal_length</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">=</span> <span class="n">focal_length</span>

        <span class="c1"># set the intrinsic matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The 2x3 intrinsic matrix contains the conversion from unitless gnomic locations to a location in an image with </span>
<span class="sd">        units of pixels.</span>
<span class="sd">        </span>
<span class="sd">        It is defined as </span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{K} = \left[\begin{array}{ccc} k_x &amp; 0 &amp; p_x \\</span>
<span class="sd">            0 &amp; k_y &amp; p_y \end{array}\right] </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">intrinsic_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">intrinsic_matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kx</span> <span class="o">=</span> <span class="n">kx</span>
        <span class="k">if</span> <span class="n">ky</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ky</span> <span class="o">=</span> <span class="n">ky</span>
        <span class="k">if</span> <span class="n">px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">px</span> <span class="o">=</span> <span class="n">px</span>
        <span class="k">if</span> <span class="n">py</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">py</span> <span class="o">=</span> <span class="n">py</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The coefficients for the polynomial specifying the change in the focal length as a function of temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the temperature dependence</span>
        <span class="k">if</span> <span class="n">temperature_coefficients</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span> <span class="o">=</span> <span class="n">temperature_coefficients</span>

        <span class="k">if</span> <span class="n">a1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>

        <span class="k">if</span> <span class="n">a2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>

        <span class="k">if</span> <span class="n">a3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a3</span> <span class="o">=</span> <span class="n">a3</span>

        <span class="c1"># set the misalignment attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contains either a single rotation vector representing the misalignment between the specified camera frame and</span>
<span class="sd">        the actual camera frame, or a list of rotation vectors representing the misalignments between the specified </span>
<span class="sd">        camera frame and the actual camera frame for each image.</span>
<span class="sd">        </span>
<span class="sd">        Typically you should not interface with this attribute directly and allow other GIANT objects to handle it, </span>
<span class="sd">        because it can get complicated to ensure it is in-sync with the number of images under consideration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">misalignment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">misalignment</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">misalignment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">misalignment</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">misalignment</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">misalignment</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="n">misalignment</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="n">misalignment</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># set a flag for where to use multiple misalignments or not (set by estimation_parameters property)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This boolean value is used to determine whether multiple misalignments are being estimated/used per image.</span>
<span class="sd">        </span>
<span class="sd">        If set to ``True`` then one misalignment is estimated for each image and used for each image when projecting</span>
<span class="sd">        through the camera model.  When set to ``False`` then a single misalignment is estimated for all images and</span>
<span class="sd">        used for all images when projecting through the camera model.  Typically the user shouldn&#39;t be setting this </span>
<span class="sd">        attribute directly as it is automatically handled when setting the :attr:`estimation_parameters` attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set the estimation parameters attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_estimation_parameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span> <span class="o">=</span> <span class="n">estimation_parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_misalignment</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An instance of SciPy&#39;s RegularGridInterpolator for converting pixels to gnomic coordinates.</span>

<span class="sd">        This is generated by a call to :meth:`prepare_interp`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call the super init</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_rows</span><span class="o">=</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="n">n_cols</span><span class="p">,</span>
                         <span class="n">use_a_priori</span><span class="o">=</span><span class="n">use_a_priori</span><span class="p">,</span> <span class="n">field_of_view</span><span class="o">=</span><span class="n">field_of_view</span><span class="p">)</span>

        <span class="c1"># store the important attributes for use in the proper functions</span>
        <span class="c1"># temporarily duplicate the docstring so that sphinx can pick it up</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">important_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">important_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;kx&#39;</span><span class="p">,</span> <span class="s1">&#39;ky&#39;</span><span class="p">,</span> <span class="s1">&#39;px&#39;</span><span class="p">,</span> <span class="s1">&#39;py&#39;</span><span class="p">,</span> <span class="s1">&#39;focal_length&#39;</span><span class="p">,</span> <span class="s1">&#39;misalignment&#39;</span><span class="p">,</span>
                                                                 <span class="s1">&#39;estimate_multiple_misalignments&#39;</span><span class="p">,</span>
                                                                 <span class="s1">&#39;estimation_parameters&#39;</span><span class="p">,</span>
                                                                 <span class="s1">&#39;a1&#39;</span><span class="p">,</span> <span class="s1">&#39;a2&#39;</span><span class="p">,</span> <span class="s1">&#39;a3&#39;</span><span class="p">,</span> <span class="s1">&#39;_interp&#39;</span><span class="p">]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list specifying the important attributes the must be saved/loaded for this camera model to be completely </span>
<span class="sd">        reconstructed. </span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;PinholeModel(kx=</span><span class="si">{kx}</span><span class="s2">, ky=</span><span class="si">{ky}</span><span class="s2">, px=</span><span class="si">{px}</span><span class="s2">, py=</span><span class="si">{py}</span><span class="s2">, focal_length=</span><span class="si">{f}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="s2">&quot;             a1=</span><span class="si">{a1}</span><span class="s2">, a2=</span><span class="si">{a2}</span><span class="s2">, a3=</span><span class="si">{a3}</span><span class="s2">, n_rows=</span><span class="si">{n_rows}</span><span class="s2">, n_cols=</span><span class="si">{n_cols}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="s2">&quot;             field_of_view=</span><span class="si">{fov}</span><span class="s2">, misalignment=</span><span class="si">{mis!r}</span><span class="s2">, </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="s2">&quot;             estimation_parameters=</span><span class="si">{ep!r}</span><span class="s2">, use_a_priori=</span><span class="si">{ap}</span><span class="s2">)</span><span class="se">\n\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">kx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ky</span><span class="p">,</span> <span class="n">px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">py</span><span class="p">,</span>
            <span class="n">fov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">,</span>
            <span class="n">mis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">,</span> <span class="n">ep</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_a_priori</span><span class="p">,</span>
            <span class="n">a1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a3</span><span class="p">,</span> <span class="n">n_rows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">template</span> <span class="o">=</span> <span class="sa">u</span><span class="s2">&quot;Pinhole Camera Model:</span><span class="se">\n\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot; __  __     __       __                              </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;|   x  |   |  f*Xc/Zc  |                   2      3  </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;|      | = |           | * (1 + a1*T + a2*T + a3*T ) </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;|   y  |   |  f*Yc/Zc  |                             </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot; --  --     --       --                              </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot; __ __     __          __  __ __  </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;|  u  | _ |  kx  0   px  ||  x  | </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;|  v  | - |  0   ky  py  ||  y  | </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot; -- --     --          -- |  1  | </span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;                           -- --  </span><span class="se">\n\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;—————————————————————————————————————————</span><span class="se">\n\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;camera parameters:</span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;    f=</span><span class="si">{4}</span><span class="s2">, kx=</span><span class="si">{0}</span><span class="s2">, ky=</span><span class="si">{1}</span><span class="s2">, px=</span><span class="si">{2}</span><span class="s2">, py=</span><span class="si">{3}</span><span class="se">\n\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;temperature coefficients:</span><span class="se">\n</span><span class="s2">&quot;</span> \
                   <span class="sa">u</span><span class="s2">&quot;    a1=</span><span class="si">{5}</span><span class="s2">, a2=</span><span class="si">{6}</span><span class="s2">, a3=</span><span class="si">{7}</span><span class="se">\n\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ky</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">py</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">a1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a3</span><span class="p">)</span>

    <span class="nd">@CameraModel</span><span class="o">.</span><span class="n">state_vector</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the fully realized state vector according to :attr:`estimation_parameters` as a length l list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state_vector</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_state_labels</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;misalignment&#39;</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">state_vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;something went wrong if this fails&quot;</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">:</span>
                        <span class="n">state_vector</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">state_vector</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state_vector</span>
    
<div class="viewcode-block" id="PinholeModel.get_state_labels">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.get_state_labels.html#giant.camera_models.pinhole_model.PinholeModel.get_state_labels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_state_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of estimation parameters into state label names.</span>

<span class="sd">        This method interprets the list of estimation parameters (:attr:`estimation_parameters) into state labels for</span>
<span class="sd">        pretty printing calibration results.  In general this returns a list of attributes which can be retrieved from</span>
<span class="sd">        the camera using ``getattr`` with the exception of misalignment which must be handled separately.</span>

<span class="sd">        :return: The list of state names corresponding to estimation parameters in order</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">olist</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;misalignment&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="n">param</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">param</span> <span class="o">==</span> <span class="s2">&quot;basic&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_labels</span><span class="p">):</span>
                        <span class="c1"># this is a misalignment location we should ignore for now</span>
                        <span class="k">continue</span>
                    <span class="n">olist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_labels</span><span class="p">[</span><span class="n">loc</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">olist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">olist</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimation_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of strings containing the parameters to estimate when performing calibration with this model.</span>

<span class="sd">        This list is used in the methods :meth:`compute_jacobian` and :meth:`apply_update` to determine which parameters</span>
<span class="sd">        are being estimated/updated. From the :meth:`compute_jacobian` method, only columns of the Jacobian matrix</span>
<span class="sd">        corresponding to the parameters in this list are returned.  In the :meth:`apply_update` method, the update</span>
<span class="sd">        vector elements are assumed to correspond to the order expressed in this list.</span>

<span class="sd">        Valid values for the elements of this list are shown in the following table.  Generally, they correspond to</span>
<span class="sd">        attributes of this class, with a few convenient aliases that point to a collection of attributes.</span>

<span class="sd">        .. _pinhole-estimation-table:</span>

<span class="sd">        ============================  ==================================================================================</span>
<span class="sd">        Value                         Description</span>
<span class="sd">        ============================  ==================================================================================</span>
<span class="sd">        ``&#39;basic&#39;``                   estimate focal length, ky, and a single misalignment</span>
<span class="sd">                                      term for all images between the camera attitude and the spacecraft&#39;s attitude:</span>
<span class="sd">                                      :math:`\left[\begin{array}{ccc} f &amp; k_y &amp; \boldsymbol{\delta\theta}</span>
<span class="sd">                                      \end{array}\right]`</span>
<span class="sd">        ``&#39;intrinsic&#39;``               estimate focal length, kx, ky, px, and py:</span>
<span class="sd">                                      :math:`\left[\begin{array}{ccccc} f &amp; k_x &amp; k_y &amp; p_x &amp; p_y</span>
<span class="sd">                                      \end{array}\right]`.  Note that this will likely result in a rank-deficient matrix</span>
<span class="sd">                                      without an a priori covariance.  Use ``&#39;basic intrinsic&#39;`` instead.</span>
<span class="sd">        ``&#39;basic intrinsic&#39;``         estimate focal length and ky:</span>
<span class="sd">                                      :math:`\left[\begin{array}{cc} f &amp; k_y \end{array}\right]`</span>
<span class="sd">        ``&#39;focal_length&#39;``            the focal length of the camera:  :math:`f`</span>
<span class="sd">        ``&#39;kx&#39;``                      inverse of the pixel pitch along the x axis: :math:`k_x`</span>
<span class="sd">        ``&#39;ky&#39;``                      inverse of the pixel pitch along the y axis: :math:`k_y`</span>
<span class="sd">        ``&#39;px&#39;``                      x location of the principal point in pixels: :math:`p_x`</span>
<span class="sd">        ``&#39;py&#39;``                      y location of the principal point in pixels: :math:`p_y`</span>
<span class="sd">        ``&#39;a1&#39;``                      the linear coefficient for a temperature dependent focal length: :math:`a_1`</span>
<span class="sd">        ``&#39;a2&#39;``                      the quadratic coefficient for a temperature dependent focal length: :math:`a_2`</span>
<span class="sd">        ``&#39;a3&#39;``                      the cubic coefficient for a temperature dependent focal length: :math:`a_3`</span>
<span class="sd">        ``&#39;temperature dependence&#39;``  estimate 3 temperature dependence coefficients for the focal length a1, a2, a3:</span>
<span class="sd">                                      :math:`\left[\begin{array}{ccc} a_1 &amp; a_2 &amp; a_3 \end{array}\right]`</span>
<span class="sd">        ``&#39;single misalignment&#39;``     estimate a single misalignment for all images: :math:`\boldsymbol{\delta\theta}`</span>
<span class="sd">        ``&#39;multiple misalignments&#39;``  estimate a misalignment for each image:</span>
<span class="sd">                                      :math:`\left[\begin{array}{ccc}\boldsymbol{\delta\theta}_1 &amp; \ldots &amp;</span>
<span class="sd">                                      \boldsymbol{\delta\theta}_n \end{array}\right]`</span>
<span class="sd">        ============================  ==================================================================================</span>

<span class="sd">        Note that it may not be possible to estimate all attributes simultaneously because this may result in a rank</span>
<span class="sd">        deficient matrix in the calibration process (for instance, without setting a priori weights, estimating</span>
<span class="sd">        ``&#39;focal_length&#39;``, ``&#39;kx&#39;``, and ``&#39;ky&#39;`` together would result in a rank deficient matrix.  Therefore, just</span>
<span class="sd">        because you can set something in this list doesn&#39;t mean you should.</span>

<span class="sd">        For more details about calibrating a camera model, see the :mod:`.calibration` package for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimation_parameters</span>

    <span class="nd">@estimation_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimation_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_estimation_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_parameters</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="s1">&#39;multiple misalignments&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span> <span class="o">=</span> <span class="kc">False</span>
            
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            
            <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The estimation parameters elements must be one of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39; You specified </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
                
        <span class="k">return</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The inverse of the pixel pitch along the x axis in units of pix/distance.</span>

<span class="sd">        This is the conversion factor to convert from gnomic coordinates (in units of distance) to units of pixels.</span>
<span class="sd">        It corresponds to the [0, 0] component of the intrinsic matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@kx</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The skewness term between xy</span>

<span class="sd">        This is the conversion factor to convert from gnomic coordinates (in units of distance) to units of pixels.</span>
<span class="sd">        It corresponds to the [0, 1] component of the intrinsic matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@kxy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ky</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The inverse of the pixel pitch along the y axis in units of pix/distance.</span>

<span class="sd">        This is the conversion factor to convert from pinhole coordinates (in units of distance) to units of pixels.</span>
<span class="sd">        It corresponds to the [1, 1] component of the intrinsic matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@ky</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ky</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kyx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The skewness term between yx</span>

<span class="sd">        This is the conversion factor to convert from gnomic coordinates (in units of distance) to units of pixels.</span>
<span class="sd">        It corresponds to the [1, 0] component of the intrinsic matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@kyx</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kyx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">px</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The x pixel location of the principal point of the camera.</span>

<span class="sd">        The principal point of the camera is the point in the image where the distortion is zero (the point where the</span>
<span class="sd">        optical axis pierces the image).  This corresponds to the [0, 2] component of the intrinsic matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="nd">@px</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">px</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">py</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The y pixel location of the principal point of the camera.</span>

<span class="sd">        The principal point of the camera is the point in the image where the distortion is zero (the point where the</span>
<span class="sd">        optical axis pierces the image).  This corresponds to the [1, 2] component of the intrinsic matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="nd">@py</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">py</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The linear coefficient for the focal length temperature dependence</span>

<span class="sd">        This is the first term in the :attr:`.temperature_coefficients` array and is multiplied by the temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@a1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The quadratic coefficient for the focal length temperature dependence</span>

<span class="sd">        This is the second term in the :attr:`.temperature_coefficients` array and is multiplied by the temperature</span>
<span class="sd">        squared.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@a2</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a3</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cubic coefficient for the focal length temperature dependence</span>

<span class="sd">        This is the third term in the :attr:`.temperature_coefficients` array and is multiplied by the temperature</span>
<span class="sd">        cubed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@a3</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">focal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The focal length for the camera expressed in units of distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_focal_length</span>

    <span class="nd">@focal_length</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">focal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_focal_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intrinsic_matrix_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The inverse of the intrinsic matrix.</span>

<span class="sd">        The inverse of the intrinsic matrix is used to convert from units of pixels with an origin at the upper left</span>
<span class="sd">        corner of the image to units of distance with an origin at the principal point of the image.</span>

<span class="sd">        the intrinsic matrix has an analytic inverse which is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{K}^{-1} = \left[\begin{array}{ccc} \frac{1}{k_x} &amp; 0 &amp; \frac{-p_x}{k_x} \\</span>
<span class="sd">            0 &amp; \frac{1}{k_y} &amp; \frac{-p_y}{k_y} \end{array}\right]</span>

<span class="sd">        To convert from units of pixels to units of distance you would do::</span>
<span class="sd">            &gt;&gt;&gt; from giant.camera_models import PinholeModel</span>
<span class="sd">            &gt;&gt;&gt; model = PinholeModel(kx=5, ky=10, px=100, py=500)</span>
<span class="sd">            &gt;&gt;&gt; ((model.intrinsic_matrix_inv[:, :2]@[[1, 2, 300], [4, 5, 600]]).T + model.intrinsic_matrix_inv[:, 2]).T</span>
<span class="sd">            array([[-19.8, -19.6, 40.]</span>
<span class="sd">                   [-49.6, -49.5, 10.]])</span>

<span class="sd">        .. note:: For the :class:`PinholeModel`, this same functionality is available from :meth:`pixels_to_gnomic`.  In</span>
<span class="sd">                  classes with a distortion model (like the rest of the classes in this module) however, the above code</span>
<span class="sd">                  will give you distorted gnomic location, while the :meth:`pixels_to_gnomic` will give you</span>
<span class="sd">                  undistorted gnomic locations (true pinhole points).</span>

<span class="sd">        .. note:: Since the :class:`PinholeModel` class defines the intrinsic matrix as a :math:`2\times 3` matrix this</span>
<span class="sd">                  isn&#39;t a formal inverse.  To get the true inverse you need to append a row of [0, 0, 1] to both the</span>
<span class="sd">                  intrinsic matrix and intrinsic matrix inverse.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">kx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">px</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">kx</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ky</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">py</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ky</span><span class="p">]])</span>

<div class="viewcode-block" id="PinholeModel.adjust_temperature">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.adjust_temperature.html#giant.camera_models.pinhole_model.PinholeModel.adjust_temperature">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjust_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel_locations</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">old_temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">new_temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method adjusts a pixel location to reflect a new image temperature.</span>

<span class="sd">        This is done by (a) converting back to the image frame by multiplying by the inverse camera matrix,</span>
<span class="sd">        (b) multiplying by the ratio of the new temperature scaling to the old temperature scaling, and</span>
<span class="sd">        (c) multiplying by the camera matrix to return to pixel space</span>

<span class="sd">        :param pixel_locations: the pixel locations to change the temperature for</span>
<span class="sd">        :param old_temperature: the temperature the current pixel locations reflect</span>
<span class="sd">        :param new_temperature: the new desired temperature</span>
<span class="sd">        :return: the updated pixel locations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gnomic_distorted</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">pixel_locations</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">temp_change_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span>
            <span class="n">new_temperature</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">old_temperature</span><span class="p">)</span>
        <span class="n">new_gnomic_distorted</span> <span class="o">=</span> <span class="n">temp_change_ratio</span> <span class="o">*</span> <span class="n">gnomic_distorted</span>

        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">new_gnomic_distorted</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="PinholeModel.get_temperature_scale">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.get_temperature_scale.html#giant.camera_models.pinhole_model.PinholeModel.get_temperature_scale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_temperature_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="n">SCALAR_OR_ARRAY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the scaling to the focal length caused by a shift in temperature.</span>

<span class="sd">        The temperature dependence is defined as a third order polynomial in temperature:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \Delta f = 1 + a_1 T + a_2 T^2 + a_3 T^3</span>

<span class="sd">        where :math:`T` is the temperature (usually in units of degrees Celsius).</span>

<span class="sd">        You can use this method to get the temperature scaling as either a scalar value for a single parameter, or</span>
<span class="sd">        an array of values for an array of temperatures::</span>

<span class="sd">            &gt;&gt;&gt; from giant.camera_models import PinholeModel</span>
<span class="sd">            &gt;&gt;&gt; model = PinholeModel(a1=1, a2=2, a3=3)</span>
<span class="sd">            &gt;&gt;&gt; model.get_temperature_scale(5.5)</span>
<span class="sd">            566.125</span>
<span class="sd">            &gt;&gt;&gt; model.get_temperature_scale([5.5, -2.5, 0])</span>
<span class="sd">            array([ 566.125, -35.875, 1. ])</span>

<span class="sd">        :param temperature: The temperature(s) to compute the scaling at</span>
<span class="sd">        :return: the temperature scaling either as a float or a numpy ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ensure the temperature is a numpy array if it is an array</span>
        <span class="n">temperature</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># compute the powers of the temperature</span>
        <span class="n">temp_powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">temperature</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">**</span> <span class="mi">3</span><span class="p">])</span>

        <span class="c1"># compute the temperature scaling</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span> <span class="o">@</span> <span class="n">temp_powers</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">apply_distortion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pinhole_locations</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method simply returns the pinhole locations since this is the pinhole camera model.  It is included</span>
<span class="sd">        for completeness and for assisting with subclassing.</span>

<span class="sd">        In general this function is not used by the user and the higher level :meth:`project_onto_image` is used</span>
<span class="sd">        which calls this method (along with a few others) instead.  In cases were it is desirable to use this method</span>
<span class="sd">        the pinhole locations should be input as a shape (2,) or shape (2, n) array of image plane locations in units of</span>
<span class="sd">        distance.  The output from this function is the distorted image plane locations of the points in units of</span>
<span class="sd">        distance.</span>

<span class="sd">        You can input the pinhole locations as a single length 2 location, or an array of shape (2, n) locations::</span>
<span class="sd">            &gt;&gt;&gt; from giant.camera_models import PinholeModel</span>
<span class="sd">            &gt;&gt;&gt; model = PinholeModel()</span>
<span class="sd">            &gt;&gt;&gt; model.apply_distortion([1, 2])  # the output will be the same as the input since this is the pinhole</span>
<span class="sd">            [1, 2]</span>
<span class="sd">            &gt;&gt;&gt; model.apply_distortion([[1, 2, 3, 4], [5, 6, 7, 8]])</span>
<span class="sd">            [[1, 2, 3, 4], [5, 6, 7, 8]]</span>

<span class="sd">        :param pinhole_locations: The image plane location of points to be distorted as a shape (2,) or (2, n) array in</span>
<span class="sd">                                  units of distance</span>
<span class="sd">        :return: The distorted locations of the points on the image plane as a shape (2,) or (2, n) array in units of</span>
<span class="sd">                 distance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pinhole_locations</span><span class="p">)</span>

<div class="viewcode-block" id="PinholeModel.get_projections">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.get_projections.html#giant.camera_models.pinhole_model.PinholeModel.get_projections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes and returns the pinhole, and pixel locations for a set of</span>
<span class="sd">        3D points expressed in the camera frame.</span>

<span class="sd">        In general the user will not use this method and the higher level :meth:`project_onto_image` will be used</span>
<span class="sd">        instead.  In cases where it is desirable to use this method, the camera points should be input as a shape (2,)</span>
<span class="sd">        or shape (2, n) array of points expressed in the camera frame (units don&#39;t matter). This method will then return</span>
<span class="sd">        the gnomic locations in units of distance as a shape (2,) or (2, n) numpy array and the pixel locations of the</span>
<span class="sd">        points as a shape (2,) or (2, n) numpy array with units of pixels as a length 2 tuple.</span>

<span class="sd">        The optional `image` flag specifies which image you are projecting the points onto.  This is only important if</span>
<span class="sd">        you have the :attr:`estimate_multiple_misalignments` flag set to true, and have a different alignment set for</span>
<span class="sd">        each image.  In general, the optional input `image` should be ignored except during calibration.</span>

<span class="sd">        The optional `temperature` input specifies the temperature to perform the projection at.  This is only import</span>
<span class="sd">        when your focal length is dependent on temperature and you have entered or calibrated for the temperature</span>
<span class="sd">        dependency coefficients.</span>

<span class="sd">        You can specify the directions to be input as either a shape (3,) or shape (3, n) array::</span>
<span class="sd">            &gt;&gt;&gt; from giant.camera_models import PinholeModel</span>
<span class="sd">            &gt;&gt;&gt; model = PinholeModel(kx=300, ky=400, px=500, py=500, focal_length=10, a1=1e-5, a2=1e-6,</span>
<span class="sd">            &gt;&gt;&gt;                      misalignment=[[1e-12, -2e-14, 3e-10], [2e-15, 1e-13, 3e-10]],</span>
<span class="sd">            &gt;&gt;&gt;                      estimation_parameters=[&#39;multiple misalignments&#39;])</span>
<span class="sd">            &gt;&gt;&gt; model.get_projections([1, 2, 12000])</span>
<span class="sd">            (array([ 0.00083333,  0.00166667]), array([ 500.25      ,  500.66666667]))</span>
<span class="sd">            &gt;&gt;&gt; model.get_projections([[1, 2, 3, 4], [2, 5, 6, 7], [12000, 13000, 9000, 5000]], image=1)</span>
<span class="sd">            (array([[ 0.00083333,  0.00153846,  0.00333333,  0.008     ],</span>
<span class="sd">                    [ 0.00166667,  0.00384615,  0.00666667,  0.014     ]]),</span>
<span class="sd">             array([[ 500.25      ,  500.46153846,  501.        ,  502.4       ],</span>
<span class="sd">                    [ 500.66666667,  501.53846154,  502.66666667,  505.6       ]]))</span>
<span class="sd">            &gt;&gt;&gt; model.get_projections([[1, 2, 3, 4], [2, 5, 6, 7], [12000, 13000, 9000, 5000]], temperature=-1)</span>
<span class="sd">            (array([[-0.00166667, -0.00307694, -0.0066667 , -0.01600007],</span>
<span class="sd">                    [-0.00333335, -0.00769234, -0.01333339, -0.02800013]]),</span>
<span class="sd">             array([[ 499.49999775,  499.07691892,  497.999991  ,  495.1999784 ],</span>
<span class="sd">                    [ 498.66666066,  496.92306307,  494.66664266,  488.79994959]]))</span>

<span class="sd">        :param points_in_camera_frame: a shape (3,) or shape (3, n) array of points to project</span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :param temperature: The temperature to project the points at</span>
<span class="sd">        :return: A tuple of the pinhole and pixel locations for a set of 3D points</span>
<span class="sd">                 expressed in the camera frame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ensure the points are an array</span>
        <span class="n">camera_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points_in_camera_frame</span><span class="p">)</span>

        <span class="c1"># apply misalignment to the points</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="c1"># optimization to avoid matrix multiplication</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">]):</span>
                <span class="n">camera_points</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">@</span> <span class="n">camera_points</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">):</span>  <span class="c1"># optimization to avoid matrix multiplication</span>
                <span class="n">camera_points</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">@</span> <span class="n">camera_points</span>

        <span class="c1"># get the pinhole locations of the points</span>
        <span class="n">gnomic_locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">*</span> \
            <span class="n">camera_points</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">camera_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># type: np.ndarray</span>

        <span class="c1"># apply the temperature scaling</span>
        <span class="n">gnomic_locations</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># get the pixel locations of the points, need to mess with transposes due to numpy broadcasting rules</span>
        <span class="n">picture_locations</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">gnomic_locations</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">gnomic_locations</span><span class="p">,</span> <span class="n">gnomic_locations</span><span class="p">,</span> <span class="n">picture_locations</span></div>


<div class="viewcode-block" id="PinholeModel.project_onto_image">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.project_onto_image.html#giant.camera_models.pinhole_model.PinholeModel.project_onto_image">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_onto_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method transforms 3D points or directions expressed in the camera frame into the corresponding 2D image</span>
<span class="sd">        locations.</span>

<span class="sd">        The points input should be either 1 or 2 dimensional, with the first axis being length 3 (each point</span>
<span class="sd">        (direction) in the camera frame is specified as a column).</span>

<span class="sd">        The optional ``image`` key word argument specifies the index of the image you are projecting onto (this only</span>
<span class="sd">        applies if you have a separate misalignment for each image)</span>

<span class="sd">        The optional temperature input specifies the temperature to perform the projection at.  This is only import when</span>
<span class="sd">        your focal length is dependent on temperature and you have entered or calibrated for the temperature dependency</span>
<span class="sd">        coefficients.</span>

<span class="sd">        You can specify the directions to be input as either a shape (3,) or shape (3, n) array::</span>
<span class="sd">            &gt;&gt;&gt; from giant.camera_models import PinholeModel</span>
<span class="sd">            &gt;&gt;&gt; model = PinholeModel(kx=300, ky=400, px=500, py=500, focal_length=10, a1=1e-5, a2=1e-6,</span>
<span class="sd">            &gt;&gt;&gt;                      misalignment=[[1e-12, -2e-14, 3e-10], [2e-15, 1e-13, 3e-10]],</span>
<span class="sd">            &gt;&gt;&gt;                      estimation_parameters=[&#39;multiple misalignments&#39;])</span>
<span class="sd">            &gt;&gt;&gt; model.project_onto_image([1, 2, 12000])</span>
<span class="sd">            array([ 500.25      ,  500.66666667])</span>
<span class="sd">            &gt;&gt;&gt; model.project_onto_image([[1, 2, 3, 4], [2, 5, 6, 7], [12000, 13000, 9000, 5000]], image=1)</span>
<span class="sd">            array([[ 500.25      ,  500.46153846,  501.        ,  502.4       ],</span>
<span class="sd">                   [ 500.66666667,  501.53846154,  502.66666667,  505.6       ]])</span>
<span class="sd">            &gt;&gt;&gt; model.project_onto_image([[1, 2, 3, 4], [2, 5, 6, 7], [12000, 13000, 9000, 5000]], temperature=-1)</span>
<span class="sd">            array([[ 499.49999775,  499.07691892,  497.999991  ,  495.1999784 ],</span>
<span class="sd">                   [ 498.66666066,  496.92306307,  494.66664266,  488.79994959]])</span>

<span class="sd">        :param points_in_camera_frame: a shape (3,) or shape (3, n) array of points to project</span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :param temperature: The temperature to project the points at</span>
<span class="sd">        :return: A shape (2,) or shape (2, n) numpy array of image points (with units of pixels)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">picture_locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_projections</span><span class="p">(</span>
            <span class="n">points_in_camera_frame</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">picture_locations</span></div>


<div class="viewcode-block" id="PinholeModel.project_directions">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.project_directions.html#giant.camera_models.pinhole_model.PinholeModel.project_directions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directions_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method transforms 3D directions expressed in the camera frame into the corresponding 2D image</span>
<span class="sd">        directions.</span>

<span class="sd">        The direction input should be either 1 or 2 dimensional, with the first axis being length 3 (each direction</span>
<span class="sd">        in the camera frame is specified as a column).</span>

<span class="sd">        The optional ``image`` key word argument specifies the index of the image you are projecting onto (this only</span>
<span class="sd">        applies if you have a separate misalignment for each image)</span>

<span class="sd">        This method is different from method :meth:`project_onto_image` in that it only projects the direction component</span>
<span class="sd">        perpendicular to the optical axis of the camera (x, y axes of the camera frame) into a unit vector in the image</span>
<span class="sd">        plane.  Therefore, you do not get a location in the image out of this, rather a unitless direction in the image.</span>

<span class="sd">        :param directions_in_camera_frame: a shape (3,) or shape (3, n) array of points to project</span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :return: A shape (2,) or shape (2, n) numpy array of image direction unit vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">directions_in_camera_frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">directions_in_camera_frame</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="c1"># optimization to avoid matrix multiplication</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">]):</span>
                <span class="n">directions_in_camera_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">@</span>
                                              <span class="n">directions_in_camera_frame</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">):</span>  <span class="c1"># optimization to avoid matrix multiplication</span>
                <span class="n">directions_in_camera_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">@</span>
                                              <span class="n">directions_in_camera_frame</span><span class="p">)</span>

        <span class="n">image_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">directions_in_camera_frame</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">image_direction</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">image_direction</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="PinholeModel.compute_pixel_jacobian">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.compute_pixel_jacobian.html#giant.camera_models.pinhole_model.PinholeModel.compute_pixel_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pixel_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors_in_camera_frame</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian matrix :math:`\partial\mathbf{x}_P/\partial\mathbf{x}_C` where</span>
<span class="sd">        :math:`\mathbf{x}_C` is a vector in the camera frame that projects to :math:`\mathbf{x}_P` which is the</span>
<span class="sd">        pixel location.</span>

<span class="sd">        This method is used in the :class:`.LimbScanning` process in order to predict the change in a projected pixel</span>
<span class="sd">        location with respect to a change in the projected vector.  The :attr:`vectors_in_camera_frame` input should</span>
<span class="sd">        be a 3xn array of vectors which the Jacobian is to be computed for.</span>

<span class="sd">        Mathematically the Jacobian matrix is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{x}_C} =</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{x}_I}</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial\mathbf{x}_C&#39;}</span>
<span class="sd">            \frac{\partial\mathbf{x}_C&#39;}{\partial\mathbf{x}_C}</span>

<span class="sd">        where</span>

<span class="sd">        .. math::</span>
<span class="sd">            :nowrap:</span>

<span class="sd">            \begin{gather}</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{x}_I} = (1+a_1T+a_2T^2+a_3T^3)</span>
<span class="sd">            \mathbf{K}_{2x2} \\</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial\mathbf{x}_C&#39;} = \frac{f}{z_C&#39;}\left[</span>
<span class="sd">            \begin{array}{ccc}1 &amp; 0 &amp; \frac{-x_C&#39;}{z_C&#39;} \\ 0 &amp; 1 &amp; \frac{-y_C&#39;}{z_C&#39;} \end{array}\right] \\</span>
<span class="sd">            \frac{\partial\mathbf{x}_C&#39;}{\partial\mathbf{x}_C} = \mathbf{T}_{\boldsymbol{\delta\theta}}</span>
<span class="sd">            \end{gather}</span>

<span class="sd">        :math:`\mathbf{x}_C&#39;` is the camera frame point after applying the misalignment,</span>
<span class="sd">        :math:`\boldsymbol{\delta\theta}` is the misalignment vector, :math:`\mathbf{x}_C` is the camera frame point</span>
<span class="sd">        before misalignment is applied,</span>
<span class="sd">        :math:`\mathbf{x}_P` is the pixel location, :math:`\mathbf{x}_I` is the gnomic location,</span>
<span class="sd">        :math:`a_{1-3}` are the temperature coefficients, :math:`T` is the temperature, :math:`k_x` is the inverse of</span>
<span class="sd">        the pixel pitch in the x direction,  :math:`k_y` is the inverse of the pixel pitch in the y direction,</span>
<span class="sd">        :math:`f` is the focal length, :math:`\mathbf{K}_{2x2}` is the first 2 rows and columns of the</span>
<span class="sd">        :attr:`intrinsic_matrix`, and :math:`\mathbf{T}_{\boldsymbol{\delta\theta}}` is the rotation matrix</span>
<span class="sd">        corresponding to rotation vector :math:`\boldsymbol{\delta\theta}`.</span>

<span class="sd">        :param vectors_in_camera_frame: The vectors to compute the Jacobian at</span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :param temperature: The temperature to project the points at</span>
<span class="sd">        :return: The Jacobian matrix as a nx2x3 array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vectors_in_camera_frame</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>

            <span class="c1"># get the required projections for the point</span>
            <span class="n">gnomic_location</span><span class="p">,</span> <span class="n">gnomic_location_distorted</span><span class="p">,</span> <span class="n">pixel_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_projections</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span>
                                                                                              <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                                                                                              <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

            <span class="c1"># get the camera point after misalignment and shift from principle frame is applied</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
                <span class="c1"># optimization to avoid matrix multiplication</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">]):</span>
                    <span class="n">mis</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="n">cam_point</span> <span class="o">=</span> <span class="n">mis</span> <span class="o">@</span> <span class="n">vector</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">cam_point</span> <span class="o">=</span> <span class="n">vector</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">):</span>  <span class="c1"># optimization to avoid matrix multiplication</span>
                    <span class="n">mis</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="n">cam_point</span> <span class="o">=</span> <span class="n">mis</span> <span class="o">@</span> <span class="n">vector</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">cam_point</span> <span class="o">=</span> <span class="n">vector</span>

            <span class="c1"># compute the radial distance from the optical axis as well as its powers</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gnomic_location</span><span class="p">))</span>
            <span class="n">radius2</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">radius3</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius2</span>
            <span class="n">radius4</span> <span class="o">=</span> <span class="n">radius2</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>
            <span class="c1"># get the partial derivative of the measurement with respect to the input vector</span>
            <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>

            <span class="c1"># get the partial derivative of the distorted gnomic location with respect to the gnomic location</span>
            <span class="n">ddist_gnom_dgnom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ddistortion_dgnomic</span><span class="p">(</span><span class="n">gnomic_location</span><span class="p">,</span>
                                                                             <span class="n">radius</span><span class="p">,</span> <span class="n">radius2</span><span class="p">,</span> <span class="n">radius3</span><span class="p">,</span> <span class="n">radius4</span><span class="p">)</span>

            <span class="c1"># get the partial derivative of the pixel location of the point with respect to the dist gnomic location</span>
            <span class="n">dpix_ddist_gnom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dpixel_ddistorted_gnomic</span><span class="p">(</span>
                <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

            <span class="c1"># compute the partial derivative of the misaligned vector with respect to a change in the input vector</span>
            <span class="n">dcam_point_dvector</span> <span class="o">=</span> <span class="n">mis</span>

            <span class="c1"># compute the partial derivative of the gnomic location with respect to the point in the camera frame</span>
            <span class="n">dgnom_dcam_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dgnomic_dcamera_point</span><span class="p">(</span><span class="n">cam_point</span><span class="p">)</span>

            <span class="c1"># compute the partial derivative of the pixel location with respect to the input vector</span>
            <span class="n">dpix_dvector</span> <span class="o">=</span> <span class="n">dpix_ddist_gnom</span> <span class="o">@</span> <span class="n">ddist_gnom_dgnom</span> <span class="o">@</span> <span class="n">dgnom_dcam_point</span> <span class="o">@</span> <span class="n">dcam_point_dvector</span>

            <span class="n">jacobian</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dpix_dvector</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ddistortion_dgnomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the change in the distortion with respect to a change in the gnomic location.</span>

<span class="sd">        For the pinhole model, the distortion doesn&#39;t change (since there isn&#39;t a distortion) therefore this method</span>
<span class="sd">        simply returns the 2x2 0 matrix.  This method is included simply for subclassing purposes.</span>

<span class="sd">        :param args: Ignored</span>
<span class="sd">        :return: A 2x2 0 matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dcamera_point_dgnomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gnomic_location</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">vec_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method compute the change in the misaligned unit vector with respect to a change in the gnomic location,</span>
<span class="sd">        :math:`\partial\mathbf{x}_C&#39;/\partial\mathbf{x}_I`.</span>

<span class="sd">        Mathematically this is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_C&#39;}{\partial\mathbf{x}_I} = \left[\begin{array}{cc}</span>
<span class="sd">            1/v &amp; 0 \\ 0 &amp; 1/v \\ 0 &amp; 0\end{array}\right] -</span>
<span class="sd">            \frac{1}{v^3}\left[\begin{array}{c} \mathbf{x}_I \\ f \end{array}\right]\mathbf{x}_I^T</span>

<span class="sd">        :param gnomic_location: The gnomic location we are computing the derivative at</span>
<span class="sd">        :param vec_length: The amount the vector is divided by to make it a unit vector</span>
<span class="sd">        :return: The change in the misaligned unit vector with respect to a change in the gnomic location</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">gnomic_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gnomic_location</span><span class="p">)</span>

        <span class="n">vector_portion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">vec_length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))])</span>
        <span class="n">scalar_portion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">gnomic_location</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">]]),</span>
                                  <span class="n">gnomic_location</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">vec_length</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vector_portion</span> <span class="o">-</span> <span class="n">scalar_portion</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dgnomic_ddist_gnomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distorted_gnomic_location</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the change in the gnomic location with respect to a change in the distorted gnomic location</span>
<span class="sd">        for the inverse camera model.</span>

<span class="sd">        Since this process is iterative this is only an approximate solution.</span>

<span class="sd">        Mathematically this is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial\mathbf{x}_I&#39;} = \mathbf{I}_{2\times 2} -</span>
<span class="sd">            \left.\frac{\partial\mathbf{x}_I&#39;}{\partial\mathbf{x}_I}\right|_{\mathbf{x}_I=\mathbf{x}_I&#39;}</span>

<span class="sd">        :param distorted_gnomic_location: The distorted gnomic location we are calculating the derivative at.</span>
<span class="sd">        :return: the partial derivative of the gnomic location with respect to the distorted gnomic location for the</span>
<span class="sd">                 inverse camera model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the radial distance from the principal point and its powers to give to the ddistortion/dgnomic method</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">distorted_gnomic_location</span><span class="p">)</span>
        <span class="n">radius2</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>
        <span class="n">radius3</span> <span class="o">=</span> <span class="n">radius2</span> <span class="o">*</span> <span class="n">radius</span>
        <span class="n">radius4</span> <span class="o">=</span> <span class="n">radius2</span> <span class="o">*</span> <span class="n">radius2</span>

        <span class="c1"># compute the derivative</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ddistortion_dgnomic</span><span class="p">(</span><span class="n">distorted_gnomic_location</span><span class="p">,</span>
                                                             <span class="n">radius</span><span class="p">,</span> <span class="n">radius2</span><span class="p">,</span> <span class="n">radius3</span><span class="p">,</span> <span class="n">radius4</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ddist_gnomic_dpixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the change in the distorted gnomic location with respect to a change in the pixel location.</span>

<span class="sd">        This change is the same for all pixel locations and is given mathematically by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_I&#39;}{\partial\mathbf{x}_P} = \frac{\mathbf{K}^{-1}}{1+a_1T+a_2T^2+a_3T^3}</span>

<span class="sd">        :param temperature: The temperature of the camera</span>
<span class="sd">        :return: The partial derivative of the distorted gnomic location with respect to the pixel location</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

<div class="viewcode-block" id="PinholeModel.compute_unit_vector_jacobian">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.compute_unit_vector_jacobian.html#giant.camera_models.pinhole_model.PinholeModel.compute_unit_vector_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_unit_vector_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel_locations</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian matrix :math:`\partial\mathbf{x}_C/\partial\mathbf{x}_P` where</span>
<span class="sd">        :math:`\mathbf{x}_C` is a vector in the camera frame that projects to :math:`\mathbf{x}_P` which is the</span>
<span class="sd">        pixel location.</span>

<span class="sd">        This method is used in the :class:`.LimbScanning` process in order to predict the change in the unit vector that</span>
<span class="sd">        projects to a pixel location with respect to a change in the pixel location.  The</span>
<span class="sd">        ``pixel_locations`` input should be a 2xn array of vectors which the Jacobian is to be computed for.</span>

<span class="sd">        :param pixel_locations: The pixel locations to compute the Jacobian at</span>
<span class="sd">        :param image: The number of the image we are computing the Jacobian for</span>
<span class="sd">        :param temperature: The temperature to compute the Jacobian at</span>
<span class="sd">        :return: The Jacobian matrix as a nx3x2 array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pixel_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">pixel_locations</span><span class="p">)</span>

        <span class="c1"># get the misalignment matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="c1"># optimization to avoid matrix multiplication</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">]):</span>
                <span class="n">mis</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">mis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">):</span>  <span class="c1"># optimization to avoid matrix multiplication</span>
                <span class="n">mis</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">mis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># get the distorted gnomic location</span>
        <span class="n">gnomic_distorted</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">pixel_locations</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># get the gnomic location and the unit vector in the camera frame</span>
        <span class="n">gnomic_locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels_to_gnomic</span><span class="p">(</span>
            <span class="n">pixel_locations</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># append the focal length</span>
        <span class="k">if</span> <span class="n">pixel_locations</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cam_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">gnomic_locations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">cam_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">gnomic_locations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">pixel_locations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])</span>

        <span class="n">unit_vectors</span> <span class="o">=</span> <span class="n">mis</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">cam_points</span>

        <span class="n">vec_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cam_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">unit_vectors</span> <span class="o">/=</span> <span class="n">vec_lengths</span>

        <span class="c1"># initialize the Jacobian list</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># compute the change in the distorted gnomic location with respect to a change in the pixel location</span>
        <span class="c1"># we can do this here once because it is independent of the pixel location</span>
        <span class="n">dgnom_dist_dpixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ddist_gnomic_dpixel</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pixel</span><span class="p">,</span> <span class="n">gnomic_loc</span><span class="p">,</span> <span class="n">dist_gnom_loc</span><span class="p">,</span> <span class="n">cam_point</span><span class="p">,</span> <span class="n">unit_vector</span><span class="p">,</span> <span class="n">vec_length</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pixel_locations</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                                        <span class="n">gnomic_locations</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                                        <span class="n">gnomic_distorted</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                                        <span class="n">cam_points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">unit_vectors</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                                        <span class="n">vec_lengths</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
            <span class="c1"># compute the change in the camera location with respect to a change in the misaligned camera location</span>
            <span class="n">dunit_dcam_point</span> <span class="o">=</span> <span class="n">mis</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># compute the change in the misaligned camera direction with respect to a change in the gnomic location</span>
            <span class="n">dcam_point_dgnomic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dcamera_point_dgnomic</span><span class="p">(</span>
                <span class="n">gnomic_loc</span><span class="p">,</span> <span class="n">vec_length</span><span class="p">)</span>

            <span class="c1"># compute the change in the gnomic location with respect to a change in the distorted gnomic location</span>
            <span class="n">dgnom_ddist_gnom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dgnomic_ddist_gnomic</span><span class="p">(</span><span class="n">gnomic_loc</span><span class="p">)</span>

            <span class="c1"># form the Jacobian rows and append to the Jacobian list</span>
            <span class="n">jacobian</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dunit_dcam_point</span> <span class="o">@</span> <span class="n">dcam_point_dgnomic</span> <span class="o">@</span>
                            <span class="n">dgnom_ddist_gnom</span> <span class="o">@</span> <span class="n">dgnom_dist_dpixel</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dcamera_point_dmisalignment</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the partial derivative of the 3D camera frame location with respect to a change in the misalignment</span>

<span class="sd">        Mathematically, this partial is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_C&#39;}{\partial\boldsymbol{\delta\theta}} = \left[\mathbf{x}_C\times\right]</span>

<span class="sd">        where :math:`\mathbf{x}_C&#39;` is the camera frame point after applying the misalignment,</span>
<span class="sd">        :math:`\boldsymbol{\delta\theta}` is the misalignment vector, :math:`\mathbf{x}_C` is the camera frame point</span>
<span class="sd">        before misalignment is applied, and :math:`\left[\bullet\times\right]` is the skew-symmetric cross product</span>
<span class="sd">        matrix formed from :math:`\bullet`.</span>

<span class="sd">        :param unit_vector_camera: the unit vector through the point in the camera frame</span>
<span class="sd">        :return: the partial derivative of the 3D camera frame location with respect to a change in the misalignment</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">skew</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dpixel_ddistorted_gnomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the partial derivative of the pixel location with respect to a change in the distorted gnomic location.</span>

<span class="sd">        Mathematically, this partial is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{x}_I} = (1+a_1T+a_2T^2+a_3T^3)</span>
<span class="sd">            \left[\begin{array}{cc} k_x &amp; 0 \\ 0 &amp; k_y \end{array}\right]</span>

<span class="sd">        where :math:`\mathbf{x}_P` is the pixel location, :math:`\mathbf{x}_I` is the gnomic location,</span>
<span class="sd">        :math:`a_{1-3}` are the temperature coefficients, :math:`T` is the temperature, :math:`k_x` is the inverse of</span>
<span class="sd">        the pixel pitch in the x direction, and :math:`k_y` is the inverse of the pixel pitch in the y direction</span>

<span class="sd">        :param temperature: The temperature of the camera</span>
<span class="sd">        :return: the partial derivative of the pixel location with respect to a change in the distorted gnomic location</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dgnomic_dcamera_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_vector_camera</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the partial derivative of the gnomic location with respect to a change in the 3D camera frame location</span>
<span class="sd">        after the misalignment correction is applied.</span>

<span class="sd">        Mathematically this is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial\mathbf{x}_C&#39;} = \frac{f}{z_C&#39;}\left[</span>
<span class="sd">            \begin{array}{ccc}1 &amp; 0 &amp; \frac{-x_C&#39;}{z_C&#39;} \\ 0 &amp; 1 &amp; \frac{-y_C&#39;}{z_C&#39;} \end{array}\right]</span>

<span class="sd">        where all is as defined before.</span>

<span class="sd">        :param unit_vector_camera: The 3D camera frame location of the point after misalignment is applied</span>
<span class="sd">        :return: The partial derivative of the gnomic location with respect to a change in the 3D camera frame location</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unit_vector_camera</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">/</span> <span class="n">unit_vector_camera</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="n">unit_vector_camera</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                                                                      <span class="n">unit_vector_camera</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dgnomic_dfocal_length</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the partial derivative of the gnomic location with respect to a change in the focal length.</span>

<span class="sd">        The input is the camera frame point after the misalignment correction has been applied.</span>

<span class="sd">        Mathematically this is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial f} = \frac{1}{z_C&#39;}</span>
<span class="sd">            \left[\begin{array}{c}x_C&#39;\\y_C&#39;\end{array}\right]</span>

<span class="sd">        :param unit_vector_camera: the point being projected onto the image after the misalignment correction is applied</span>
<span class="sd">        :return: The partial derivative of the gnomic location with respect to a change in the focal length</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unit_vector_camera</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unit_vector_camera</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit_vector_camera</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dpixel_dintrinsic</span><span class="p">(</span><span class="n">gnomic_location_distorted</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        computes the partial derivative of the pixel location with respect to a change in one of the intrinsic matrix</span>
<span class="sd">        parameters given the gnomic location of the point we are computing the derivative for.</span>

<span class="sd">        Mathematically this is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{k}} = \left[\begin{array}{cccc} x_I &amp; 0 &amp; 1 &amp; 0 \\</span>
<span class="sd">            0 &amp; y_I &amp; 0 &amp; 1 \end{array}\right]</span>

<span class="sd">        where :math:`\mathbf{k}=[k_x \quad k_y \quad p_x \quad p_y]` is a vector of the intrinsic camera parameters</span>
<span class="sd">        and all else is as defined before.</span>

<span class="sd">        :param gnomic_location_distorted: the gnomic location of the point to compute the derivative for</span>
<span class="sd">        :return: the partial derivative of the pixel location with respect to a change in one of the intrinsic matrix</span>
<span class="sd">                 parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the partial derivative of the pixel location with respect to the pixel pitch</span>
        <span class="n">dpix_dkx</span> <span class="o">=</span> <span class="p">[</span><span class="n">gnomic_location_distorted</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dpix_dky</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">gnomic_location_distorted</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># compute the partial derivative of the pixel location with respect to the principal point</span>
        <span class="n">dpix_dpx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dpix_dpy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># compute the partial derivative of the pixel location with respect to the intrinsic matrix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dpix_dkx</span><span class="p">,</span> <span class="n">dpix_dky</span><span class="p">,</span> <span class="n">dpix_dpx</span><span class="p">,</span> <span class="n">dpix_dpy</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_dpixel_dtemperature_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gnomic_location_distorted</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the partial derivative of the pixel coordinates with respect to a change in the temperature</span>
<span class="sd">        coefficients for a given gnomic location and temperature.</span>

<span class="sd">        Mathematically this is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{a}} = \left[\begin{array}{cc} k_x &amp; 0 \\</span>
<span class="sd">            0 &amp; k_y\end{array}\right] \mathbf{x}_I \left[\begin{array}{ccc} T &amp; T^2 &amp; T^3 \end{array}\right]</span>

<span class="sd">        where :math:`\mathbf{a}=[a_1 \quad a_2 \quad a_3]` is a vector of the temperature dependence coefficients.</span>

<span class="sd">        :param gnomic_location_distorted:  The gnomic location point to compute the derivative for</span>
<span class="sd">        :param temperature:  The temperature to compute the derivative at</span>
<span class="sd">        :return: The partial derivative of the pixel coordinates with respect to a change in the temperature</span>
<span class="sd">                 coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the powers of the temperature</span>
        <span class="n">temperature_powers</span> <span class="o">=</span> <span class="p">[</span><span class="n">temperature</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">*</span>
                              <span class="n">temperature</span><span class="p">,</span> <span class="n">temperature</span><span class="o">*</span><span class="n">temperature</span><span class="o">*</span><span class="n">temperature</span><span class="p">]</span>

        <span class="c1"># convert the gnomic location to units of pixels</span>
        <span class="n">gnomic_pixels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">gnomic_location_distorted</span>

        <span class="c1"># get the derivative</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">gnomic_pixels</span><span class="p">,</span> <span class="n">temperature_powers</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_jacobian_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_vector_camera</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_images</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Jacobian matrix for a single point.</span>

<span class="sd">        The Jacobian is calculated for every possible parameter that could be included in the state vector in this</span>
<span class="sd">        method, and then columns corresponding to the state vectors that the Jacobian is not needed for can be removed</span>
<span class="sd">        using the :meth:`_remove_jacobian_columns` method.</span>

<span class="sd">        In general you should use the :meth:`compute_jacobian` method in place of this method.</span>

<span class="sd">        This method computes the following:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{c}} = \left[\begin{array}{cccc}</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial f} &amp; \frac{\partial\mathbf{x}_P}{\mathbf{k}} &amp;</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{a}} &amp;</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\boldsymbol{\delta\theta}}\end{array}\right]</span>

<span class="sd">        where, using the chain rule,</span>

<span class="sd">        .. math::</span>
<span class="sd">            :nowrap:</span>

<span class="sd">            \begin{gather}</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial f} =</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{x}_I}</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial f} \\</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\boldsymbol{\delta\theta}} =</span>
<span class="sd">            \frac{\partial\mathbf{x}_P}{\partial\mathbf{x}_I}</span>
<span class="sd">            \frac{\partial\mathbf{x}_I}{\partial\mathbf{x}_C&#39;}</span>
<span class="sd">            \frac{\partial\mathbf{x}_C&#39;}{\partial\boldsymbol{\delta\theta}}</span>
<span class="sd">            \end{gather}</span>

<span class="sd">        and all else is as defined before.</span>

<span class="sd">        :param unit_vector_camera: The unit vector we are computing the Jacobian for</span>
<span class="sd">        :param image: The number of the image we are computing the Jacobian for</span>
<span class="sd">        :param num_images:   The total number of images included in our Jacobian matrix</span>
<span class="sd">        :param temperature: The temperature to compute the Jacobian at</span>
<span class="sd">        :return: The row of the Jacobian matrix corresponding to the input unit vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">unit_vector_camera</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">unit_vector_camera_mis</span> <span class="o">=</span> <span class="n">unit_vector_camera</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="c1"># optimization to avoid matrix multiplication</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">]):</span>
                <span class="n">unit_vector_camera_mis</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">@</span> <span class="n">unit_vector_camera</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">):</span>  <span class="c1"># optimization to avoid matrix multiplication</span>
                <span class="n">unit_vector_camera_mis</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">@</span> <span class="n">unit_vector_camera</span>

        <span class="c1"># get the required projections for the point</span>
        <span class="n">gnomic_location</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">pixel_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_projections</span><span class="p">(</span><span class="n">unit_vector_camera</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                                                                  <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>
        <span class="c1"># get the partial derivative of the measurement with respect to the misalignment vector</span>
        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>

        <span class="c1"># get the partial derivative of the pixel location of the point with respect to the gnomic location</span>
        <span class="n">dpix_dgnom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dpixel_ddistorted_gnomic</span><span class="p">(</span>
            <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># compute the partial derivative of the camera location with respect to a change in the misalignment vector</span>
        <span class="n">dcam_point_dmisalignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dcamera_point_dmisalignment</span><span class="p">(</span>
            <span class="n">unit_vector_camera</span><span class="p">)</span>

        <span class="c1"># compute the partial derivative of the gnomic location with respect to the point in the camera frame</span>
        <span class="n">dgnom_dcam_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dgnomic_dcamera_point</span><span class="p">(</span>
            <span class="n">unit_vector_camera_mis</span><span class="p">)</span>

        <span class="c1"># compute the partial derivative of the pixel location with respect to the misalignment</span>
        <span class="n">dpix_dmisalignment</span> <span class="o">=</span> <span class="n">dpix_dgnom</span> <span class="o">@</span> <span class="n">dgnom_dcam_point</span> <span class="o">@</span> <span class="n">dcam_point_dmisalignment</span>

        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>
        <span class="c1"># get the partial derivative of the measurement with respect to the focal length</span>
        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>

        <span class="c1"># compute the change in the gnomic location with respect to a change in the focal length</span>
        <span class="n">dgnom_dfocal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dgnomic_dfocal_length</span><span class="p">(</span>
            <span class="n">unit_vector_camera_mis</span><span class="p">)</span>

        <span class="c1"># compute the change in the pixel location with respect to the focal length</span>
        <span class="n">dpix_dfocal</span> <span class="o">=</span> <span class="n">dpix_dgnom</span> <span class="o">@</span> <span class="n">dgnom_dfocal</span>

        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>
        <span class="c1"># get the partial derivative of the measurement with respect to the terms of the intrinsic matrix</span>
        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>

        <span class="n">dpix_dintrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dpixel_dintrinsic</span><span class="p">(</span><span class="n">gnomic_location</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>
        <span class="c1"># get the partial derivative of the measurement with respect to the temperature coefficients</span>
        <span class="c1"># --------------------------------------------------------------------------------------------------------------</span>

        <span class="n">dpix_dtemperature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dpixel_dtemperature_coeffs</span><span class="p">(</span>
            <span class="n">gnomic_location</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># stack everything together.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="n">jacobian_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">dpix_dfocal</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dpix_dintrinsic</span><span class="p">,</span> <span class="n">dpix_dtemperature</span><span class="p">,</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">image</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                                               <span class="p">),</span> <span class="n">dpix_dmisalignment</span><span class="p">,</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">num_images</span> <span class="o">-</span> <span class="n">image</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">jacobian_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">dpix_dfocal</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dpix_dintrinsic</span><span class="p">,</span> <span class="n">dpix_dtemperature</span><span class="p">,</span>
                                      <span class="n">dpix_dmisalignment</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">jacobian_row</span>

<div class="viewcode-block" id="PinholeModel.compute_jacobian">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.compute_jacobian.html#giant.camera_models.pinhole_model.PinholeModel.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_vectors_in_camera_frame</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]],</span>
                         <span class="n">temperature</span><span class="p">:</span> <span class="n">F_SCALAR_OR_ARRAY</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Jacobian matrix for each observation in `unit_vectors_in_camera_frame` for each parameter to be estimated</span>
<span class="sd">        as defined in the :attr:`estimation_parameters` attribute.</span>

<span class="sd">        This method works by first computing the partial derivatives for all camera parameters for each provided unit</span>
<span class="sd">        vector. It then concatenates the rows into the Jacobian matrix and removes any columns of parameters that</span>
<span class="sd">        are not specified in the :attr:`estimation_parameters` attribute and sorts the columns according to the order</span>
<span class="sd">        of the :attr:`estimation_parameters` attribute. The resulting Jacobian</span>
<span class="sd">        will be the appropriate size and in the order specified by :attr:`estimation_parameters`.  There is one</span>
<span class="sd">        constraint that the misalignment (if included) must be last in :attr:`estimation_parameters`.</span>

<span class="sd">        The `unit_vectors_in_camera_frame` inputs should be formatted as a Sequence of 2d sequences.  Each inner 2D sequence</span>
<span class="sd">        should be of shape :math:`3\times x`, where each row corresponds to a component of a unit vector in the camera</span>
<span class="sd">        frame. Each inner sequence should contain all observations from a single image, so that if there are :math:`m`</span>
<span class="sd">        images being considered, then the outer sequence should be length :math:`m`.  The value of :math:`x` can change</span>
<span class="sd">        for each image. If you are estimating multiple misalignments (one for each image) then each misalignment will</span>
<span class="sd">        correspond to the order of the image observations in the outer sequence.</span>

<span class="sd">        You can also set the :attr:`use_a_priori` to True to have this method append an identity matrix to the bottom of</span>
<span class="sd">        this Jacobian if you are solving for an update to your camera model, and not a new one entirely.</span>

<span class="sd">        The optional `temperature` input specifies the temperature of the camera for use in estimating temperature</span>
<span class="sd">        dependence.  The temperature input should either be a scalar value (float or int), or a list that is the same</span>
<span class="sd">        length as `unit_vectors_in_camera_frame`, where each element of the list is the temperature of the camera at the time</span>
<span class="sd">        of each image represented by `unit_vectors_in_camera_frame`.  If the `temperature` input is a scalar, then it is assumed</span>
<span class="sd">        to be the temperature value for all of the images represented in `unit_vectors_in_camera_frame`.</span>

<span class="sd">        :param unit_vectors_in_camera_frame: The points/directions in the camera frame that the jacobian matrix is to be computed</span>
<span class="sd">                                    for.  For multiple images, this should be a list of 2D unit vectors where each</span>
<span class="sd">                                    element of the list corresponds to a new image.</span>
<span class="sd">        :param temperature: A single temperature for all images or a list of temperatures the same length of</span>
<span class="sd">                            `unit_vectors_in_camera_frame` containing the temperature of the camera at the time each image was</span>
<span class="sd">                            captured</span>
<span class="sd">        :return: The Jacobian matrix evaluated for each observation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the number of images being considered</span>
        <span class="n">number_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit_vectors_in_camera_frame</span><span class="p">)</span>

        <span class="c1"># initialize the Jacobian list</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># put the temperature into the correct format</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">temperature</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">temperature</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit_vectors_in_camera_frame</span><span class="p">)</span>

        <span class="c1"># walk through the observations for each image</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">vecs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unit_vectors_in_camera_frame</span><span class="p">):</span>
            <span class="c1"># walk through the observations in the current image</span>
            <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">vecs</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
                <span class="c1"># get the full Jacobian row for the current observation</span>
                <span class="n">jac_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_jacobian_row</span><span class="p">(</span>
                    <span class="n">vec</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">number_images</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

                <span class="n">jacobian</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jac_row</span><span class="p">)</span>

        <span class="c1"># remove un-needed columns from the Jacobian matrix and turn into ndarray</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_unused_misalignment</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">unit_vectors_in_camera_frame</span><span class="p">)</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_jacobian_columns</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span>

        <span class="c1"># append the identity matrix if we are solving for an update to our model, and not an entirely new independent</span>
        <span class="c1"># model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_a_priori</span><span class="p">:</span>
            <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">jacobian</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="o">-</span><span class="n">jacobian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:,</span> <span class="o">-</span><span class="n">jacobian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">jacobian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">jacobian</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_jacobian_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes columns from the full size Jacobian according to the parameters in</span>
<span class="sd">        :attr:`estimation_parameters`.</span>

<span class="sd">        The columns are removed and reordered.  In general the user will not use this method, and instead will use the</span>
<span class="sd">        :meth:`compute_jacobian` method which calls this method.</span>

<span class="sd">        .. note:: This method assumes that Jacobian is organized according to :meth:`_get_jacobian_row`.  If the</span>
<span class="sd">                  Jacobian is not organized in this way then the results from this method will be invalid.</span>

<span class="sd">        :param jacobian: The Jacobian matrix to remove the columns from</span>
<span class="sd">        :return: The reordered and simplified Jacobian</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jac_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through each element in the estimation parameters attribute and store the appropriate columns</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">:</span>
            <span class="n">jac_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jacobian</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]])</span>

        <span class="c1"># reform the Jacobian matrix into a ndarray</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">jac_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_unused_misalignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vecs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to remove unused misalignment columns from the Jacobian matrix when arbitrary images</span>
<span class="sd">        are not included in the calibration</span>

<span class="sd">        The unused misalignment columns are determined by matching them with empty lists in the `vecs` list.  When</span>
<span class="sd">        an empty index is found, the corresponding columns for that image are removed from the `jacobian` matrix</span>
<span class="sd">        and a flag is set in the :attr:`_fix_misalignment` attribute that is used later when applying the update</span>
<span class="sd">        vector.</span>

<span class="sd">        These methods are only necessary when arbitrary images are excluded from the calibration solution using</span>
<span class="sd">        the :attr:`Camera.image_mask` attribute and there are multiple misalignments being estimated.</span>

<span class="sd">        :param jacobian: The Jacobian matrix to remove the columns from as a numpy array</span>
<span class="sd">        :param vecs: An iterable containing camera points</span>
<span class="sd">        :return: the Jacobian matrix with the unneeded misalignment columns removed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_fix_misalignment</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">local_jac_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">jacobian</span><span class="p">[:,</span> <span class="p">:</span><span class="nb">getattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="s1">&#39;multiple misalignments&#39;</span><span class="p">],</span> <span class="s1">&#39;start&#39;</span><span class="p">)]]</span>

            <span class="n">misalignment_cols</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">[:,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="s1">&#39;multiple misalignments&#39;</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ivecs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vecs</span><span class="p">):</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivecs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="n">local_jac_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">misalignment_cols</span><span class="p">[:,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">ind</span><span class="p">:</span><span class="mi">3</span> <span class="o">*</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_fix_misalignment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_fix_misalignment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">local_jac_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">jacobian</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_update_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_vec</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to fix the update vector when arbitrary images are not included in the calibration and</span>
<span class="sd">        multiple misalignments are being estimated.</span>

<span class="sd">        The update vector is supplemented with 0 values in the locations that correspond to the misalignment for images</span>
<span class="sd">        that were not included in the estimation.  This is necessary to ensure the update is correctly applied to the</span>
<span class="sd">        correct alignments.  The location of the 0 values to insert are determined (a) by the beginning of the alignment</span>
<span class="sd">        updates in the update vec according the the `parameters` input vector and (b) by a list of boolean values in</span>
<span class="sd">        the :attr:`_fix_misalignment` indicating whether 0s need to be added for the image corresponding to the index</span>
<span class="sd">        of the :attr:`_fix_misalignment` list.</span>

<span class="sd">        :param update_vec: delta updates to the model parameters</span>
<span class="sd">        :param parameters: the parameters that correspond to the update vector.</span>
<span class="sd">        :return: the fixed update vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fix_misalignment</span><span class="p">):</span>

            <span class="n">lparameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="c1"># type: ignore</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">lparameters</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="s1">&#39;multiple misalignments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

            <span class="n">misalignment_update</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">update_vec</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

            <span class="n">fixed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fixed</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">update_vec</span><span class="p">[:</span><span class="n">start</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">fix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_misalignment</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">fix</span><span class="p">:</span>

                    <span class="n">fixed</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">fixed</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">misalignment_update</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

                    <span class="n">misalignment_update</span> <span class="o">=</span> <span class="n">misalignment_update</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">update_vec</span>

<div class="viewcode-block" id="PinholeModel.apply_update">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.apply_update.html#giant.camera_models.pinhole_model.PinholeModel.apply_update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_vec</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span> <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes in a delta update to the camera parameters (:math:`\Delta\mathbf{c}`) and applies the update</span>
<span class="sd">        to the current instance in place.</span>

<span class="sd">        In general the delta update is calculated in the estimators in the :mod:`.calibration` subpackage and this</span>
<span class="sd">        method is not used by the user.</span>

<span class="sd">        The order of the update vector is determined by the order of the elements in :attr:`estimation_parameters`.  Any</span>
<span class="sd">        misalignment terms must always call last.</span>

<span class="sd">        This method operates by walking through the elements in :attr:`estimation_parameters` and retrieving the</span>
<span class="sd">        parameter that the element corresponds to.  The value of the ``update_vec`` at the index of the parameter is</span>
<span class="sd">        then applied as an additive update to the parameter in self, with the exception of misalignment, which is</span>
<span class="sd">        applied as a multiplicative update.</span>

<span class="sd">        :param update_vec: An iterable of delta updates to the model parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jacobian_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="n">element</span><span class="p">],</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_dict</span><span class="p">[</span><span class="n">element</span><span class="p">])</span>
                                         <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">])</span>

        <span class="n">update_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">update_vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        
        <span class="n">update_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_update_vector</span><span class="p">(</span><span class="n">update_vec</span><span class="p">,</span> <span class="n">jacobian_parameters</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jacobian_parameters</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kx</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ky</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">px</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">py</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">a3</span> <span class="o">+=</span> <span class="n">update_vec</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">parameter</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">or</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s1">&#39;8:&#39;</span><span class="p">:</span>

                <span class="n">misalignment_updates</span> <span class="o">=</span> <span class="n">update_vec</span><span class="p">[</span><span class="n">ind</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Rotation</span><span class="p">(</span><span class="n">update</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span><span class="o">.</span><span class="n">vector</span>
                                         <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">update</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">misalignment_updates</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">Rotation</span><span class="p">(</span><span class="n">misalignment_updates</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">vector</span>

                <span class="k">break</span></div>


<div class="viewcode-block" id="PinholeModel.prepare_interp">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.prepare_interp.html#giant.camera_models.pinhole_model.PinholeModel.prepare_interp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixel_bounds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">temperature_bounds</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
                       <span class="n">temperature_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method prepares a SciPy RegularGridInterpolator for converting pixels into undistorted gnomic locations.</span>

<span class="sd">        This is done by making calls to :meth:`pixels_to_unit` to compute the transformation at every pixel in the</span>
<span class="sd">        detector plus/minus the pixel bounds and for each temperature in the temperature bounds using the</span>
<span class="sd">        temperature step. (That is: ``cols = np.arange(-pixel_bounds, self.n_cols+pixel_bounds)``,</span>
<span class="sd">        ``rows=np.arange(-pixel_bounds, self.n_rows+pixel_bounds)``,</span>
<span class="sd">        ``temps = np.arange(temperature_bounds[0], temperature_bounds[1]+temperature_step, temperature_step)``.)</span>

<span class="sd">        This method will likely take a little while to run, but only needs to be run once and then the results are saved</span>
<span class="sd">        for future use, including if the camera model is dumped to a file.</span>

<span class="sd">        :param pixel_bounds: An integer specifying how many pixels to pad when computing the transformation to gnomic</span>
<span class="sd">                             locations.</span>
<span class="sd">        :param temperature_bounds: A tuple specifying the temperature bounds to compute the transformation over</span>
<span class="sd">                                   (inclusive).  If none of :attr:`temperature_coefficients` are non-zero then this is</span>
<span class="sd">                                   ignored.</span>
<span class="sd">        :param temperature_step: An integer specifying the temperature step size to compute the transformation to gnomic</span>
<span class="sd">                                 locations over.  If none of :attr:`temperature_coefficients` are non-zero then this is</span>
<span class="sd">                                 ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">col_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">pixel_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">+</span> <span class="n">pixel_bounds</span><span class="p">)</span>
        <span class="n">row_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">pixel_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span> <span class="o">+</span> <span class="n">pixel_bounds</span><span class="p">)</span>
        <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">col_labels</span><span class="p">,</span> <span class="n">row_labels</span><span class="p">)</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cols</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">rows</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">temperature_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">temperature_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temperature_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">temperature_step</span><span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="n">temperature_labels</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixels_to_gnomic</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">temp</span><span class="p">)))</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">((</span><span class="n">rows</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temperature_labels</span><span class="p">),</span> <span class="n">results</span><span class="p">,</span>
                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span>
                <span class="p">(</span><span class="n">rows</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels_to_gnomic</span><span class="p">(</span><span class="n">pix</span><span class="p">))</span></div>


<div class="viewcode-block" id="PinholeModel.pixels_to_gnomic_interp">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.pixels_to_gnomic_interp.html#giant.camera_models.pinhole_model.PinholeModel.pixels_to_gnomic_interp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pixels_to_gnomic_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes an input in pixels and approximates the undistorted gnomic location in units of distance.</span>

<span class="sd">        This approximating is done by interpolating values previously computed using :meth:`pixels_to_gnomic` and</span>
<span class="sd">        :meth:`prepare_interp` and will in general run much faster than :meth:`pixels_to_gnomic`.  It should usually be</span>
<span class="sd">        accurate to better than a few thousandths of a pixel for any pixels within the field of view.  The interpolation</span>
<span class="sd">        is done using SciPy&#39;s RegularGridInterpolator with a linear interpolation scheme.</span>

<span class="sd">        :param pixels: The pixels to be converted as a shape (2,) or (2, n) Sequence</span>
<span class="sd">        :param temperature: The temperature for perform the conversion at.</span>
<span class="sd">        :return: The undistorted gnomic location of the points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;prepare_interp must be called before pixels_to_gnomic_interp&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature_coefficients</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pixels</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">temperature</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">pixels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]))</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">pixels</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="PinholeModel.pixels_to_gnomic">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.pixels_to_gnomic.html#giant.camera_models.pinhole_model.PinholeModel.pixels_to_gnomic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pixels_to_gnomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_allow_interp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes an input in pixels and computes the undistorted gnomic location in units of distance.</span>

<span class="sd">        This conversion is done iteratively (when there is a distortion model involved).  First, the pixel locations</span>
<span class="sd">        are converted to units of distance and re-centered at the principal point by multiplying by the inverse</span>
<span class="sd">        intrinsic matrix.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{x}_I&#39;=\mathbf{K}^{-1}\left[\begin{array}{c} \mathbf{x}_P \\ 1 \end{array}\right]</span>

<span class="sd">        Next, if there is a distortion model, the distortion is removed iteratively using a fixed point algorithm.</span>

<span class="sd">        .. math::</span>
<span class="sd">           \mathbf{x}_{Ip}&#39; = d(\mathbf{x}_{Ip}) \\</span>
<span class="sd">           \mathbf{x}_{In} = \mathbf{x}_{Ip} + (\mathbf{x}_I&#39; - \mathbf{x}_{Ip}&#39;)</span>

<span class="sd">        where a subscript of :math:`p` indicates the previous iteration&#39;s value, a subscript of :math:`n` indicates</span>
<span class="sd">        the new value, and :math:`d()` is the distortion model (method :meth:`apply_distortion`).  This iteration is</span>
<span class="sd">        repeated until the solution converges, or 20 iterations have been performed.</span>

<span class="sd">        The final iteration&#39;s value of the undistorted gnomic points are returned.</span>

<span class="sd">        :param pixels: The pixels to be converted as a shape (2,) or (2, n) Sequence</span>
<span class="sd">        :param temperature: The temperature for perform the conversion at.</span>
<span class="sd">        :param _allow_interp: A flag allowing this to dispatch to the interpolation based conversion in</span>
<span class="sd">                              :meth:`pixels_to_gnomic_interp`</span>
<span class="sd">        :return: The undistorted gnomic location of the points</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">_allow_interp</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels_to_gnomic_interp</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># warn(&quot;Attempted a call to pixels_to_gnomic_interp but prepare_interp hasn&#39;t been called yet.&quot;</span>
                <span class="c1">#      &quot;Falling back to the regular method&quot;)</span>
                <span class="k">pass</span>

        <span class="c1"># get the distorted gnomic location of the points by multiplying by the inverse camera matrix and dividing by</span>
        <span class="c1"># the temperature scale</span>
        <span class="n">gnomic_distorted</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">pixels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">gnomic_distorted</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># initialize the fpa guess to be the distorted gnomic location</span>
        <span class="n">gnomic_guess</span> <span class="o">=</span> <span class="n">gnomic_distorted</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># perform the fpa</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>

            <span class="c1"># get the distorted location assuming the current guess is correct</span>
            <span class="n">gnomic_guess_distorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_distortion</span><span class="p">(</span><span class="n">gnomic_guess</span><span class="p">)</span>

            <span class="c1"># subtract off the residual distortion from the gnomic guess</span>
            <span class="n">gnomic_guess</span> <span class="o">+=</span> <span class="n">gnomic_distorted</span> <span class="o">-</span> <span class="n">gnomic_guess_distorted</span>

            <span class="c1"># check for convergence</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gnomic_guess_distorted</span> <span class="o">-</span> <span class="n">gnomic_distorted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-15</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="c1"># return the new gnomic location</span>
        <span class="k">return</span> <span class="n">gnomic_guess</span></div>


<div class="viewcode-block" id="PinholeModel.undistort_pixels">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.undistort_pixels.html#giant.camera_models.pinhole_model.PinholeModel.undistort_pixels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">undistort_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allow_interp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes undistorted pixel locations (gnomic/pinhole locations) for given distorted</span>
<span class="sd">        pixel locations according to the current model.</span>

<span class="sd">        This method operates by calling :meth:`pixels_to_gnomic` and then re-transforming the undistorted gnomic</span>
<span class="sd">        location into an undistorted pixel location using the :attr:`intrinsic_matrix`.</span>

<span class="sd">        The ``pixels`` input should be specified as a shape (2,) or (2, n) array of image locations with units of</span>
<span class="sd">        pixels.  The return will be an array of the same shape as ``pixels`` with units of pixels but with distortion</span>
<span class="sd">        removed.</span>

<span class="sd">        :param pixels: The image points to be converted to gnomic (pinhole) locations as a shape (2,) or (2, n) array</span>
<span class="sd">        :param temperature: The temperature to use for the undistortion</span>
<span class="sd">        :param allow_interp: Allow the approximate conversion using interpolation for speed</span>
<span class="sd">        :return: The undistorted (gnomic) locations corresponding to the distorted pixel locations as an array of</span>
<span class="sd">                 the same shape as ``pixels``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the undistorted gnomic location</span>
        <span class="n">gnomic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels_to_gnomic</span><span class="p">(</span>
            <span class="n">pixels</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">_allow_interp</span><span class="o">=</span><span class="n">allow_interp</span><span class="p">)</span>

        <span class="c1"># scale by the temperature</span>
        <span class="n">gnomic</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># put back into pixel space using the intrinsic matrix</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">gnomic</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="PinholeModel.pixels_to_unit">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.pixels_to_unit.html#giant.camera_models.pinhole_model.PinholeModel.pixels_to_unit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pixels_to_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">F_ARRAY_LIKE</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                       <span class="n">allow_interp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method converts pixel image locations to unit vectors expressed in the camera frame.</span>

<span class="sd">        The pixel locations should be expressed as a shape (2,) or (2, n) array.  They are converted</span>
<span class="sd">        to unit vectors by first going through the inverse distortion model (see :meth:`pixels_to_gnomic`) and then</span>
<span class="sd">        being converted to unit vectors in the camera frame according to the definitions of the current model (also</span>
<span class="sd">        including any misalignment terms).  Once the gnomic locations are retrieved using :meth:`pixels_to_gnomic`, the</span>
<span class="sd">        unit vectors are formed according to</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{x}_C = \mathbf{T}_{\boldsymbol{\delta\theta}}^T\left[\begin{array}{c} \mathbf{x}_I \\ f</span>
<span class="sd">            \end{array}\right] \\</span>
<span class="sd">            \hat{\mathbf{x}}_C = \frac{\mathbf{x}_C}{\|\mathbf{x}_C\|}</span>

<span class="sd">        where :math:`\mathbf{T}_{\boldsymbol{\delta\theta}}^T` is the inverse rotation matrix for the misalignment</span>
<span class="sd">        for the image.</span>

<span class="sd">        :param pixels: The image points to be converted to unit vectors in the camera frame as a shape (2,) or (2, n)</span>
<span class="sd">                       array</span>
<span class="sd">        :param temperature: The temperature to use for the undistortion</span>
<span class="sd">        :param image: The image index that the pixel belong to (only important if there are multiple misalignments)</span>
<span class="sd">        :param allow_interp: Allow the approximate conversion using interpolation for speed</span>
<span class="sd">        :return: The unit vectors corresponding to the image locations expressed in the camera frame as a shape (3,) or</span>
<span class="sd">                 (3, n) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>

        <span class="c1"># get the undistorted gnomic locations</span>
        <span class="n">gnomic_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixels_to_gnomic</span><span class="p">(</span>
            <span class="n">pixels</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">_allow_interp</span><span class="o">=</span><span class="n">allow_interp</span><span class="p">)</span>

        <span class="c1"># append the focal length</span>
        <span class="k">if</span> <span class="n">pixels</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">los_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">gnomic_locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">los_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">gnomic_locs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">pixels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])</span>

        <span class="c1"># apply misalignment to the unit vectors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="c1"># optimization to avoid matrix multiplication</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">]):</span>
                <span class="n">los_vectors</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">los_vectors</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">):</span>  <span class="c1"># optimization to avoid matrix multiplication</span>
                <span class="n">los_vectors</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">los_vectors</span>

        <span class="c1"># convert to unit vector and return</span>
        <span class="k">return</span> <span class="n">los_vectors</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">los_vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="PinholeModel.distort_pixels">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.distort_pixels.html#giant.camera_models.pinhole_model.PinholeModel.distort_pixels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distort_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A method that takes gnomic pixel locations in units of pixels and applies the appropriate distortion to them.</span>

<span class="sd">        This method is used in the :meth:`distortion_map` method to generate the distortion values for each pixel.</span>

<span class="sd">        The distortion is applied by first converting the pixels to gnomic location by multiplying by the inverse camera</span>
<span class="sd">        matrix, second applying the distortion to the gnomic locations using :meth:`apply_distortion`, and third</span>
<span class="sd">        reconverting to pixel units using the :attr:`intrinsic_matrix` and temperature scale.</span>

<span class="sd">        In general this method is not used directly by the user and instead the :meth:`distortion_map` method is used</span>
<span class="sd">        to generate a distortion map for the camera model</span>

<span class="sd">        :param pixels: The pinhole location pixel locations the distortion is to be applied to</span>
<span class="sd">        :param temperature:  The temperature to perform the distortion at</span>
<span class="sd">        :return: The distorted pixel locations in units of pixels</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the scale for the current temperature</span>
        <span class="n">temp_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_temperature_scale</span><span class="p">(</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># get the gnomic location using the inverse intrinsic matrix and temperature scale</span>
        <span class="n">gnomic</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">pixels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix_inv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">gnomic</span> <span class="o">/=</span> <span class="n">temp_scale</span>

        <span class="c1"># apply the distortion</span>
        <span class="n">gnomic_distorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_distortion</span><span class="p">(</span><span class="n">gnomic</span><span class="p">)</span>

        <span class="c1"># reconvert to pixel units and return</span>
        <span class="n">gnomic_distorted</span> <span class="o">*=</span> <span class="n">temp_scale</span>

        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">gnomic_distorted</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intrinsic_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>


    <span class="c1"># noinspection PyProtectedMember</span>
<div class="viewcode-block" id="PinholeModel.to_elem">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.to_elem.html#giant.camera_models.pinhole_model.PinholeModel.to_elem">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span><span class="p">,</span> <span class="n">misalignment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">etree</span><span class="o">.</span><span class="n">_Element</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores this camera model in an :class:`etree._Element` object for storing in a GIANT xml file</span>

<span class="sd">        :param elem: The :class:`etree._Element` class to store this camera model in</span>
<span class="sd">        :param misalignment: A flag about whether to include the misalignment in the :class:`etree._Element`</span>
<span class="sd">        :return: The :class:`etree._Element` for this model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store a copy of self as it currently is</span>
        <span class="n">copy_of_self</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">PinholeModel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># if we don&#39;t want to include the misalignment in the save file then set</span>
        <span class="c1"># estimation parameters to only include a single misalignment</span>
        <span class="c1"># and set the misalignment to be zero</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">misalignment</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;multiple misalignments&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="p">:</span>
                <span class="c1"># noinspection PyUnresolvedReferences</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;multiple misalignments&#39;</span><span class="p">)</span>
                <span class="c1"># noinspection PyUnresolvedReferences</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimation_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;single misalignment&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># store the model into the element</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

        <span class="c1"># reset self to the way it was</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="n">copy_of_self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">elem</span></div>


<div class="viewcode-block" id="PinholeModel.reset_misalignment">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.reset_misalignment.html#giant.camera_models.pinhole_model.PinholeModel.reset_misalignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_misalignment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method reset the misalignment terms to all be zero (no misalignment).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="n">new_misalignment</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_misalignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span> <span class="o">=</span> <span class="n">new_misalignment</span></div>


<div class="viewcode-block" id="PinholeModel.get_misalignment">
<a class="viewcode-back" href="../../../pinhole_model/giant.camera_models.pinhole_model.PinholeModel.get_misalignment.html#giant.camera_models.pinhole_model.PinholeModel.get_misalignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_misalignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the Rotation object for the misalignment for the requested image.</span>

<span class="sd">        :param image: the image number to get the misalignment for</span>
<span class="sd">        :return: The :class:`.Rotation` representing the misalignment between the camera frame and the actual image</span>
<span class="sd">                 frame for projection.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_multiple_misalignments</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">[</span><span class="n">image</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">misalignment</span><span class="p">)</span></div>

            
    <span class="k">def</span><span class="w"> </span><span class="nf">check_in_fov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if any points in the array are within the field of view of the camera.</span>

<span class="sd">        :param vectors: Vectors to check if they are in the field of view of the camera expressed as a shape (3, n) array in the camera frame.  </span>
<span class="sd">        :param image: The index of the image being projected onto (only applicable with multiple misalignments)</span>
<span class="sd">        :param temperature: The temperature of the camera to use for the projection</span>
<span class="sd">        :return: A boolean array the same length as the number of columns of vectors. False by default, True if the point is in the FOV.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="n">in_fov</span> <span class="o">=</span> <span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \
                 <span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pixels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span>

        <span class="c1"># the camera models break down at extremes so also spot check the angular FOV</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">@</span> <span class="n">vectors</span><span class="p">[:,</span> <span class="n">in_fov</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vectors</span><span class="p">[:,</span> <span class="n">in_fov</span><span class="p">],</span>
                                                                                         <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                                         <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">*</span>
                  <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_of_view</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># get the FOV computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_field_of_view</span><span class="p">(</span><span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
            
        <span class="n">in_fov</span><span class="p">[</span><span class="n">in_fov</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">&lt;</span> <span class="mf">1.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_of_view</span>

        <span class="k">return</span> <span class="n">in_fov</span></div>

       
        
<span class="k">class</span><span class="w"> </span><span class="nc">CircularPinholeModel</span><span class="p">(</span><span class="n">PinholeModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class overrides the :class:`.PinholeModel` to reimplement the :meth:`.check_in_fov` method to only check the angle between the </span>
<span class="sd">    boresight and the target vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_in_fov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if any points in the array are within the field of view of the camera.</span>
<span class="sd">        </span>
<span class="sd">        :param vectors: Vectors to check if they are in the field of view of the camera expressed as a shape (3, n) array in the camera frame.  </span>
<span class="sd">        :param image: ignored</span>
<span class="sd">        :param temperature: used to compute the field of view if the field of view is not specified</span>
<span class="sd">        :return: A boolean array the same length as the number of columns of vectors. False by default, True if the point is in the FOV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the camera models break down at extremes so also spot check the angular FOV</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">@</span> <span class="n">vectors</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span>
                                                                             <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                             <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="o">*</span>
                  <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_of_view</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># get the FOV computed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_field_of_view</span><span class="p">(</span><span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
            
        <span class="n">in_fov</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_of_view</span>

        <span class="k">return</span> <span class="n">in_fov</span>
            

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>