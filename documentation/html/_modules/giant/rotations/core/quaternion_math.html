<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.rotations.core.quaternion_math &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../index.html">
    <img class="logo" src="../../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.rotations.core.quaternion_math</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>  

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">DatetimeLike</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations.core._helpers</span><span class="w"> </span><span class="kn">import</span> <span class="n">_check_quaternion_array_and_shape</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;quaternion_normalize&quot;</span><span class="p">,</span> <span class="s2">&quot;quaternion_inverse&quot;</span><span class="p">,</span> <span class="s2">&quot;quaternion_multiplication&quot;</span><span class="p">,</span> <span class="s2">&quot;nlerp&quot;</span><span class="p">,</span> <span class="s2">&quot;slerp&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="quaternion_normalize">
<a class="viewcode-back" href="../../../../rotations/core/quaternion_math/giant.rotations.core.quaternion_math.quaternion_normalize.html#giant.rotations.core.quaternion_math.quaternion_normalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">quaternion_normalize</span><span class="p">(</span><span class="n">quaternion</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalizes the quaternion(s) such that the scalar term is positive and the length is 1</span>
<span class="sd">    </span>
<span class="sd">    :param quaternion: the quaternion(s) to normalize</span>
<span class="sd">    </span>
<span class="sd">    :returns: The normalized quaternions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">work_quaternion</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion</span><span class="p">)</span>
    
    <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">work_quaternion</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">signs</span><span class="p">):</span>
        <span class="n">signs</span><span class="p">[</span><span class="n">signs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">signs</span> <span class="o">=</span> <span class="n">signs</span> <span class="k">if</span> <span class="n">signs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        
    <span class="n">work_quaternion</span> <span class="o">*=</span> <span class="n">signs</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">work_quaternion</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">work_quaternion</span></div>



<div class="viewcode-block" id="quaternion_inverse">
<a class="viewcode-back" href="../../../../rotations/core/quaternion_math/giant.rotations.core.quaternion_math.quaternion_inverse.html#giant.rotations.core.quaternion_math.quaternion_inverse">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">quaternion_inverse</span><span class="p">(</span><span class="n">quaternion</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function provides the inverse of a rotation quaternion of the form discussed in</span>
<span class="sd">    :ref:`Rotation Representations &lt;rotation-representation-table&gt;`.</span>

<span class="sd">    The inverse of a rotation quaternion is defined such that</span>
<span class="sd">    :math:`\mathbf{q}\otimes\mathbf{q}^{-1}=\mathbf{q}_I` where</span>
<span class="sd">    :math:`\mathbf{q}_I=\left[\begin{array}{cccc}0&amp;0&amp;0&amp;1\end{array}\right]^T` is the identity quaternion which</span>
<span class="sd">    corresponds to the identity matrix (or no rotation) and :math:`\otimes` indicates quaternion multiplication.</span>
<span class="sd">    Mathematically this corresponds to negating the vector portion of the quaternion:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{q}=\left[\begin{array}{c}\text{sin}(\frac{\theta}{2})\hat{\mathbf{x}}\\</span>
<span class="sd">        \text{cos}(\frac{\theta}{2})\end{array}\right]\\</span>
<span class="sd">        \mathbf{q}^{-1}=\left[\begin{array}{c}-\text{sin}(\frac{\theta}{2})\hat{\mathbf{x}}\\</span>
<span class="sd">        \text{cos}(\frac{\theta}{2})\end{array}\right]</span>

<span class="sd">    This function is also vectorized, meaning that you can specify multiple rotation quaternions to be inversed by</span>
<span class="sd">    specifying each quaternion as a column.  Regardless of whether you are converting 1 or many</span>
<span class="sd">    quaternions the first axis must have a length of 4.</span>

<span class="sd">    This function makes the output have the same number of dimensions as the input.  Therefore, if the input is one</span>
<span class="sd">    dimensional, then the output is one dimensional, and if the input is two dimensional then the output will be two</span>
<span class="sd">    dimensional. </span>

<span class="sd">    :param quaternion: The rotation quaternion(s) to be inverted</span>
<span class="sd">    :return: a numpy array representing the inverse quaternion corresponding to the input quaternion</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># ensure the value is an array and break mutability</span>
    <span class="n">quaternion</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">return_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># negate the vector portion</span>
    <span class="n">quaternion</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># return the inverse quaternion(s) as an array</span>
    <span class="k">return</span> <span class="n">quaternion</span></div>



<div class="viewcode-block" id="quaternion_multiplication">
<a class="viewcode-back" href="../../../../rotations/core/quaternion_math/giant.rotations.core.quaternion_math.quaternion_multiplication.html#giant.rotations.core.quaternion_math.quaternion_multiplication">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">quaternion_multiplication</span><span class="p">(</span><span class="n">quaternion_1_in</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span>
                              <span class="n">quaternion_2_in</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs the hamiltonian quaternion multiplication operation.</span>

<span class="sd">    The quaternions should be of the form as specified in</span>
<span class="sd">    :ref:`Rotation Representations &lt;rotation-representation-table&gt;`.</span>

<span class="sd">    The hamiltonian multiplication is defined such that</span>
<span class="sd">    `q_from_A_to_C = quaternion_multiplication(q_from_B_to_C, q_from_A_to_B)`</span>

<span class="sd">    Mathematically this is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{q}_1\otimes\mathbf{q}_2=\left[\begin{array}{c}q_{s1}\mathbf{q}_{v2} + q_{s2}\mathbf{q}_{v1} +</span>
<span class="sd">        \mathbf{q}_{v1}\times\mathbf{q}_{v2}\\</span>
<span class="sd">        q_{s1}q_{s2}-\mathbf{q}_{v1}^T\mathbf{q}_{v2}\end{array}\right]</span>

<span class="sd">    This function is vectorized, therefore you can input multiple quaternions as a 4xn array where each column is an</span>
<span class="sd">    independent quaternion.</span>

<span class="sd">    :param quaternion_1_in: The first quaternion to multiply</span>
<span class="sd">    :param quaternion_2_in: The second quaternion to multiply</span>
<span class="sd">    :return: The non-hamiltonian product of quaternion_1 and quaternion_2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rquat</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">quaternion_1</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion_1_in</span><span class="p">)</span>
    <span class="n">quaternion_2</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion_2_in</span><span class="p">)</span>

    <span class="n">qs1</span> <span class="o">=</span> <span class="n">quaternion_1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">qv1</span> <span class="o">=</span> <span class="n">quaternion_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">qs2</span> <span class="o">=</span> <span class="n">quaternion_2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">qv2</span> <span class="o">=</span> <span class="n">quaternion_2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">qout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">qs1</span> <span class="o">*</span> <span class="n">qv2</span> <span class="o">+</span> <span class="n">qs2</span> <span class="o">*</span> <span class="n">qv1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">qv1</span><span class="p">,</span> <span class="n">qv2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                           <span class="p">[</span><span class="n">qs1</span> <span class="o">*</span> <span class="n">qs2</span> <span class="o">-</span> <span class="p">(</span><span class="n">qv1</span> <span class="o">*</span> <span class="n">qv2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qout</span></div>



<div class="viewcode-block" id="nlerp">
<a class="viewcode-back" href="../../../../rotations/core/quaternion_math/giant.rotations.core.quaternion_math.nlerp.html#giant.rotations.core.quaternion_math.nlerp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">nlerp</span><span class="p">(</span><span class="n">quaternion0</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">quaternion1</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span>
          <span class="n">time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DatetimeLike</span><span class="p">,</span>
          <span class="n">time0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DatetimeLike</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">time1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DatetimeLike</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs normalized linear interpolation of rotation quaternions.</span>

<span class="sd">    NLERP of quaternions involves first performing a linear interpolation between the two vectors, and then normalizing</span>
<span class="sd">    the interpolated result to have unit length.  That is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{q}=\frac{\mathbf{q}_0(1-p)+\mathbf{q}_1p}</span>
<span class="sd">        {\left\|\mathbf{q}_0(1-p)+\mathbf{q}_1p\right\|}</span>

<span class="sd">    where :math:`\mathbf{q}` is the interpolated quaternion, :math:`\mathbf{q}_0` is the starting quaternion,</span>
<span class="sd">    :math:`\mathbf{q}_1` is the ending quaternion, and :math:`p` is the fractional percent of the way between</span>
<span class="sd">    :math:`\mathbf{q}_0` and :math:`\mathbf{q}_1` that we want to interpolate at (:math:`p\in[0, 1]`)</span>

<span class="sd">    When using this function you can either specify the argument `time` as the fractional percent that you want to</span>
<span class="sd">    interpolate at, or specify the keyword arguments `time0` and `time1` to be the times corresponding to the first and</span>
<span class="sd">    second quaternion respectively and the function will compute the fractional percent for you.  When using this method</span>
<span class="sd">    it is also possible to specify all three of `time`, `time0`, and `time1` as python datetime objects.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        NLERP is a very fast and efficient interpolation method that is fine for short interpolation intervals; however,</span>
<span class="sd">        it does not perform a constant angular velocity interpolation (and instead performs a constant linear velocity</span>
<span class="sd">        interpolation), therefore it is not well suited to interpolating over long time intervals. If you need to</span>
<span class="sd">        interpolate over larger time intervals it is better to use the :func:`slerp` function which does perform</span>
<span class="sd">        constant angular velocity interpolation (but is less efficient).</span>

<span class="sd">    :param quaternion0: The starting quaternion(s)</span>
<span class="sd">    :param quaternion1: The ending quaternion(s)</span>
<span class="sd">    :param time: The time to interpolate the quaternions at, as a fractional percent or as the actual time between</span>
<span class="sd">                `time0` and `time1`</span>
<span class="sd">    :param time0: the time(s) corresponding to the first quaternion(s). Leave at 0 if you are specifying `time` as a</span>
<span class="sd">                  fractional percent</span>
<span class="sd">    :param time1: the time(s) corresponding to the second quaternion(s). Leave at 1 if you are specifying `time` as a</span>
<span class="sd">                  fractional percent</span>
<span class="sd">    :return: The interpolated quaternion(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="c1"># compute the fractional percent we are interpolating at</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="n">time</span> <span class="o">-</span> <span class="n">time0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">time1</span> <span class="o">-</span> <span class="n">time0</span><span class="p">))</span> <span class="c1"># type: ignore</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;time, time0, and time1 must support subtraction resulting in a type that supports true division.&#39;</span>
                        <span class="s1">&#39;Typically this means they should all be floats or all be DatetimeLike objects&#39;</span><span class="p">)</span>

    <span class="n">rquat</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># extract the quaternion values as arrays </span>
    <span class="n">q0</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion0</span><span class="p">)</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion1</span><span class="p">)</span>

    <span class="c1"># perform the linear interpolation</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">q1</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="c1"># perform the normalization</span>
    <span class="n">q</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># return the interpolated quaternion(s)</span>
    <span class="k">return</span> <span class="n">q</span></div>



<div class="viewcode-block" id="slerp">
<a class="viewcode-back" href="../../../../rotations/core/quaternion_math/giant.rotations.core.quaternion_math.slerp.html#giant.rotations.core.quaternion_math.slerp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">slerp</span><span class="p">(</span><span class="n">quaternion0</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">quaternion1</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span>
          <span class="n">time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DatetimeLike</span><span class="p">,</span>
          <span class="n">time0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DatetimeLike</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">time1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">DatetimeLike</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs spherical linear interpolation of rotation quaternions.</span>

<span class="sd">    SLERP of quaternions involves performing a linear interpolation along the great circle arc connecting the two</span>
<span class="sd">    quaternions. That is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \omega = \text{cos}^{-1}(\mathbf{q}_0^T\mathbf{q}_1)\\</span>
<span class="sd">        \mathbf{q}=\mathbf{q}_0\text{cos}(p\omega)+</span>
<span class="sd">        \text{sin}(p\omega)\frac{\mathbf{q}_1-\mathbf{q}_0\text{cos}(\omega)}</span>
<span class="sd">        {\left\|\mathbf{q}_1-\mathbf{q}_0\text{cos}(\omega)\right\|}\\</span>
<span class="sd">        \mathbf{q} = \frac{\mathbf{q}}{\left\|\mathbf{q}\right\|}</span>

<span class="sd">    where :math:`\mathbf{q}` is the interpolated quaternion, :math:`\mathbf{q}_0` is the starting quaternion,</span>
<span class="sd">    :math:`\mathbf{q}_1` is the ending quaternion, :math:`\omega` is the angle between the first and second quaternion,</span>
<span class="sd">    and :math:`p` is the fractional percent of the way between</span>
<span class="sd">    :math:`\mathbf{q}_0` and :math:`\mathbf{q}_1` that we want to interpolate at (:math:`p\in[0, 1]`)</span>

<span class="sd">    When using this function you can either specify the argument `time` as the fractional percent that you want to</span>
<span class="sd">    interpolate at, or specify the keyword arguments `time0` and `time1` to be the times corresponding to the first and</span>
<span class="sd">    second quaternion respectively and the function will compute the fractional percent for you.  When using this method</span>
<span class="sd">    it is also possible to specify all three of `time`, `time0`, and `time1` as python datetime objects.</span>

<span class="sd">    :param quaternion0: The starting quaternion(s)</span>
<span class="sd">    :param quaternion1: The ending quaternion(s)</span>
<span class="sd">    :param time: The time to interpolate the quaternions at, as a fractional percent or as the actual time between</span>
<span class="sd">                `time0` and `time1`</span>
<span class="sd">    :param time0: the time(s) corresponding to the first quaternion(s). Leave at 0 if you are specifying `time` as a</span>
<span class="sd">                  fractional percent</span>
<span class="sd">    :param time1: the time(s) corresponding to the second quaternion(s). Leave at 1 if you are specifying `time` as a</span>
<span class="sd">                  fractional percent</span>
<span class="sd">    :return: The interpolated quaternion(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># compute the fractional percent we are interpolating at</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="n">time</span> <span class="o">-</span> <span class="n">time0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">time1</span> <span class="o">-</span> <span class="n">time0</span><span class="p">))</span> <span class="c1"># type: ignore</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;time, time0, and time1 must support subtraction resulting in a type that supports true division.&#39;</span>
                        <span class="s1">&#39;Typically this means they should all be floats or all be DatetimeLike objects&#39;</span><span class="p">)</span>

    <span class="c1"># extract the quaternion values as arrays </span>
    <span class="n">q0</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion0</span><span class="p">)</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">_check_quaternion_array_and_shape</span><span class="p">(</span><span class="n">quaternion1</span><span class="p">)</span>

    <span class="c1"># enforce unit normalization</span>
    <span class="n">q0</span> <span class="o">=</span> <span class="n">quaternion_normalize</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">quaternion_normalize</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>

    <span class="c1"># get the cosine of the angle between the quaternions</span>
    <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cos_angle</span> <span class="o">&gt;</span> <span class="mf">0.9995</span><span class="p">:</span>
        <span class="c1"># if the quaternions are really close revert to nlerp</span>
        <span class="k">return</span> <span class="n">nlerp</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">cos_angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># if the dot product is negative negate the second quaternion to ensure the shorter path is taken</span>
        <span class="n">q1</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">cos_angle</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cos_angle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># ensure the domain for acos (only will leave due to numerical issues)</span>

    <span class="n">angle0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_angle</span><span class="p">)</span>  <span class="c1"># angle between q0 and q1</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">angle0</span> <span class="o">*</span> <span class="n">dt</span>  <span class="c1"># angle between q0 and q</span>

    <span class="c1"># form an orthonormal basis</span>
    <span class="n">qb</span> <span class="o">=</span> <span class="n">q1</span> <span class="o">-</span> <span class="n">q0</span> <span class="o">*</span> <span class="n">cos_angle</span>

    <span class="n">qb</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>

    <span class="c1"># perform the interpolation</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">+</span> <span class="n">qb</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">q</span></div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>