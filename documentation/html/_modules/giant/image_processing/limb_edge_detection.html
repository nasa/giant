<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.image_processing.limb_edge_detection &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.image_processing.limb_edge_detection</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span> 

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image_processing.edge_detection</span><span class="w"> </span><span class="kn">import</span> <span class="n">PAESubpixelEdgeDetector</span><span class="p">,</span> <span class="n">PAESubpixelEdgeDetectorOptions</span><span class="p">,</span> \
                                                  <span class="n">ZernikeRampEdgeDetector</span><span class="p">,</span> <span class="n">ZernikeRampEdgeDetectorOptions</span><span class="p">,</span> \
                                                  <span class="n">PixelEdgeDetector</span><span class="p">,</span> <span class="n">EdgeDetectionMethods</span><span class="p">,</span> <span class="n">EdgeDetector</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image_processing.otsu</span><span class="w"> </span><span class="kn">import</span> <span class="n">otsu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.outlier_identifier</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_outliers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.options</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.user_option_configured</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserOptionConfigured</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.attribute_equality_comparison</span><span class="w"> </span><span class="kn">import</span> <span class="n">AttributeEqualityComparison</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.attribute_printing</span><span class="w"> </span><span class="kn">import</span> <span class="n">AttributePrinting</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>


<div class="viewcode-block" id="LimbEdgeDetectionOptions">
<a class="viewcode-back" href="../../../image_processing/limb_edge_detection/giant.image_processing.limb_edge_detection.LimbEdgeDetectionOptions.html#giant.image_processing.limb_edge_detection.LimbEdgeDetectionOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LimbEdgeDetectionOptions</span><span class="p">(</span><span class="n">UserOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This dataclass specifies the options which control how limbs are identified using edge detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">edge_detection_type</span><span class="p">:</span> <span class="n">EdgeDetectionMethods</span> <span class="o">=</span> <span class="n">EdgeDetectionMethods</span><span class="o">.</span><span class="n">ZERNIKE_RAMP_EDGE_DETECTOR</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The edge detection type to use.</span>
<span class="sd">    </span>
<span class="sd">    If this is set to :attr:`.EdgeDetectionMethods.CUSTOM_DETECTOR` then the :attr:`custom_edge_detection_class` must be specified.</span>
<span class="sd">    </span>
<span class="sd">    If this is set to :attr:`.EdgeDetectionMethods.CUSTOM_DETECTOR`, :attr:`.EdgeDetectionMethods.PAE_SUBPIXEL_EDGE_DETECTOR` or :attr:`.EdgeDetectionMethods.ZERNIKE_RAMPE_EDGE_DETECTOR`</span>
<span class="sd">    then you can configure the detector using the :attr:`edge_detection_options` attribute.</span>
<span class="sd">    </span>
<span class="sd">    From this class, we only use the :meth:`.EdgeDetector.refine_edges` method to refine the pixel level limb points we detected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">custom_edge_detection_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">EdgeDetector</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A custom edge detector class implementing the :class:`.EdgeDetector` API.</span>
<span class="sd">    </span>
<span class="sd">    This will be initialized by providing the &quot;attr:`edge_detection_options` attribute as the only argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">edge_detection_options</span><span class="p">:</span> <span class="nb">object</span> <span class="o">|</span> <span class="n">ZernikeRampEdgeDetectorOptions</span> <span class="o">|</span> <span class="n">PAESubpixelEdgeDetectorOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The options dataclass to initialize the edge detector with.</span>
<span class="sd">    </span>
<span class="sd">    This is provided as the only argument to initialization if the :attr:`edge_detection_type` is set to anything by :attr:`.EdgeDetectionMethods.PIXEL_EDGE_DETECTOR`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The step size to sample limb points at in units of pixels </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">surround_check_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    How many pixels to use before/after the limb in the sun direction to check that the intensity changes from darker to brighter (indicating an illuminated limb).</span>
<span class="sd">    </span>
<span class="sd">    That is, we will check that the median of image intensity of the previous `surround_check_size` pixels along the scan line is lower than the median of the </span>
<span class="sd">    image intensity of the next `surround_check_size` pixels along the scan line.</span>
<span class="sd">    </span>
<span class="sd">    If this is set to `None` then we use approximately 1/8 of the length of the scan line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">minimum_surround_check_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The minimum number of pixels before/after the limb to include in checking that the image goes from dark to light at the limb point.</span>
<span class="sd">    </span>
<span class="sd">    If there are not this many pixels before or after a potential limb to check (due to being close to the boundary of the image) then </span>
<span class="sd">    the potential limb is discarded.  Therefore, you want this to be a decent size so you can get a reasonable sense of the intensity </span>
<span class="sd">    before/after the potential limb point, but if set too large too many true limbs could be unnecessarily discarded.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

    
    
<div class="viewcode-block" id="LimbEdgeDetection">
<a class="viewcode-back" href="../../../image_processing/limb_edge_detection/giant.image_processing.limb_edge_detection.LimbEdgeDetection.html#giant.image_processing.limb_edge_detection.LimbEdgeDetection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LimbEdgeDetection</span><span class="p">(</span><span class="n">UserOptionConfigured</span><span class="p">[</span><span class="n">LimbEdgeDetectionOptions</span><span class="p">],</span> 
                        <span class="n">LimbEdgeDetectionOptions</span><span class="p">,</span>
                        <span class="n">AttributePrinting</span><span class="p">,</span>
                        <span class="n">AttributeEqualityComparison</span><span class="p">):</span>
    
    <span class="n">edge_detector</span><span class="p">:</span> <span class="n">EdgeDetector</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">LimbEdgeDetectionOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">LimbEdgeDetectionOptions</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="c1"># set up the edge detector</span>
        <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_type</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">EdgeDetectionMethods</span><span class="o">.</span><span class="n">PIXEL_EDGE_DETECTOR</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span> <span class="o">=</span> <span class="n">PixelEdgeDetector</span><span class="p">()</span>
            <span class="k">case</span> <span class="n">EdgeDetectionMethods</span><span class="o">.</span><span class="n">PAE_SUBPIXEL_EDGE_DETECTOR</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span><span class="p">,</span> <span class="n">PAESubpixelEdgeDetectorOptions</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;edge_detection_options must be None or an instance of PAESubpixelEdgeDetectorOptions to use the PAE_SUBPIXEL_EDGE_DETECTOR&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span> <span class="o">=</span> <span class="n">PAESubpixelEdgeDetector</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">EdgeDetectionMethods</span><span class="o">.</span><span class="n">ZERNIKE_RAMP_EDGE_DETECTOR</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span><span class="p">,</span> <span class="n">ZernikeRampEdgeDetectorOptions</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;edge_detection_options must be None or an instance of ZernikeRampEdgeDetectorOptions to use the ZERNIKE_RAMP_EDGE_DETECTOR&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span> <span class="o">=</span> <span class="n">ZernikeRampEdgeDetector</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">EdgeDetectionMethods</span><span class="o">.</span><span class="n">CUSTOM_DETECTOR</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_edge_detection_class</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_edge_detection_class</span><span class="p">,</span> <span class="n">EdgeDetector</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;custom_edge_detection_class must be specified as a subclass of EdgeDetecto if CUSTOM_DETECTOR is chosen&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_edge_detection_class</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_detection_options</span><span class="p">)</span>

<div class="viewcode-block" id="LimbEdgeDetection.identify_subpixel_limbs">
<a class="viewcode-back" href="../../../image_processing/limb_edge_detection/giant.image_processing.limb_edge_detection.LimbEdgeDetection.html#giant.image_processing.limb_edge_detection.LimbEdgeDetection.identify_subpixel_limbs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">identify_subpixel_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">num_objs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies illuminated limbs in an image to sub-pixel accuracy.</span>

<span class="sd">        The input to this method is the image to have the limbs extracted from, the illumination direction in the image,</span>
<span class="sd">        and the number of objects that limbs are to be extracted from in the image.  The output is a list of arrays</span>
<span class="sd">        or subpixel limb points with each element of the list being a 2d array of the limb points for the</span>
<span class="sd">        i\ :sup:`th` object. The limb arrays are 2xn where n is the number of limb points and the first row</span>
<span class="sd">        corresponds to the x locations of the limb points in the image and the second row corresponds to the y</span>
<span class="sd">        locations of the limb points in the image.</span>

<span class="sd">        This method works by first thresholding the image to extract the foreground objects from the background using</span>
<span class="sd">        the :func:`otsu` function, and then identifying complete objects using connected components.  For each connected</span>
<span class="sd">        object up to `num_objs` objects, the limb points are extracted by scanning along the `illum_dir` vector to the</span>
<span class="sd">        first edge pixel encountered.  Then the edge level pixels are refined to subpixel accuracy  using one of the</span>
<span class="sd">        subpixel edge detection routines.</span>

<span class="sd">        :param image: The image to have the limbs extracted from</span>
<span class="sd">        :param illum_dir:  The direction of the incoming sunlight in the image</span>
<span class="sd">        :param num_objs: The number of objects to extract limbs from</span>
<span class="sd">        :return: A list of 2D arrays containing the xy subpixel limb points for each object in the image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert the image to uint8 if it isn&#39;t already</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">*=</span> <span class="mi">255</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># first, try to split the image into 4 bins with Otsu thresholding</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># get the number of pixels in each threshold level</span>
        <span class="n">num_pix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
        
        <span class="c1"># check for outliers</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">num_pix</span><span class="p">,</span> <span class="n">sigma_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># handle the outliers</span>
        <span class="k">if</span> <span class="n">outliers</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># check if levels 2 and 3 are also noise</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">num_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">num_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">outliers</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">num_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">num_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">outliers</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outliers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># also try with just the number of objects expected and take whichever gives more</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labels2</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">num_objs</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">n_from2</span> <span class="o">=</span> <span class="n">labels2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># create a binary image where only the non-outlier pixels are turned on</span>
        <span class="k">if</span> <span class="n">n_from2</span> <span class="o">&gt;</span> <span class="n">num_pix</span><span class="p">[</span><span class="o">~</span><span class="n">outliers</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="c1"># already have 1 on the bright poritions</span>
            <span class="n">connected_mat</span> <span class="o">=</span> <span class="n">labels2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">connected_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)[</span><span class="o">~</span><span class="n">outliers</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># do connected components</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">centroids</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span><span class="n">connected_mat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

        <span class="c1"># sort based on area size</span>
        <span class="n">sorted_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">stats</span><span class="p">[:,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">])</span>

        <span class="n">limbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">blob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_labs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1"># if we have considered the maximum number of objects already</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">num_objs</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># throw out blobs which are smaller than 10 pixels</span>
            <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># extract the area around the blob from the image</span>
            <span class="n">extra_bounds</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">top_left</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_TOP</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_LEFT</span><span class="p">]]</span> <span class="o">-</span> <span class="n">extra_bounds</span>
            <span class="n">bottom_right</span> <span class="o">=</span> <span class="n">top_left</span> <span class="o">+</span> <span class="n">stats</span><span class="p">[</span><span class="n">blob</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_HEIGHT</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_WIDTH</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">extra_bounds</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">top_left</span><span class="p">[</span><span class="n">top_left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">bottom_right</span><span class="p">[</span><span class="n">bottom_right</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">sub_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># determine the centroid of the current blob</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">centroids</span><span class="p">[</span><span class="n">blob</span><span class="p">]</span> <span class="o">-</span> <span class="n">top_left</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># check to be sure we have an actual object</span>
            <span class="k">if</span> <span class="n">sub_image</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># identify the subpixel limbs and store them</span>
            <span class="n">limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locate_limbs</span><span class="p">(</span><span class="n">sub_image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">)</span> <span class="o">+</span> <span class="n">top_left</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">limbs</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_locate_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">centroid</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies limb points in a region.</span>

<span class="sd">        This method combines the :meth:`identify_pixel_edges`, :meth:`_pixel_limbs`, and a subpixel method based off</span>
<span class="sd">        of the :attr:`.subpixel_method` attribute to determine the pixel level limb points in the region.  It inputs the</span>
<span class="sd">        region being considered, the centroid of the object in the region, and the illumination direction.  It outputs</span>
<span class="sd">        the subpixel limbs from the region.</span>

<span class="sd">        :param region: The imaging region being considered as a 2D array of illumination data</span>
<span class="sd">        :param centroid: The centroid of the blob in the region (typically provided by the opencv connected components</span>
<span class="sd">                         with stats function).</span>
<span class="sd">        :param illum_dir: The illumination direction in the region begin considered</span>
<span class="sd">        :return: the limb locations in the image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># detect edges in the image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span><span class="o">.</span><span class="n">prepare_edge_inputs</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

        <span class="c1"># pick out the pixels corresponding to the limbs</span>
        <span class="n">pixel_limbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pixel_limbs</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pixel_limbs</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pixel_limbs</span>
        
        <span class="c1"># refine to subpixel and return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span><span class="o">.</span><span class="n">refine_edges</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">pixel_limbs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pixel_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroid</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">illum_dir</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies pixel level limb points from a binary image of edge points.</span>

<span class="sd">        A limb is defined as the first edge point encountered by a scan vector in the direction of the illumination</span>
<span class="sd">        direction.  The limb points are extracted by (1) selecting starting locations for the scan vectors along a line</span>
<span class="sd">        perpendicular to the illumination direction spaced :attr:`step` pixels apart and then (2) scanning from these starting</span>
<span class="sd">        points in the illumination direction to identify the first edge point that is along the line.</span>

<span class="sd">        This method inputs a binary image with true values in the pixels which contain edges, the centroid of the object</span>
<span class="sd">        being considered in the binary image, the illumination direction, and the :attr:`step` size. It outputs the pixel level</span>
<span class="sd">        edges as a 2D array with the x values in the first row and the y values in the second row.</span>

<span class="sd">        :param centroid: The centroid of the object being considered</span>
<span class="sd">        :param illum_dir: the illumination direction in the `edge_mask` image</span>
<span class="sd">        :param image: the image being processed</span>
<span class="sd">        :return: The pixel level limb locations as a 2D integer array with the x values in the first row and the y values in the</span>
<span class="sd">                 second row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">illum_dir_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">illum_dir</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># get the illumination gradient in the sun direction</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span><span class="o">.</span><span class="n">horizontal_gradient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span><span class="o">.</span><span class="n">vertical_gradient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;the gradients can&#39;t be none at this point&quot;</span>
        <span class="n">illum_grad</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span><span class="o">.</span><span class="n">horizontal_gradient</span><span class="o">*</span><span class="n">illum_dir_np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_detector</span><span class="o">.</span><span class="n">vertical_gradient</span><span class="o">*</span><span class="n">illum_dir_np</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># set the minimum gradient for a limb to be 3/4 of an SD away from the mean</span>
        <span class="n">limb_grad_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">illum_grad</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.75</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">illum_grad</span><span class="p">)</span>

        <span class="c1"># determine how far we need to travel from the centroid to start our scan lines</span>
        <span class="n">line_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">illum_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>

        <span class="c1"># determine the direction to offset our scan stars</span>
        <span class="n">perpendicular_direction</span> <span class="o">=</span> <span class="n">illum_dir_np</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">perpendicular_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># get the middle of the start positions of our scan lines</span>
        <span class="c1"># middle start position of scan</span>
        <span class="n">scan_start_middle</span> <span class="o">=</span> <span class="n">centroid</span> <span class="o">-</span> <span class="n">line_length</span> <span class="o">*</span> <span class="n">illum_dir_np</span>

        <span class="c1"># choose scan starting locations</span>
        <span class="n">scan_starts</span> <span class="o">=</span> <span class="n">scan_start_middle</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">line_length</span><span class="p">,</span> <span class="n">line_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">perpendicular_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># where we&#39;ll store the limbs</span>
        <span class="n">limbs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># for each scan line</span>
        <span class="k">for</span> <span class="n">scan_line_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scan_starts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># get the points along the scan line</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">scan_starts</span><span class="p">[:,</span> <span class="n">scan_line_number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">line_length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">illum_dir_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">sl_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># make sure we preserve order</span>
            <span class="n">scan_line</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sl_index</span><span class="p">)]</span>

            <span class="c1"># filter out invalid scan points</span>
            <span class="n">scan_line</span> <span class="o">=</span> <span class="n">scan_line</span><span class="p">[:,</span> <span class="p">(</span><span class="n">scan_line</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> 
                                  <span class="p">(</span><span class="n">scan_line</span> <span class="o">&lt;</span> <span class="p">[[</span><span class="n">illum_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">illum_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>

            <span class="c1"># if none of the line is valid continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">scan_line</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># get the gradient values along the scan line</span>
            <span class="n">scan_gradient</span> <span class="o">=</span> <span class="n">illum_grad</span><span class="p">[</span><span class="n">scan_line</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scan_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># look for large gradients</span>
            <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">scan_gradient</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># get the step along the line the outliers fall out</span>
            <span class="n">outlier_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">outliers</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">outlier_number</span> <span class="ow">in</span> <span class="n">outlier_numbers</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
                <span class="n">outlier_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">outlier_number</span><span class="p">)</span>

                <span class="c1"># make sure that the outlier is not at the end or beginning</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">outlier_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">outlier_number</span> <span class="o">==</span> <span class="p">(</span><span class="n">scan_gradient</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">continue</span>

                <span class="c1"># make sure this is greater than the min gradient</span>
                <span class="k">if</span> <span class="n">scan_gradient</span><span class="p">[</span><span class="n">outlier_number</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">limb_grad_min</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># check if we are at a local maxima</span>
                <span class="k">if</span> <span class="n">scan_gradient</span><span class="p">[</span><span class="n">outlier_number</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">scan_gradient</span><span class="p">[</span><span class="n">outlier_number</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">scan_gradient</span><span class="p">[</span><span class="n">outlier_number</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">scan_gradient</span><span class="p">[</span><span class="n">outlier_number</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># determine how many surrounding pixels we need to check</span>
                <span class="c1"># distance between the current step and the end points</span>
                <span class="n">back_distance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">outlier_number</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">forward_distance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">scan_line</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">outlier_number</span> <span class="o">-</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surround_check_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># if the check size wasn&#39;t specified use 1/8 of the scan line length</span>
                    <span class="n">check_size</span> <span class="o">=</span> <span class="n">scan_line</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">8</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surround_check_size</span>

                <span class="n">check_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">check_size</span><span class="p">,</span> <span class="n">back_distance</span><span class="p">,</span> <span class="n">forward_distance</span><span class="p">)</span>
                <span class="c1"># if we&#39;re at the edge discard this</span>
                <span class="k">if</span> <span class="n">check_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_surround_check_size</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># check if the backwards is less than the forwards</span>
                <span class="n">backwards_points</span> <span class="o">=</span> <span class="n">scan_line</span><span class="p">[:,</span> <span class="n">outlier_number</span><span class="o">-</span><span class="n">check_size</span><span class="p">:</span><span class="n">outlier_number</span><span class="p">]</span>
                <span class="n">backwards_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">backwards_points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">backwards_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">forwards_points</span> <span class="o">=</span> <span class="n">scan_line</span><span class="p">[:,</span> <span class="n">outlier_number</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">outlier_number</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">check_size</span><span class="p">]</span>
                <span class="n">forwards_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">forwards_points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">forwards_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">backwards_median</span> <span class="o">&gt;=</span> <span class="n">forwards_median</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># if we made it here we have a limb</span>
                <span class="n">limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scan_line</span><span class="p">[:,</span> <span class="n">outlier_number</span><span class="p">])</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">limbs</span><span class="p">:</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">limbs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limbs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">limbs</span></div>


</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>