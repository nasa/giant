<!DOCTYPE html>

<html lang="en" data-content_root="../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.relative_opnav.estimators.sfn.sfn_class &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../../index.html">
    <img class="logo" src="../../../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.relative_opnav.estimators.sfn.sfn_class</h1><div class="highlight"><pre>
<span></span>


<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides the capability to locate surface features from a target in an image using 2D cross-correlation.</span>

<span class="sd">Description of the Technique</span>
<span class="sd">----------------------------</span>

<span class="sd">When a target grows to the point where we can begin to distinguish individual features on the surface in the images, we</span>
<span class="sd">typically consider switching to navigating using these features instead of just the center of figure of the target.</span>
<span class="sd">There are a number of reasons for this, including the fact that as the body grows in the field of view and errors in</span>
<span class="sd">your shape model can start contributing to larger and larger errors in your center-finding results and the fact that</span>
<span class="sd">having multiple observations instead of a single puts a stronger constraint on the location of the camera at each image</span>
<span class="sd">allowing us to more accurately estimate the trajectory of the camera through time.</span>

<span class="sd">One of the most common ways of extracting observations of each feature is through cross correlation, using a very</span>
<span class="sd">similar technique to that describe in :mod:`.cross_correlation`.  Essentially we render what we think each feature will</span>
<span class="sd">look like based on the current knowledge of the relative position and orientation of the camera with respect to each</span>
<span class="sd">feature (the features are stored in a special catalog called a :class:`.FeatureCatalog`).  We then take the rendered</span>
<span class="sd">template and use normalized cross correlation to identify the location of the feature in the image.  After we have</span>
<span class="sd">identified the features in the image, we optionally solve a PnP problem to refine our knowledge of the spacecraft state</span>
<span class="sd">and then repeat the process to correct any errors in the observations created by errors in our initial state estimates.</span>

<span class="sd">In more detail, GIANT implements this using the following steps</span>

<span class="sd">#. Identify which features we think should be visible in the image using the :attr:`.FeatureCatalog.feature_finder`</span>
<span class="sd">#. For each feature we predict should be visible, render the template based on the a priori relative state between the</span>
<span class="sd">   camera and the feature using a single bounce ray trace and the routines from :mod:`.ray_tracer`.</span>
<span class="sd">#. Perform 2D normalized cross correlation for every possible alignment between the center of the templates and the</span>
<span class="sd">   image.  We do this in a search region specified by the user and usually in the spatial domain so that we can include</span>
<span class="sd">   information about which pixels we want to consider when computing the correlation scores, as described in</span>
<span class="sd">   :func:`.sfn_correlator`.</span>
<span class="sd">#. Locate the peaks of the correlation surfaces (optionally locate the subpixel peak by fitting a 2D quadric to the</span>
<span class="sd">   correlation surface)</span>
<span class="sd">#. Correct the located peaks based on the location of the center-of-feature in the template to get the</span>
<span class="sd">   observed center-of-feature in the image.</span>
<span class="sd">#. Optionally solve the PnP problem for the best shift/rotation of the feature locations in the camera frame to minimize</span>
<span class="sd">   the residuals between the predicted feature locations and the observed feature locations.  Once complete, update the</span>
<span class="sd">   knowledge of the relative position/orientation of the camera with respect to the target and repeat all steps except</span>
<span class="sd">   this one to correct for errors introduced by a priori state knowledge errors.</span>

<span class="sd">Tuning</span>
<span class="sd">------</span>

<span class="sd">There are a few more tuning options in SFN verses normal cross correlation.  The first, and likely most important</span>
<span class="sd">tuning is for identifying potentially visible features in an image.  For this, you actually want to set the</span>
<span class="sd">:attr:`.FeatureCatalog.feature_finder` attribute to be something that will correctly determine which features are</span>
<span class="sd">possibly visible (typically to an instance of :class:`.VisibleFeatureFinder`).  We discuss the tuning for the</span>
<span class="sd">:class:`.VisibleFeatureFinder` here, though you could concievably use something else if you desired.</span>

<span class="sd">========================================================= ==============================================================</span>
<span class="sd">Parameter                                                 Description</span>
<span class="sd">========================================================= ==============================================================</span>
<span class="sd">:attr:`.VisibleFeatureFinder.off_boresight_angle_maximum` The maximum angle between the boresight of the camera and the</span>
<span class="sd">                                                          feature location in the camera frame in degrees.</span>
<span class="sd">:attr:`.VisibleFeatureFinder.gsd_scaling`                 The permissible ratio of the camera ground sample distance to</span>
<span class="sd">                                                          the feature ground sample distance</span>
<span class="sd">:attr:`.VisibleFeatureFinder.reflectance_angle_maximum`   The maximum angle between the viewing vector and the average</span>
<span class="sd">                                                          normal vector of the feature in degrees.</span>
<span class="sd">:attr:`.VisibleFeatureFinder.incident_angle_maximum`      The maximum angle between the incoming light vector and the</span>
<span class="sd">                                                          average feature normal vector in degrees.</span>
<span class="sd">:attr:`.VisibleFeatureFinder.percent_in_fov`              The percentage of the feature that is in the FOV</span>
<span class="sd">:attr:`.VisibleFeatureFinder.feature_list`                A list of feature names to consider</span>
<span class="sd">========================================================= ==============================================================</span>

<span class="sd">When tuning the feature finder you generally are looking to only get features that are likely to actually correlate well</span>
<span class="sd">in the image so that you don&#39;t waste time considering features that won&#39;t work for one reason or another.  All of these</span>
<span class="sd">parameters can contribute to this, but some of the most important are the ``gsd_scaling``, which should typically be</span>
<span class="sd">around 2 and the ``off_boresight_angle_maximum`` which should typically be just a little larger than the half diagonal</span>
<span class="sd">field of view of the detector to avoid possibly overflowing values in the projection computation and processing features</span>
<span class="sd">that are actually way outside the field of view.  Note that since you set the feature finder on each feature catalog,</span>
<span class="sd">this means that you can have different tunings for different feature catalogs (if you have multiple in a scene).</span>

<span class="sd">Next we have the parameters that control the actual rendering/correlation for each feature.  These are the same as for</span>
<span class="sd">:mod:`.cross_correlation`.</span>

<span class="sd">================================================ =======================================================================</span>
<span class="sd">Parameter                                        Description</span>
<span class="sd">================================================ =======================================================================</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.brdf`           The bidirectional reflectance distribution function used to compute the</span>
<span class="sd">                                                 expected illumination of a ray based on the geometry of the scene.</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.grid_size`      The size of the grid to use for subpixel sampling when rendering the</span>
<span class="sd">                                                 templates</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.peak_finder`    The function to use to detect the peaks of the correlation surfaces.</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.blur`           A flag specifying whether to blur the correlation surfaces to decrease</span>
<span class="sd">                                                 high frequency noise before identifying the peak.</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.search_region`  The search region in pixels to restrict the area the peak of</span>
<span class="sd">                                                 the correlation surfaces is searched for around the a priori predicted</span>
<span class="sd">                                                 centers for each feature</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.min_corr_score` The minimum correlation score to accept as a successful identification.</span>
<span class="sd">                                                 Correlation scores range from -1 to 1, with 1 indicating perfect</span>
<span class="sd">                                                 correlation.</span>
<span class="sd">================================================ =======================================================================</span>

<span class="sd">Of these options, most only make small changes to the results.  The 2 that can occasionally make large changes are</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.search_region` and :attr:`~SurfaceFeatureNavigation.blur`.  In general</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.search_region` should be set to a few pixels larger than the expected uncertainty in</span>
<span class="sd">the camera/feature relative state. Since we are doing spatial correlation here we typically want this number to be as</span>
<span class="sd">small as possible for efficiency while still capturing the actual peak. The :attr:`~SurfaceFeatureNavigation.blur`</span>
<span class="sd">attribute can also be used to help avoid mistaken correlation (perhaps were only empty space is aligned).  Finally, the</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.min_corr_score` can generally be left at the default, though if you have a poor a</span>
<span class="sd">priori knowledge of either the shape model or the relative position of the features then you may need to decrease this</span>
<span class="sd">some.</span>

<span class="sd">The last set of tuning parameters to consider are those for the PnP solver.  They are as follows:</span>

<span class="sd">=============================================================== ========================================================</span>
<span class="sd">Parameter                                                       Description</span>
<span class="sd">=============================================================== ========================================================</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.run_pnp_solver`                A flag to turn the PnP solver on</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.pnp_ransac_iterations`         The number of RANSAC iterations to attempt in the PnP</span>
<span class="sd">                                                                solver</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.second_search_region`          The search region in pixels to restrict the area the</span>
<span class="sd">                                                                peak of the correlation surfaces is searched for around</span>
<span class="sd">                                                                the a priori predicted centers for each feature after</span>
<span class="sd">                                                                a PnP solution has been done</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.measurement_sigma`             The uncertainty to assume for each measurement</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.position_sigma`                The uncertainty to assume in the a priori relative</span>
<span class="sd">                                                                position vector between the camera and the features in</span>
<span class="sd">                                                                kilometers</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.attitude_sigma`                The uncertainty to assume in the a priori relative</span>
<span class="sd">                                                                orientation between the camera and the features in</span>
<span class="sd">                                                                degrees</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.state_sigma`                   The uncertainty to assume in the relative position and</span>
<span class="sd">                                                                orientation between the camera and the features</span>
<span class="sd">                                                                (overrides the individual position and attitude sigmas)</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.max_lsq_iterations`            The maximum number of iterations to attempt to converge</span>
<span class="sd">                                                                in the linearized least squares solution of the PnP</span>
<span class="sd">                                                                problem</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.lsq_relative_error_tolerance`  The maximum change in the residuals from one iteration</span>
<span class="sd">                                                                to the next before we consider the PnP solution</span>
<span class="sd">                                                                converged</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.lsq_relative_update_tolerance` The maximum change in the update vector from one</span>
<span class="sd">                                                                iteration to the next before we consider the PnP</span>
<span class="sd">                                                                solution converged.</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.cf_results`                    A numpy array specifying the observed center of figure</span>
<span class="sd">                                                                for each target in the image (for instance from</span>
<span class="sd">                                                                :mod:`.cross_correlation`) to use to set the a priori</span>
<span class="sd">                                                                relative state information between the camera and the</span>
<span class="sd">                                                                feature catalog</span>
<span class="sd">:attr:`~SurfaceFeatureNavigation.cf_index`                      The mapping of feature catalog number to column of the</span>
<span class="sd">                                                                ``cf_result`` array.</span>
<span class="sd">=============================================================== ========================================================</span>

<span class="sd">All of these options can be important.  First, unless you have very good a priori error, you probably should turn the</span>
<span class="sd">PnP solver on.  Because of the way SFN works, errors in your a priori state can lead to somewhat significant errors in</span>
<span class="sd">the observed feature locations, and the PnP solver can correct a lot of these errors.  If you do turn the PnP solver on</span>
<span class="sd">then the rest of these options become important.  The ``pnp_ransac_iterations`` should typically be set to something</span>
<span class="sd">around 100-200, especially if you expect there to be outliers (which there usually are).  The ``second_search_distance``</span>
<span class="sd">should be set to capture the expected uncertainty after the PnP solution (typically mostly just the uncertainty in the</span>
<span class="sd">camera model and the uncertainty in the feature locations themselves).  Typically something around 5 works well.  The</span>
<span class="sd">``*_sigma`` attributes control the relative weighting between the a priori state and the observed locations, which can</span>
<span class="sd">be important to get a good PnP solution.  The ``max_lsq_iterations`, ``lsq_relative_error_tolerance``, and</span>
<span class="sd">``lsq_relative_update_tolerance`` can play an important role in getting the PnP solver to converge, though the defaults</span>
<span class="sd">are generally decent.  Finally, the ``cf_results`` and ``cf_index`` can help to decrease errors in the a priori relative</span>
<span class="sd">state knowledge, which in some cases can be critical to successfully identifying features.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">The class provided in this module is usually not used by the user directly, instead it is usually interfaced with</span>
<span class="sd">through the :class:`.RelativeOpNav` class using the identifier :attr:`~.RelativeOpNav.sfn`.  For more</span>
<span class="sd">details on using the :class:`.RelativeOpNav` interface, please refer to the :mod:`.relnav_class` documentation.  For</span>
<span class="sd">more details on using the technique class directly, as well as a description of the ``details`` dictionaries produced</span>
<span class="sd">by this technique, refer to the following class documentation.</span>

<span class="sd">One implementation detail we do want to note is that you should set your :attr:`.FeatureCatalog.feature_finder` on</span>
<span class="sd">your feature catalog before using this class. For instance, if your catalog is stored in a file called</span>
<span class="sd">``&#39;features.pickle&#39;``</span>

<span class="sd">    &gt;&gt;&gt; import pickle</span>
<span class="sd">    &gt;&gt;&gt; from giant.relative_opnav.estimators.sfn.surface_features import VisibleFeatureFinder</span>
<span class="sd">    &gt;&gt;&gt; with open(&#39;features.pickle&#39;, &#39;rb&#39;) as in_file:</span>
<span class="sd">    &gt;&gt;&gt;     fc: VisibleFeatureFinder = pickle.load(in_file) </span>
<span class="sd">    &gt;&gt;&gt; fc.feature_finder = VisibleFeatureFinder(fc, gsd_scaling=2.5)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">least_squares</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span><span class="p">,</span> <span class="n">rotvec_to_rotmat</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.rays</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_rays</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">SceneObject</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.rays</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">otsu</span><span class="p">,</span> <span class="n">cv2_correlator_2d</span><span class="p">,</span> <span class="n">quadric_peak_finder_2d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNavImage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.outlier_identifier</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_outliers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.random_combination</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomCombinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserOptionConfigured</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.sfn.surface_features</span><span class="w"> </span><span class="kn">import</span> <span class="n">FeatureCatalog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.estimator_interface_abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">RelNavObservablesType</span><span class="p">,</span> <span class="n">RelNavEstimator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators._template_renderer</span><span class="w"> </span><span class="kn">import</span> <span class="n">TemplateRendererOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.sfn.sfn_correlators</span><span class="w"> </span><span class="kn">import</span> <span class="n">sfn_correlator</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">SCALAR_OR_ARRAY</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>


<div class="viewcode-block" id="SurfaceFeatureNavigationOptions">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/sfn_class/giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigationOptions.html#giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigationOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SurfaceFeatureNavigationOptions</span><span class="p">(</span><span class="n">TemplateRendererOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This dataclass serves as one way to control the settings for the :class:`.SurfaceFeatureNavigation` class.</span>

<span class="sd">    You can set any of the options on an instance of this dataclass and pass it to the</span>
<span class="sd">    :class:`.SurfaceFeatureNavigation` class at initialization to set the settings on the class. </span>
<span class="sd">    This class is the preferred way of setting options on the class due to ease of use in IDEs.</span>
<span class="sd">    </span>
<span class="sd">    :param min_corr_score: The minimum correlation score to accept for something to be considered found in an image.</span>
<span class="sd">                            The correlation score is the Pearson Product Moment Coefficient between the image and the</span>
<span class="sd">                            template. This should be a number between -1 and 1, and in nearly every cast a number</span>
<span class="sd">                            between 0 and 1.  Setting this to -1 essentially turns the minimum correlation score</span>
<span class="sd">                            check off.</span>
<span class="sd">    :param blur: A flag to perform a Gaussian blur on the correlation surface before locating the peak to remove</span>
<span class="sd">                    high frequency noise</span>
<span class="sd">    :param search_region: The number of pixels to search around the a priori predicted center for the peak of the</span>
<span class="sd">                            correlation surface.  If ``None`` then searches the entire correlation surface.</span>
<span class="sd">    :param run_pnp_solver: A flag specifying whether to use the PnP solver to correct errors in the initial</span>
<span class="sd">                            relative state between the camera and the target body</span>
<span class="sd">    :param pnp_ransac_iterations: The number of RANSAC iterations to attempt in the PnP solver.  Set to 0 to turn</span>
<span class="sd">                                    the RANSAC component of the PnP solver</span>
<span class="sd">    :param second_search_region: The distance around the nominal location to search for each feature in the image</span>
<span class="sd">                                    after correcting errors using the PnP solver.</span>
<span class="sd">    :param measurement_sigma: The uncertainty to assume for each measurement in pixels. This is used to set the</span>
<span class="sd">                                relative weight between the observed landmarks are the a priori knowledge in the PnP</span>
<span class="sd">                                problem. See the :attr:`measurement_sigma` documentation for a description of valid</span>
<span class="sd">                                inputs.</span>
<span class="sd">    :param position_sigma: The uncertainty to assume for the relative position vector in kilometers. This is used to</span>
<span class="sd">                            set the relative weight between the observed landmarks and the a priori knowledge in the</span>
<span class="sd">                            PnP problem. See the :attr:`position_sigma` documentation for a description of valid</span>
<span class="sd">                            inputs.  If the ``state_sigma`` input is not ``None`` then this is ignored.</span>
<span class="sd">    :param attitude_sigma: The uncertainty to assume for the relative orientation rotation vector in radians. This</span>
<span class="sd">                            is used to set the relative weight between the observed landmarks and the a priori</span>
<span class="sd">                            knowledge in the PnP problem. See the :attr:`attitude_sigma` documentation for a</span>
<span class="sd">                            description of valid inputs.  If the ``state_sigma`` input is not ``None`` then this is</span>
<span class="sd">                            ignored.</span>
<span class="sd">    :param state_sigma: The uncertainty to assume for the relative position vector and orientation rotation vector</span>
<span class="sd">                        in kilometers and radians respectively. This is used to set the relative weight between the</span>
<span class="sd">                        observed landmarks and the a priori knowledge in the PnP problem. See the</span>
<span class="sd">                        :attr:`state_sigma` documentation for a description of valid inputs.  If this input is not</span>
<span class="sd">                        ``None`` then the ``attitude_sigma`` and ``position_sigma`` inputs are ignored.</span>
<span class="sd">    :param max_lsq_iterations: The maximum number of iterations to make in the least squares solution to the PnP</span>
<span class="sd">                                problem.</span>
<span class="sd">    :param lsq_relative_error_tolerance: The relative tolerance in the residuals to signal convergence in the least</span>
<span class="sd">                                            squares solution to the PnP problem.</span>
<span class="sd">    :param lsq_relative_update_tolerance: The relative tolerance in the update vector to signal convergence in the</span>
<span class="sd">                                            least squares solution to the PnP problem</span>
<span class="sd">    :param cf_results: A numpy array containing the center finding residuals for the target that the feature</span>
<span class="sd">                        catalog is a part of.  If present this is used to correct errors in the a priori line of</span>
<span class="sd">                        sight to the target before searching for features in the image.</span>
<span class="sd">    :param cf_index: A list that maps the features catalogs contained in the ``scene`` (in order) to the</span>
<span class="sd">                        appropriate column of the ``cf_results`` matrix.  If left blank the mapping is assumed to be</span>
<span class="sd">                        in like order</span>
<span class="sd">    :param show_templates: A flag to show the rendered templates for each feature &quot;live&quot;.  This is useful for</span>
<span class="sd">                            debugging but in general should not be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">peak_finder</span><span class="p">:</span>  <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadric_peak_finder_2d</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The peak finder function to use. This should be a callable that takes in a 2D surface as a numpy array and returns </span>
<span class="sd">    the (x,y) location of the peak of the surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">min_corr_score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The minimum correlation score to accept for something to be considered found in an image. The correlation score </span>
<span class="sd">    is the Pearson Product Moment Coefficient between the image and the template. This should be a number between -1 </span>
<span class="sd">    and 1, and in nearly every cast a number between 0 and 1.  Setting this to -1 essentially turns the minimum </span>
<span class="sd">    correlation score check off. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">blur</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag to perform a Gaussian blur on the correlation surface before locating the peak to remove high frequency noise</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">search_region</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of pixels to search around the a priori predicted center for the peak of the correlation surface.  If </span>
<span class="sd">    ``None`` then searches the entire correlation surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">run_pnp_solver</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag specifying whether to use the PnP solver to correct errors in the initial relative state between the camera </span>
<span class="sd">    and the target body</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pnp_ransac_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of RANSAC iterations to attempt in the PnP solver.  Set to 0 to turn the RANSAC component of the PnP </span>
<span class="sd">    solver</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">second_search_region</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The distance around the nominal location to search for each feature in the image after correcting errors using the </span>
<span class="sd">    PnP solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">measurement_sigma</span><span class="p">:</span> <span class="n">SCALAR_OR_ARRAY</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The uncertainty to assume for each measurement in pixels. This is used to set the relative weight between the </span>
<span class="sd">    observed landmarks are the a priori knowledge in the PnP problem. See the :attr:`measurement_sigma` documentation </span>
<span class="sd">    for a description of valid inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">position_sigma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SCALAR_OR_ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The uncertainty to assume for the relative position vector in kilometers. This is used to set the relative weight </span>
<span class="sd">    between the observed landmarks and the a priori knowledge in the PnP problem. See the :attr:`position_sigma` </span>
<span class="sd">    documentation for a description of valid inputs.  If the ``state_sigma`` input is not ``None`` then this is </span>
<span class="sd">    ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attitude_sigma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SCALAR_OR_ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The uncertainty to assume for the relative orientation rotation vector in radians. This is used to set the </span>
<span class="sd">    relative weight between the observed landmarks and the a priori knowledge in the PnP problem. See the </span>
<span class="sd">    :attr:`attitude_sigma` documentation for a description of valid inputs.  If the ``state_sigma`` input is not </span>
<span class="sd">    ``None`` then this is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">state_sigma</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The uncertainty to assume for the relative position vector and orientation rotation vector in kilometers and </span>
<span class="sd">    radians respectively. This is used to set the relative weight between the observed landmarks and the a priori </span>
<span class="sd">    knowledge in the PnP problem. See the :attr:`state_sigma` documentation for a description of valid inputs.  If </span>
<span class="sd">    this input is not ``None`` then the ``attitude_sigma`` and ``position_sigma`` inputs are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_lsq_iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum number of iterations to make in the least squares solution to the PnP problem. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lsq_relative_error_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The relative tolerance in the residuals to signal convergence in the least squares solution to the PnP problem.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lsq_relative_update_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The relative tolerance in the update vector to signal convergence in the least squares solution to the PnP problem</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cf_results</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    A numpy array containing the center finding residuals for the target that the feature catalog is a part of.  If </span>
<span class="sd">    present this is used to correct errors in the a priori line of sight to the target before searching for features </span>
<span class="sd">    in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cf_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list that maps the features catalogs contained in the ``scene`` (in order) to the appropriate column of the </span>
<span class="sd">    ``cf_results`` matrix.  If left blank the mapping is assumed to be in like order</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">show_templates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag to show the rendered templates for each feature &quot;live&quot;. This is useful for debugging but in general should </span>
<span class="sd">    not be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">override_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_search_region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_search_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_region</span></div>



<div class="viewcode-block" id="SurfaceFeatureNavigation">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/sfn_class/giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.html#giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SurfaceFeatureNavigation</span><span class="p">(</span><span class="n">UserOptionConfigured</span><span class="p">[</span><span class="n">SurfaceFeatureNavigationOptions</span><span class="p">],</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">SurfaceFeatureNavigationOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements surface feature navigation using normalized cross correlation template matching for GIANT.</span>

<span class="sd">    All of the steps required for performing surface feature navigation are handled by this class, including the</span>
<span class="sd">    identification of visible features in the image, the rendering of the templates for each feature, the actual cross</span>
<span class="sd">    correlation, the identification of the peaks of the correlation surfaces, and optionally the solution of a PnP</span>
<span class="sd">    problem based on the observed feature locations in the image.  This is all handled in the :meth:`estimate` method</span>
<span class="sd">    and is performed for each requested target.  Note that targets must have shapes of :class:`.FeatureCatalog` to use</span>
<span class="sd">    this class.</span>

<span class="sd">    When all of the required data has been successfully loaded into an instance of this class, the :meth:`estimate`</span>
<span class="sd">    method is used to perform the estimation for the requested image.  The results are stored into the</span>
<span class="sd">    :attr:`observed_bearings` attribute for the observed center of template locations. In addition, the predicted</span>
<span class="sd">    locations for the center of template for each template is stored in the :attr:`computed_bearings` attribute.</span>
<span class="sd">    Finally, the details about the fit are stored as a dictionary in the appropriate element in the :attr:`details`</span>
<span class="sd">    attribute.  Specifically, these dictionaries will contain the following keys.</span>

<span class="sd">    ================================= ==================================================================================</span>
<span class="sd">    Key                               Description</span>
<span class="sd">    ================================= ==================================================================================</span>
<span class="sd">    ``&#39;Correlation Scores&#39;``          The correlation score at the peak of the correlation surface for each feature as a</span>
<span class="sd">                                      list of floats. The corresponding element will be 0 for any features that were not</span>
<span class="sd">                                      found.  Each element of this list corresponds to the feature according to the</span>
<span class="sd">                                      corresponding element in the ``&#39;Visible Features&#39;`` list. If no potential visible</span>
<span class="sd">                                      features were expected in the image then this is not available.</span>
<span class="sd">    ``&#39;Visible Features&#39;``            The list of feature indices (into the :attr:`.FeatureCatalog.features` list)</span>
<span class="sd">                                      that were looked for in the image.  Each element of this list corresponds to the</span>
<span class="sd">                                      corresponding element in the :attr:`templates` list.  If no potential visible</span>
<span class="sd">                                      features were expected in the image then this is not available.</span>
<span class="sd">    ``&#39;Correlation Peak Locations&#39;``  The Location of the correlation peaks before correcting it to find the location of</span>
<span class="sd">                                      the location of the feature in the image as a list of size 2 numpy arrays. Each</span>
<span class="sd">                                      element of this list corresponds to the feature according to the corresponding</span>
<span class="sd">                                      element in the ``&#39;Visible Features&#39;`` list.  Any features that were not found in</span>
<span class="sd">                                      the image have ``np.nan`` for their values.  If no potential visible features were</span>
<span class="sd">                                      expected in the image then this is not available.</span>
<span class="sd">    ``&#39;Correlation Surfaces&#39;``        The raw correlation surfaces as 2D arrays of shape</span>
<span class="sd">                                      ``2*search_region+1 x 2*search_region+1``.  Each pixel in the correlation surface</span>
<span class="sd">                                      represents a shift between the predicted and expected location, according to</span>
<span class="sd">                                      :func:`.sfn_correlator`.  Each element of this list corresponds to the feature</span>
<span class="sd">                                      according to the corresponding element in the ``&#39;Visible Features&#39;`` list.  If no</span>
<span class="sd">                                      potential visible features were expected in the image then this is not available.</span>
<span class="sd">    ``&#39;Target Template Coordinates&#39;`` The location of the center of each feature in its corresponding template. Each</span>
<span class="sd">                                      element of this list corresponds to the feature according to the corresponding</span>
<span class="sd">                                      element in the ``&#39;Visible Features&#39;`` list.  If no potential visible features</span>
<span class="sd">                                      were expected in the image then this is not available.</span>
<span class="sd">    ``&#39;Intersect Masks&#39;``             The boolean arrays the shape shapes of each rendered template with ``True`` where</span>
<span class="sd">                                      a ray through that pixel struct the surface of the template and ``False``</span>
<span class="sd">                                      otherwise. Each element of this list corresponds to the feature according to the</span>
<span class="sd">                                      corresponding element in the ``&#39;Visible Features&#39;`` list.  If no potential</span>
<span class="sd">                                      visible features were expected in the image then this is not available.</span>
<span class="sd">    ``&#39;Space Mask&#39;``                  The boolean array the same shape as the image specifying which pixels of the image</span>
<span class="sd">                                      we thought were empty space with a ``True`` and which we though were on the body</span>
<span class="sd">                                      with a ``False``.  If no potential visible features were expected in the image</span>
<span class="sd">                                      then this is not available</span>
<span class="sd">    ``&#39;PnP Solution&#39;``                A boolean indicating whether the PnP solution was successful (``True``) or not.</span>
<span class="sd">                                      This is only available if a PnP solution was attempted.</span>
<span class="sd">    ``&#39;PnP Translation&#39;``             The solved for translation in the original camera frame that minimizes the</span>
<span class="sd">                                      residuals in the PnP solution as a length 3 array with units of kilometers.  This</span>
<span class="sd">                                      is only available if a PnP solution was attempted and the PnP solution was</span>
<span class="sd">                                      successful.</span>
<span class="sd">    ``&#39;PnP Rotation&#39;``                The solved for rotation of the original camera frame that minimizes the</span>
<span class="sd">                                      residuals in the PnP solution as a :class:`.Rotation`.  This</span>
<span class="sd">                                      is only available if a PnP solution was attempted and the PnP solution was</span>
<span class="sd">                                      successful.</span>
<span class="sd">    ``&#39;PnP Position&#39;``                The solved for relative position of the target in the camera frame after the PnP</span>
<span class="sd">                                      solution is applied as a length 3 numpy array in km.</span>
<span class="sd">    ``&#39;PnP Orientation&#39;``             The solved for relative orientation of the target frame with respect to the camera</span>
<span class="sd">                                      frame after the PnP solution is applied as a :class:`.Rotation`.</span>
<span class="sd">    ``&#39;Failed&#39;``                      A message indicating why the SFN failed.  This will only be present if the SFN fit</span>
<span class="sd">                                      failed (so you could do something like ``&#39;Failed&#39; in sfn.details[target_ind]`` to</span>
<span class="sd">                                      check if something failed.  The message should be a human readable description of</span>
<span class="sd">                                      what caused the failure.</span>
<span class="sd">    ================================= ==================================================================================</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Before calling the :meth:`estimate` method be sure that the scene has been updated to correspond to the correct</span>
<span class="sd">        image time.  This class does not update the scene automatically.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">observable_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LANDMARK</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This technique generates LANDMARK bearing observables to the center of landmarks in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">generates_templates</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag specifying that this RelNav estimator generates and stores templates in the :attr:`templates` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">technique</span> <span class="o">=</span> <span class="s2">&quot;sfn&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The name for the technique for registering with :class:`.RelativeOpNav`.  </span>
<span class="sd">    </span>
<span class="sd">    If None then the name will default to the name of the module where the class is defined.  </span>
<span class="sd">    </span>
<span class="sd">    This should typically be all lowercase and should not include any spaces or special characters except for ``_`` as </span>
<span class="sd">    it will be used to make attribute/method names.  (That is ``MyEstimator.technique.isidentifier()`` should evaluate </span>
<span class="sd">    ``True``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SurfaceFeatureNavigationOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param scene: The scene describing the a priori locations of the targets and the light source.</span>
<span class="sd">        :param camera: The :class:`.Camera` object containing the camera model and images to be analyzed</span>
<span class="sd">        :param options: A dataclass specifying the options to set for this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">SurfaceFeatureNavigationOptions</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cf_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cf_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cf_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cf_index</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This variable is used to notify which features are predicted to be visible in the image.</span>
<span class="sd">        </span>
<span class="sd">        Each visible feature is identified by its index in the :attr:`.FeatureCatalog.features` list.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<div class="viewcode-block" id="SurfaceFeatureNavigation.render">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/sfn_class/giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.render.html#giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.render">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
               <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span>
               <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method renders each visible feature for the current target according to the current estimate of the</span>
<span class="sd">        relative position/orientation between the target and the camera using single bounce ray tracing.</span>

<span class="sd">        The illumination values are computed by (a) determining the rays to trace through the scene (either user</span>
<span class="sd">        specified or by a call to :meth:`compute_rays`), (b) performing a single bounce ray trace through the scene</span>
<span class="sd">        using a call to :meth:`.Scene.get_illumination_inputs` with only the feature being processed &quot;turned on&quot;,</span>
<span class="sd">        (c) converting the results of the ray trace into illumination values using :attr:`brdf`, and then summing the</span>
<span class="sd">        intensity of each ray into a 2D template array. The rendered templates are store in the :attr:`templates`</span>
<span class="sd">        attribute.</span>

<span class="sd">        Additionally, this method also produces a 2D boolean array specifying which pixels in the template had rays</span>
<span class="sd">        which actually struck the surface of the feature (``True``) and which hit empty space (``False``) for use in</span>
<span class="sd">        the correlation of the template with the image.  Finally, it also computes the :attr:`computed_bearings` for</span>
<span class="sd">        each visible template by projecting the template center onto the image using the camera model and storing it</span>
<span class="sd">        in a 2xn array.</span>

<span class="sd">        Note that before calling this method you must have set the visible feature list in the image to the</span>
<span class="sd">        :attr:`visible_features` attribute.</span>

<span class="sd">        Typically this method is not used directly by the user and instead is called by the :meth:`estimate` method</span>
<span class="sd">        automatically.</span>

<span class="sd">        :param target_ind: index into the :attr:`.Scene.target_objs` list of the target being rendering</span>
<span class="sd">        :param target: the :class:`.SceneObject` for the target being rendered</span>
<span class="sd">        :param temperature: The temperature of the camera at the time the scene is being rendered.</span>
<span class="sd">        :return: The intersect masks as a list of 2D boolean arrays and the location of the feature center in each</span>
<span class="sd">                 template as a 2xn array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">visible_features</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot call render without having identified which features are visible&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">FeatureCatalog</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use SFN with non feature catalogs&#39;</span><span class="p">)</span>

        <span class="c1"># initialize the templates list to store the templates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">visible_features</span><span class="p">))</span>
        <span class="c1"># initialize the intersects list and the template centers list</span>
        <span class="n">intersects_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># initialize the array for the location of the feature center in each template as well as the computed bearings</span>
        <span class="c1"># for each template</span>
        <span class="n">template_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">visible_features</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">visible_features</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># loop through each possibly visible feature in the image</span>
        <span class="k">for</span> <span class="n">feature_number</span><span class="p">,</span> <span class="n">feature_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">visible_features</span><span class="p">):</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1"># figure out what rays to trace.  Hopefully we are doing this ourselves because things might go wonky</span>
            <span class="c1"># otherwise</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="p">(</span><span class="n">rays</span><span class="p">,</span> <span class="n">locs</span><span class="p">),</span> <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_rays</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">feature_ind</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="p">,</span> <span class="n">Rays</span><span class="p">):</span>
                <span class="n">rays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">rays</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">locs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">())</span> <span class="c1"># type: ignore</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="p">(</span><span class="n">rays</span><span class="p">,</span> <span class="n">locs</span><span class="p">),</span> <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_rays</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">feature_ind</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">rays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][</span><span class="n">feature_ind</span><span class="p">]</span> <span class="c1"># type: ignore</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">rays</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">locs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">())</span> <span class="c1"># type: ignore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rays</span><span class="p">:</span> <span class="n">Rays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">rays</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span> <span class="n">locs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">())</span> <span class="c1"># type: ignore</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tracing </span><span class="si">{}</span><span class="s1"> rays&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">num_rays</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">include_features</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature_ind</span><span class="p">]</span>

            <span class="c1"># get the ray trace results along with the intersect array</span>
            <span class="n">illum_inputs</span><span class="p">,</span> <span class="n">intersects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">get_illumination_inputs</span><span class="p">(</span><span class="n">rays</span><span class="p">,</span> <span class="n">return_intersects</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># transform the ray trace results into relative intensity values</span>
            <span class="n">illums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">brdf</span><span class="p">(</span><span class="n">illum_inputs</span><span class="p">)</span>

            <span class="n">template_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># make the arrays for the template and the intersect mask</span>
            <span class="n">intersects_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">template_size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="n">template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">template_size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

            <span class="c1"># figure out the subscripts into the template/intersect mask arrays</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">(</span><span class="n">locs</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># make the template/intersect mask</span>

            <span class="c1"># logical and means only pixels where all rays hit the surface are included.  This is to ignore the edge</span>
            <span class="c1"># which will be darker because fewer rays hit it.</span>

            <span class="c1"># alternatively we could use a logical or and then divide the template by the count of rays that actually</span>
            <span class="c1"># hit the surface.  Something to consider for the future.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">intersects_out</span><span class="p">,</span> <span class="p">(</span><span class="n">subs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">subs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">intersects</span><span class="p">[</span><span class="s1">&#39;check&#39;</span><span class="p">])</span>

            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="p">(</span><span class="n">subs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">subs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">illums</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">psf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">psf</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

            <span class="c1"># compute the bearing to the center of the feature in the image/template.</span>
            <span class="n">computed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">feature_locations</span><span class="p">[</span><span class="n">feature_ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span> 

            <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">feature_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">computed</span> <span class="c1"># type: ignore </span>
            <span class="n">template_centers</span><span class="p">[:,</span> <span class="n">feature_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">computed</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># type: ignore</span>

            <span class="n">intersects_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intersects_out</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][</span><span class="n">feature_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span> <span class="c1"># type: ignore</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Feature </span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">feature_ind</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> number </span><span class="si">{</span><span class="n">feature_number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> of &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">visible_features</span><span class="p">)</span><span class="si">}</span><span class="s1"> rendered in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># call the garbage collector to get rid of features that have been unloaded, because sometimes python doesn&#39;t do</span>
        <span class="c1"># this when we want it to</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">intersects_list</span><span class="p">,</span> <span class="n">template_centers</span></div>


    <span class="c1"># noinspection PyMethodOverriding</span>
<div class="viewcode-block" id="SurfaceFeatureNavigation.compute_rays">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/sfn_class/giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.compute_rays.html#giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.compute_rays">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_rays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_catalog</span><span class="p">:</span> <span class="n">FeatureCatalog</span><span class="p">,</span>
                     <span class="n">feature_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Rays</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the required rays to render a given feature based on the current estimate of the location</span>
<span class="sd">        and orientation of the feature in the image.</span>

<span class="sd">        This method first determines which pixels to trace. If a circumscribing sphere is defined for the feature,</span>
<span class="sd">        the edges of the sphere are used to compute the required pixels; otherwise, the bounding box is used. The</span>
<span class="sd">        requested subsampling for each pixel is then applied, and the sub-pixels are then converted into rays</span>
<span class="sd">        originating at the camera origin using the :class:`.CameraModel`.</span>

<span class="sd">        :param feature_catalog: The feature catalog which contains the feature we are rendering</span>
<span class="sd">        :param feature_ind: The index of the feature in the feature catalog that we are rendering</span>
<span class="sd">        :param temperature: The temperature of the camera at the time the feature is being rendered</span>
<span class="sd">        :return: The rays to trace through the scene and the pixel coordinates for each ray as a tuple, plus</span>
<span class="sd">                 the bounds of the pixel coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the feature bounds are already in the camera frame at this point (at least they should be...)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_bounds</span><span class="p">[</span><span class="n">feature_ind</span><span class="p">]</span>
        <span class="n">image_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="n">local_min</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="n">local_max</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="n">rays_pix</span> <span class="o">=</span> <span class="n">compute_rays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="p">(</span><span class="n">local_min</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">local_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">local_min</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">local_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="n">grid_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
        <span class="n">min_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_min</span><span class="p">,</span> <span class="n">local_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rays_pix</span><span class="p">,</span> <span class="n">min_max</span></div>


<div class="viewcode-block" id="SurfaceFeatureNavigation.estimate">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/sfn_class/giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.estimate.html#giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies the locations of surface features in the image through cross correlation of rendered</span>
<span class="sd">        templates with the image.</span>

<span class="sd">        This method first checks to ensure that the appropriate correlator is set for the :attr:`image_processing`</span>
<span class="sd">        instance (which should the :func:`.sfn_correlator`).  If it is not a warning is printed and we set the</span>
<span class="sd">        correlator to be the :func:`.sfn_correlator` (this is required for surface feature navigation).  Don&#39;t worry,</span>
<span class="sd">        we&#39;ll put things back the way they were when we&#39;re done :).</span>

<span class="sd">        This method also identifies the index into the :attr:`.Camera.images` list for the image being processed. This</span>
<span class="sd">        is done by first checking identity (to find the exact same image). If that doesn&#39;t work we then check based on</span>
<span class="sd">        equality (the pixel data is all exactly the same) however, this could lead to false pairing in some degenerate</span>
<span class="sd">        instances.  As long as you are using this method as intended (and not copying/modifying the image array from the</span>
<span class="sd">        camera before sending it to this method) the identity check should work.  We do this so that we can relocate</span>
<span class="sd">        each target to be along the line of sight vector found by center finding (if done/provided) before looking for</span>
<span class="sd">        features.  Therefore if you aren&#39;t seeding your SFN with center finding results you don&#39;t need to worry about</span>
<span class="sd">        this.</span>

<span class="sd">        Once the initial preparation is complete, for each requested target that is a :class:`.FeatureCatalog` we seek</span>
<span class="sd">        feature locations that are visible in the image. This is done by first predicting which features from the</span>
<span class="sd">        catalog should be visible in the image using the a priori relative state knowledge between the camera and the</span>
<span class="sd">        feature catalog and the :attr:`.FeatureCatalog.feature_finder` function which is usually an instance of</span>
<span class="sd">        :class:`.VisibleFeatureFinder`.  Once potentially visible features have been determined, we render a predicted</span>
<span class="sd">        template of each feature using a single bounce ray tracer.  We then do spatial cross correlation between the</span>
<span class="sd">        template and the image within a specified search region (if the search region is too large we attempt global</span>
<span class="sd">        frequency correlation first) to generate a correlation surface.  From this correlation surface, we identify the</span>
<span class="sd">        peak and use that to locate the center of the feature in the image.  Once this has been completed for all</span>
<span class="sd">        potentially visible features for a given target, we then optionally attempt to solve a PnP problem to refine the</span>
<span class="sd">        relative position and orientation of the camera with respect to the target based on the observed feature</span>
<span class="sd">        locations.  If we successfully solve the PnP problem, then we iterate 1 more time through the entire process</span>
<span class="sd">        (but not the PnP solver) and the results from that time become the observed locations stored in the</span>
<span class="sd">        :attr:`observed_bearings` attribute.</span>

<span class="sd">        More details about many of these steps can be seen in the :meth:`render` and :meth:`pnp_solver` methods.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Before calling this method be sure that the scene has been updated to correspond to the correct</span>
<span class="sd">            image time.  This method does not update the scene automatically.</span>

<span class="sd">        :param image: The image to locate the targets in</span>
<span class="sd">        :param include_targets: A list specifying whether to process the corresponding target in</span>
<span class="sd">                                :attr:`.Scene.target_objs` or ``None``.  If ``None`` then all targets are processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If using PnP solver, iterate the rendering and registration twice:</span>
        <span class="n">outer_iterations</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_pnp_solver</span><span class="p">:</span>
            <span class="n">outer_iterations</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># figure out which image index the current image is in the camera</span>
        <span class="c1"># default to 0 in case we can&#39;t figure it out</span>
        <span class="n">image_ind</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">other_image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="c1"># check for identity (first)</span>
            <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="n">other_image</span><span class="p">:</span>
                <span class="n">image_ind</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">image_ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if identity didn&#39;t work check for equality</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">other_image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">image</span> <span class="o">==</span> <span class="n">other_image</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">image_ind</span> <span class="o">=</span> <span class="n">ind</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">image_ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We were unable to figure out which index in the camera corresponds to the current image. Are you &quot;</span>
                  <span class="s2">&quot;sure this image came from this camera?.  We&#39;ll assume that the index is 0 for now...&quot;</span><span class="p">)</span>
            <span class="n">image_ind</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># prepare the space mask by performing Otsu on a Gaussian blurred image and then flood fill</span>
        <span class="c1"># opencv only likes single precision</span>
        <span class="n">image_32</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># GaussianBlur here helps close the figure.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">labeled</span> <span class="o">=</span> <span class="n">otsu</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">image_32</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">space_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">labeled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">labeled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="c1"># flood fill closes the shape</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">floodFill</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">labeled</span><span class="p">,</span> <span class="n">space_mask</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># target number is a counter on the number of targets we&#39;ve processed.</span>
        <span class="n">target_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_generator</span><span class="p">(</span><span class="n">include_targets</span><span class="p">):</span>
            <span class="c1"># target_ind is the index into the target_objs list</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1"># initialize these here since PyCharm can&#39;t figure out they&#39;re set later</span>
            <span class="n">correlation_surfaces</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">correlation_peaks</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">correlation_scores</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">template_centers</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">intersects</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">outer_iterations</span><span class="p">):</span>
                <span class="c1"># first time through use the original search distance.</span>
                <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">search_dist_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_region</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">search_dist_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_search_region</span>
                    
                <span class="k">assert</span> <span class="n">search_dist_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">FeatureCatalog</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All targets in SFN must be feature catalogs. Skipping target </span><span class="si">{</span><span class="n">target_ind</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">processed</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

                <span class="c1"># only update the a priori target location the first time through</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cf_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iteration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cf_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cf_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="n">target_number</span><span class="p">][</span><span class="s1">&#39;measured&#39;</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_ind</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cf_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">cf_index</span><span class="p">[</span><span class="n">target_number</span><span class="p">]][</span><span class="s1">&#39;measured&#39;</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_ind</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">target</span><span class="o">.</span><span class="n">change_position</span><span class="p">(</span><span class="n">new_center</span><span class="p">)</span>

                <span class="c1"># use the feature finder to find the visible features in the image</span>
                <span class="n">visible_features</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">feature_finder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span>
                                                               <span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">visible_features</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visible_features</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no visible features for target </span><span class="si">{</span><span class="n">target_ind</span><span class="si">}</span><span class="s1"> &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;in image </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="si">}</span><span class="s1">. Skipping&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Failed&quot;</span><span class="p">:</span> <span class="s2">&quot;No visible features in image&quot;</span><span class="p">}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">continue</span>

                <span class="c1"># render the visible features</span>
                <span class="n">intersects</span><span class="p">,</span> <span class="n">template_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

                <span class="c1"># initialize the lists to store things for the details</span>
                <span class="n">correlation_surfaces</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">correlation_peaks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">correlation_scores</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># initialize the observed bearings array</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">visible_features</span><span class="p">)),</span>
                                                              <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">image_use</span> <span class="o">=</span> <span class="n">image_32</span>

                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Registering Templates with Image...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># feature number is the number of the feature in the image</span>
                <span class="c1"># self.visible_features[target_ind][feature_number] is the index of the feature in the feature catalog</span>
                <span class="n">templates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">templates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">feature_number</span><span class="p">,</span> <span class="n">template</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">templates</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
                    
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_templates</span><span class="p">:</span>
                        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">visible_features</span><span class="p">[</span><span class="n">feature_number</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                    <span class="c1"># this shift corrects from the center of the template to the center of the feature in the template.</span>
                    <span class="c1"># the peak of the correlation surface gives the center of the template in the image, but we want the</span>
                    <span class="c1"># center of the feature in the image</span>
                    <span class="n">temp_middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="n">delta</span> <span class="o">=</span> <span class="n">temp_middle</span> <span class="o">-</span> <span class="n">template_centers</span><span class="p">[:,</span> <span class="n">feature_number</span><span class="p">]</span>
                    
                    <span class="n">computed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">feature_number</span><span class="p">]</span> <span class="c1"># type: ignore</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">computed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

                    <span class="c1"># if the search distance is greater than 50, attempt to use the normal correlator first since</span>
                    <span class="c1"># it will be faster and then shrink to a smaller search distance</span>
                    <span class="k">if</span> <span class="n">search_dist_use</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
                        <span class="c1"># get the correlation surface between the template and the full image</span>
                        <span class="n">temp_surf</span> <span class="o">=</span> <span class="n">cv2_correlator_2d</span><span class="p">(</span><span class="n">image_use</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span> <span class="c1"># type: ignore</span>

                        <span class="n">search_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">computed</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> 
                        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">search_start</span> <span class="o">-</span> <span class="n">search_dist_use</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">search_start</span> <span class="o">+</span> <span class="n">search_dist_use</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

                        <span class="n">temp_peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_finder</span><span class="p">(</span><span class="n">temp_surf</span><span class="p">[</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                                               <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">blur</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">temp_peak</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

                            <span class="n">search_center</span> <span class="o">=</span> <span class="n">temp_peak</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">actual_search_distance</span> <span class="o">=</span> <span class="mi">20</span>
                            <span class="n">adjustment</span> <span class="o">=</span> <span class="n">search_center</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">computed</span>

                        <span class="k">else</span><span class="p">:</span>

                            <span class="c1"># if that failed then fall back to the sfn correlator</span>
                            <span class="n">search_center</span> <span class="o">=</span> <span class="n">computed</span> <span class="o">+</span> <span class="n">delta</span> 
                            <span class="n">actual_search_distance</span> <span class="o">=</span> <span class="n">search_dist_use</span>
                            <span class="n">adjustment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if less than 50 then just proceed</span>
                        <span class="n">search_center</span> <span class="o">=</span> <span class="n">computed</span> <span class="o">+</span> <span class="n">delta</span> 
                        <span class="n">actual_search_distance</span> <span class="o">=</span> <span class="n">search_dist_use</span>
                        <span class="n">adjustment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                    <span class="c1"># set the kwargs for the correlator</span>
                    <span class="c1"># make the correlation surface and find the peak of it</span>
                    <span class="n">correlation_surfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sfn_correlator</span><span class="p">(</span><span class="n">image_use</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> 
                                                               <span class="n">space_mask</span><span class="o">=</span><span class="n">space_mask</span><span class="p">,</span> 
                                                               <span class="n">intersects</span><span class="o">=</span><span class="n">intersects</span><span class="p">[</span><span class="n">feature_number</span><span class="p">],</span> 
                                                               <span class="n">search_dist</span><span class="o">=</span><span class="n">actual_search_distance</span><span class="p">,</span> 
                                                               <span class="n">center_predicted</span><span class="o">=</span><span class="n">search_center</span><span class="p">))</span>

                    <span class="n">correlation_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_finder</span><span class="p">(</span><span class="n">correlation_surfaces</span><span class="p">[</span><span class="n">feature_number</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">blur</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

                    <span class="c1"># check if we found a valid peak for this feature.  If so save the score and the location of the</span>
                    <span class="c1"># feature  in the image</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">correlation_peaks</span><span class="p">[</span><span class="n">feature_number</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">rounded_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">correlation_peaks</span><span class="p">[</span><span class="n">feature_number</span><span class="p">])</span>
                        <span class="n">correlation_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">correlation_surfaces</span><span class="p">[</span><span class="n">feature_number</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">rounded_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rounded_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                        <span class="p">)</span>

                        <span class="k">if</span> <span class="n">correlation_scores</span><span class="p">[</span><span class="n">feature_number</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_corr_score</span><span class="p">:</span>
                            <span class="n">correlation_peaks</span><span class="p">[</span><span class="n">feature_number</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                            <span class="c1"># correlation_scores[feature_number] = 0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">correlation_peaks</span><span class="p">[</span><span class="n">feature_number</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">correlation_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">adjustment</span> <span class="o">+=</span> <span class="n">correlation_peaks</span><span class="p">[</span><span class="n">feature_number</span><span class="p">]</span> <span class="o">-</span> <span class="n">actual_search_distance</span>

                    <span class="n">observed</span> <span class="o">=</span> <span class="n">computed</span> <span class="o">+</span> <span class="n">adjustment</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">feature_number</span><span class="p">]</span> <span class="o">=</span>  <span class="n">observed</span>  <span class="c1"># type: ignore</span>

                    <span class="c1"># Print shift and correlation score:</span>
                    <span class="n">feature_name</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">visible_features</span><span class="p">[</span><span class="n">feature_number</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">feature_number</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="c1"># type: ignore</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">feature_name</span><span class="si">}</span><span class="s2"> :  Landmark location could be not be identified.&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Peak correlation score is </span><span class="si">{</span><span class="n">correlation_scores</span><span class="p">[</span><span class="n">feature_number</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">shift_to_print</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">observed</span> <span class="o">-</span> <span class="n">computed</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># type: ignore</span>

                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">feature_name</span><span class="si">}</span><span class="s2"> : </span><span class="si">{</span><span class="n">shift_to_print</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;9.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">shift_to_print</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;9.3f</span><span class="si">}</span><span class="s2"> | &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">correlation_scores</span><span class="p">[</span><span class="n">feature_number</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">))</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">/10&quot;</span><span class="p">,</span>
                              <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_templates</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                <span class="n">all_observed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
                <span class="n">all_computed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">all_observed</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">all_computed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># compute statistics on the results and print them</span>
                    <span class="n">diffs</span> <span class="o">=</span> <span class="n">all_observed</span> <span class="o">-</span> <span class="n">all_computed</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">diffed_mean</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">diffed_std</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">valid</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1"> landmarks found.&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Residual mean: </span><span class="si">{</span><span class="n">diffed_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">diffed_mean</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Residual std: </span><span class="si">{</span><span class="n">diffed_std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">diffed_std</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># PnP Solver:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_pnp_solver</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iteration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># check for which landmarks are valid</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">all_observed</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># check that we have enough points to solve the PnP problem effectively</span>
                    <span class="k">if</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>

                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Solving Perspective-n-Point problem to adjust camera Pose...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">delta_pos</span><span class="p">,</span> <span class="n">delta_quat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnp_solver</span><span class="p">(</span><span class="n">target_ind</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">)</span>

                        <span class="c1"># if we got a valid shift report it and continue to the next iteration, otherwise break and just</span>
                        <span class="c1"># stick with what we&#39;ve got</span>
                        <span class="k">if</span> <span class="n">delta_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">delta_quat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shifting target position by: </span><span class="si">{</span><span class="n">delta_pos</span><span class="si">}</span><span class="s1"> km&#39;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Rotating target orientation by: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">delta_quat</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span><span class="si">}</span><span class="s1"> degrees&#39;</span><span class="p">,</span>
                                  <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                            <span class="c1"># Update scene to reflect the change:</span>
                            <span class="n">target</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">delta_pos</span><span class="p">)</span>
                            <span class="n">target</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">delta_quat</span><span class="p">)</span>

                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Re-running SFN after PnP solve.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;Decreasing search distance from </span><span class="si">{</span><span class="n">search_dist_use</span><span class="si">}</span><span class="s1"> to &#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">second_search_region</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                            <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;PnP Solution&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                                        <span class="s2">&quot;PnP Translation&quot;</span><span class="p">:</span> <span class="n">delta_pos</span><span class="p">,</span>
                                                        <span class="s2">&quot;PnP Rotation&quot;</span><span class="p">:</span> <span class="n">delta_quat</span><span class="p">,</span>
                                                        <span class="s2">&quot;PnP Position&quot;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                                        <span class="s2">&quot;PnP Orientation&quot;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">copy</span><span class="p">()}</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not compute PnP solution&#39;</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Correlation Scores&quot;</span><span class="p">:</span> <span class="n">correlation_scores</span><span class="p">,</span>
                                                        <span class="s2">&quot;Visible Features&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>
                                                        <span class="s2">&quot;Correlation Peak Locations&quot;</span><span class="p">:</span> <span class="n">correlation_peaks</span><span class="p">,</span>
                                                        <span class="s2">&quot;Correlation Surfaces&quot;</span><span class="p">:</span> <span class="n">correlation_surfaces</span><span class="p">,</span>
                                                        <span class="s2">&quot;Target Template Coordinates&quot;</span><span class="p">:</span> <span class="n">template_centers</span><span class="p">,</span>
                                                        <span class="s2">&quot;Intersect Masks&quot;</span><span class="p">:</span> <span class="n">intersects</span><span class="p">,</span>
                                                        <span class="s2">&quot;Space Mask&quot;</span><span class="p">:</span> <span class="n">space_mask</span><span class="p">,</span>
                                                        <span class="s2">&quot;PnP Solution&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
                            <span class="k">break</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Insufficient number of landmarks identified to perform PnP.&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Correlation Scores&quot;</span><span class="p">:</span> <span class="n">correlation_scores</span><span class="p">,</span>
                                                    <span class="s2">&quot;Visible Features&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>
                                                    <span class="s2">&quot;Correlation Peak Locations&quot;</span><span class="p">:</span> <span class="n">correlation_peaks</span><span class="p">,</span>
                                                    <span class="s2">&quot;Correlation Surfaces&quot;</span><span class="p">:</span> <span class="n">correlation_surfaces</span><span class="p">,</span>
                                                    <span class="s2">&quot;Target Template Coordinates&quot;</span><span class="p">:</span> <span class="n">template_centers</span><span class="p">,</span>
                                                    <span class="s2">&quot;Intersect Masks&quot;</span><span class="p">:</span> <span class="n">intersects</span><span class="p">,</span>
                                                    <span class="s2">&quot;Space Mask&quot;</span><span class="p">:</span> <span class="n">space_mask</span><span class="p">,</span>
                                                    <span class="s2">&quot;PnP Solution&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
                        <span class="k">break</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;Correlation Scores&quot;</span><span class="p">:</span> <span class="n">correlation_scores</span><span class="p">,</span> <span class="c1"># type: ignore</span>
                                                 <span class="s2">&quot;Visible Features&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>
                                                 <span class="s2">&quot;Correlation Peak Locations&quot;</span><span class="p">:</span> <span class="n">correlation_peaks</span><span class="p">,</span>
                                                 <span class="s2">&quot;Correlation Surfaces&quot;</span><span class="p">:</span> <span class="n">correlation_surfaces</span><span class="p">,</span>
                                                 <span class="s2">&quot;Target Template Coordinates&quot;</span><span class="p">:</span> <span class="n">template_centers</span><span class="p">,</span>
                                                 <span class="s2">&quot;Intersect Masks&quot;</span><span class="p">:</span> <span class="n">intersects</span><span class="p">,</span>
                                                 <span class="s2">&quot;Space Mask&quot;</span><span class="p">:</span> <span class="n">space_mask</span><span class="p">})</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Correlation Scores&quot;</span><span class="p">:</span> <span class="n">correlation_scores</span><span class="p">,</span>
                                            <span class="s2">&quot;Visible Features&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>
                                            <span class="s2">&quot;Correlation Peak Locations&quot;</span><span class="p">:</span> <span class="n">correlation_peaks</span><span class="p">,</span>
                                            <span class="s2">&quot;Correlation Surfaces&quot;</span><span class="p">:</span> <span class="n">correlation_surfaces</span><span class="p">,</span>
                                            <span class="s2">&quot;Target Template Coordinates&quot;</span><span class="p">:</span> <span class="n">template_centers</span><span class="p">,</span>
                                            <span class="s2">&quot;Intersect Masks&quot;</span><span class="p">:</span> <span class="n">intersects</span><span class="p">,</span>
                                            <span class="s2">&quot;Space Mask&quot;</span><span class="p">:</span> <span class="n">space_mask</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">processed</span><span class="p">:</span>
                <span class="n">target_number</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Target </span><span class="si">{</span><span class="n">target_number</span><span class="si">}</span><span class="s1"> complete in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SurfaceFeatureNavigation.pnp_solver">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/sfn_class/giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.pnp_solver.html#giant.relative_opnav.estimators.sfn.sfn_class.SurfaceFeatureNavigation.pnp_solver">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pnp_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method attempts to solve for an update to the relative position/orientation of the target with respect to</span>
<span class="sd">        the image based on the observed feature locations in the image.</span>

<span class="sd">        We solve the PnP problem here looking for an update (ie not trying to solve the lost in space problem).  This is</span>
<span class="sd">        done for 2 reasons.  First, it reflects what we&#39;re doing.  In order to find the surface features in the image we</span>
<span class="sd">        need some reasonable a priori knowledge of the relative position/orientation between the camera and the target</span>
<span class="sd">        so we might as well use it (since it makes things simpler).  Second, because the PnP problem can be fickle,</span>
<span class="sd">        especially if the observations are noisy (as they can sometimes be if our a priori knowledge was not the</span>
<span class="sd">        greatest) by solving for an update we force it to stay near the a priori knowledge which helps to prevent</span>
<span class="sd">        outlandish solutions, even when there are very few points available.</span>

<span class="sd">        Because we are doing an update PnP solution we simply solve a nonlinear least squares problem for the</span>
<span class="sd">        translation and rotation (cast as a 3 element rotation vector) that minimizes the error between the predicted</span>
<span class="sd">        feature locations in the image and the observed feature locations.  This is generally robust and fast,</span>
<span class="sd">        especially since we can easily compute the analytic Jacobian for the least squares problem.  Specifically, the</span>
<span class="sd">        problem we are trying to minimize is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{r}_i = \mathbf{y}_i-f\left((\mathbf{I}-[\boldsymbol{\delta\theta}\times])</span>
<span class="sd">            (\mathbf{x}_i+\mathbf{d})\right) \\</span>
<span class="sd">            \min_{\mathbf{d},\boldsymbol{\delta\theta}}\left\{\sum_i \mathbf{r}_i^T\mathbf{r}_i\right\}</span>

<span class="sd">        where :math:`\mathbf{d}` is the shift, :math:`\boldsymbol{\delta\theta}` is the rotation vector,</span>
<span class="sd">        :math:`\mathbf{y}_i` is the observed location of the :math:`i^{th}` features, :math:`\mathbf{x}_i` is the</span>
<span class="sd">        location of the :math:`i^{th}` feature center in the current a priori camera frame, :math:`\mathbf{I}` is a</span>
<span class="sd">        3x3 identity matrix, and :math:`f(\bullet)` is the function which transforms points in the camera frame to</span>
<span class="sd">        points in the image (:meth:`.CameraModel.project_onto_image`).</span>

<span class="sd">        In addition, we provide the option to use RANSAC when solving the PnP problem to attempt to reject outliers in</span>
<span class="sd">        the solution.  This is very useful and should typically be used when possible (RANSAC will not be used when the</span>
<span class="sd">        number of observed features is less than 8).  We implement a typical RANSAC algorithm, where we choose a</span>
<span class="sd">        subsample of the available measurements, compute the PnP solution using the sample, and then compute the</span>
<span class="sd">        statistics/number of inliers from the full set of measurements given the estimated location from the sample,</span>
<span class="sd">        keeping the one with the most inliers and lowest statistics.</span>

<span class="sd">        To apply the results of this method to a scene object you should do ``object.translate(shift)`` and then</span>
<span class="sd">        ``object.rotate(rotation)`` where ``object`` is the scene object, ``shift`` is the shift vector from this</span>
<span class="sd">        method, and ``rotation`` is the rotation from this method (note translate first, then rotate).</span>

<span class="sd">        :param target_ind: The index of the target that we are currently doing the PnP problem with respect to</span>
<span class="sd">        :param image: The image that we are currently solving the PnP problem for</span>
<span class="sd">        :param image_ind: The index of the image that we are solving the PnP problem for. (This only really matters if</span>
<span class="sd">                          you still have per image misalignments in your camera model still for some reason)</span>
<span class="sd">        :return: The best fit shift as a length 3 numpy array in km and rotation as a :class:`.Rotation` to go from the</span>
<span class="sd">                 current camera frame to the new camera frame if successful or ``None``, ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first identify outliers</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">computed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">valid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># type: ignore</span>

        <span class="n">a_priori_residuals</span> <span class="o">=</span> <span class="n">observed</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span> <span class="o">-</span> <span class="n">computed</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span>

        <span class="n">a_priori_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a_priori_residuals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># check for outliers</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">get_outliers</span><span class="p">(</span><span class="n">a_priori_errors</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">valid</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">outliers</span>

        <span class="c1"># get the valid image points</span>
        <span class="n">image_points</span> <span class="o">=</span> <span class="n">observed</span><span class="p">[:,</span> <span class="n">valid</span><span class="p">]</span>

        <span class="c1"># get the location of the features in the current camera frame</span>
        <span class="n">visible_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visible_features</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">visible_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">FeatureCatalog</span><span class="p">)</span>
        <span class="n">valid_lmk_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">visible_features</span><span class="p">)</span> <span class="k">if</span> <span class="n">valid</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>
        <span class="n">world_points</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">feature_locations</span><span class="p">[</span><span class="n">valid_lmk_inds</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pnp_ransac_iterations</span><span class="p">:</span>

            <span class="n">best_rotation</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">best_translation</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">best_inliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="n">best_standard_deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
            <span class="n">best_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

            <span class="c1"># we can only do ransac if there are at least 10 points</span>
            <span class="k">if</span> <span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="c1"># choose at most 10 at a time</span>
                <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">RandomCombinations</span><span class="p">(</span><span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">pnp_ransac_iterations</span><span class="p">):</span>

                    <span class="c1"># solve the least squares problem given the current subset</span>
                    <span class="n">shift</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lls</span><span class="p">(</span><span class="n">world_points</span><span class="p">[:,</span> <span class="n">combination</span><span class="p">],</span> <span class="n">image_points</span><span class="p">[:,</span> <span class="n">combination</span><span class="p">],</span>
                                                <span class="n">image</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">)</span>

                    <span class="c1"># if we failed move on</span>
                    <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># reproject the points and find inliers</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="p">(</span><span class="n">world_points</span> <span class="o">+</span> <span class="n">shift</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                                             <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_ind</span><span class="p">)</span> <span class="o">-</span>
                        <span class="n">image_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>

                    <span class="n">inliers</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_search_region</span>

                    <span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                    <span class="n">mean</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

                    <span class="c1"># if we got a good solution</span>
                    <span class="k">if</span> <span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
                        <span class="c1"># if we have more inliers and our standard deviation is at least within 20% of the current best</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">best_inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">standard_deviation</span> <span class="o">&lt;</span> <span class="n">best_standard_deviation</span><span class="o">*</span><span class="mf">1.2</span><span class="p">):</span>
                            <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
                            <span class="n">best_translation</span> <span class="o">=</span> <span class="n">shift</span>
                            <span class="n">best_inliers</span> <span class="o">=</span> <span class="n">inliers</span>
                            <span class="n">best_standard_deviation</span> <span class="o">=</span> <span class="n">standard_deviation</span>
                            <span class="n">best_mean</span> <span class="o">=</span> <span class="n">mean</span>
                        <span class="k">elif</span> <span class="p">((</span><span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">best_inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="ow">and</span>
                              <span class="p">(</span><span class="n">standard_deviation</span> <span class="o">&lt;</span> <span class="n">best_standard_deviation</span><span class="o">*</span><span class="mf">0.8</span><span class="p">)):</span>
                            <span class="c1"># if we are within 2 inliers of the other but our standard deviation is significantly better</span>
                            <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
                            <span class="n">best_translation</span> <span class="o">=</span> <span class="n">shift</span>
                            <span class="n">best_inliers</span> <span class="o">=</span> <span class="n">inliers</span>
                            <span class="n">best_standard_deviation</span> <span class="o">=</span> <span class="n">standard_deviation</span>
                            <span class="n">best_mean</span> <span class="o">=</span> <span class="n">mean</span>

                <span class="c1"># at this point print out the best RANSAC solution</span>
                <span class="k">if</span> <span class="n">best_inliers</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">assert</span> <span class="n">best_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">best_translation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;best inliers = </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;resid std, mean = </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_standard_deviation</span><span class="p">,</span> <span class="n">best_mean</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;best rotation = </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">best_rotation</span><span class="o">.</span><span class="n">vector</span><span class="p">)))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;best translation = </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">best_translation</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># try to solve the LLS using all of the inliers from the best case</span>
                    <span class="n">new_trans</span><span class="p">,</span> <span class="n">new_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lls</span><span class="p">(</span><span class="n">world_points</span><span class="p">[:,</span> <span class="n">best_inliers</span><span class="p">],</span> <span class="n">image_points</span><span class="p">[:,</span> <span class="n">best_inliers</span><span class="p">],</span>
                                                   <span class="n">image</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">new_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_rot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">new_rot</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="p">(</span><span class="n">world_points</span> <span class="o">+</span> <span class="n">new_trans</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                                                <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_ind</span><span class="p">)</span> <span class="o">-</span>
                            <span class="n">image_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>

                        <span class="n">inliers</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_search_region</span>
                        <span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                        <span class="n">mean</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inlier rotation = </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">new_rot</span><span class="o">.</span><span class="n">vector</span><span class="p">)))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inlier translation = </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">new_trans</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inlier inliers, std, mean = </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">mean</span><span class="p">),</span>
                            <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># keep either the original best or the fit of the inliers, depending on which is better</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">best_inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">standard_deviation</span> <span class="o">&lt;</span> <span class="n">best_standard_deviation</span><span class="p">):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;keeping new stuff&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">new_rot</span>
                            <span class="n">best_translation</span> <span class="o">=</span> <span class="n">new_trans</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">best_inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">standard_deviation</span> <span class="o">&lt;</span> <span class="n">best_standard_deviation</span><span class="o">*</span><span class="mf">1.2</span><span class="p">):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;keeping new stuff&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">new_rot</span>
                            <span class="n">best_translation</span> <span class="o">=</span> <span class="n">new_trans</span>
                        <span class="k">elif</span> <span class="p">((</span><span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">best_inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">mean</span> <span class="o">&lt;</span> <span class="n">best_mean</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">standard_deviation</span> <span class="o">&lt;</span> <span class="n">best_standard_deviation</span><span class="o">*</span><span class="mf">1.3</span><span class="p">)):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;keeping new stuff&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">new_rot</span>
                            <span class="n">best_translation</span> <span class="o">=</span> <span class="n">new_trans</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just do lstsq on everything</span>
                <span class="n">shift</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lls</span><span class="p">(</span><span class="n">world_points</span><span class="p">,</span> <span class="n">image_points</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">)</span>
                <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
                <span class="n">best_translation</span> <span class="o">=</span> <span class="n">shift</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just do lstsq on everything</span>
            <span class="n">shift</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lls</span><span class="p">(</span><span class="n">world_points</span><span class="p">,</span> <span class="n">image_points</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">)</span>
            <span class="n">best_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
            <span class="n">best_translation</span> <span class="o">=</span> <span class="n">shift</span>

        <span class="c1"># return the best</span>
        <span class="k">return</span> <span class="n">best_translation</span><span class="p">,</span> <span class="n">best_rotation</span>  <span class="c1"># type: ignore</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_lls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">image_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the PnP problem using Levenberg-Marquardt linearized least squares by a call to the</span>
<span class="sd">        :func:`least_squares` function from scipy.</span>

<span class="sd">        In this method we first determine the weighting matrix based on the provided sigmas for the state/measurements.</span>
<span class="sd">        We then create temporary functions which compute the residuals and the jacobian weighted by this weighting</span>
<span class="sd">        matrix.  We provide these to the :func:`scipy.optimize.least_squares` function along with an initial guess</span>
<span class="sd">        of 0 for both rotation and translation.</span>

<span class="sd">        Note that in the Jacobian and the residuals, we account for an update least squares problem by appending zeros</span>
<span class="sd">        and an identity matrix respectively.</span>

<span class="sd">        :param world_points: The feature centers in the original camera frame  as a 2xn array</span>
<span class="sd">        :param image_points: The observed pixel locations of each feature as a 2xn array</span>
<span class="sd">        :param image: The image we are solving the PnP for</span>
<span class="sd">        :param image_ind: The index of the image we are solving the PnP for</span>
<span class="sd">        :return: The best fit shift/rotation as a numpy array and a :class:`.Rotation` or ``None``s if the least squares</span>
<span class="sd">                 failed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># interpret the state sigma</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">position_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_sigma</span><span class="p">):</span>
                <span class="n">position_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_sigma</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">position_sigma</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_sigma</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attitude_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attitude_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attitude_sigma</span><span class="p">):</span>
                <span class="n">attitude_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attitude_sigma</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attitude_sigma</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attitude_sigma</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">position_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attitude_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">state_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">position_sigma</span><span class="p">,</span> <span class="n">attitude_sigma</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">state_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">position_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">state_sigma</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">position_sigma</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">state_sigma</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">position_sigma</span>
                <span class="k">if</span> <span class="n">attitude_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">state_sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">attitude_sigma</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">state_sigma</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">attitude_sigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_sigma</span><span class="p">)</span>

        <span class="c1"># interpret the measurement sigma</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measurement_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">image_points</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_sigma</span><span class="p">):</span>
            <span class="n">measurement_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">image_points</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">*</span><span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_sigma</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_sigma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">measurement_sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">*</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_sigma</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">measurement_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">measurement_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">measurement_sigma</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">measurement_number</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">measurement_number</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                  <span class="mi">2</span><span class="o">*</span><span class="n">measurement_number</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">measurement_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_sigma</span>

        <span class="c1"># form the sigma matrix</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">state_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sigma_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">measurement_sigma</span><span class="p">,</span> <span class="n">state_sigma</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">measurement_sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sigma_matrix_shape</span> <span class="o">=</span> <span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">state_sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sigma_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sigma_matrix_shape</span><span class="p">,</span> <span class="n">sigma_matrix_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">sigma_matrix</span><span class="p">[:</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">:</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">measurement_sigma</span><span class="p">)</span>
            <span class="n">sigma_matrix</span><span class="p">[</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">:,</span> <span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">state_sigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma_matrix_shape</span> <span class="o">=</span> <span class="n">measurement_sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">state_sigma</span><span class="o">.</span><span class="n">size</span>
            <span class="n">sigma_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sigma_matrix_shape</span><span class="p">,</span> <span class="n">sigma_matrix_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">sigma_matrix</span><span class="p">[:</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">:</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">measurement_sigma</span>
            <span class="n">sigma_matrix</span><span class="p">[</span><span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">:,</span> <span class="n">measurement_sigma</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">state_sigma</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">measurement_sigma</span><span class="p">,</span> <span class="n">state_sigma</span>

        <span class="c1"># interpret the sigma matrix into the transform matrix (inspired by curve_fit from scipy)</span>
        <span class="k">if</span> <span class="n">sigma_matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transform_matrix</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">sigma_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># do the Cholesky of the sigma matrix</span>
            <span class="n">transform_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">sigma_matrix</span><span class="p">)</span>

        <span class="c1"># create the function we are trying to fit</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">pnp_residual_function</span><span class="p">(</span><span class="n">state_update</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="c1"># get the updated world points</span>
            <span class="n">updated_world_points</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">state_update</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span><span class="o">@</span><span class="p">(</span><span class="n">world_points</span> <span class="o">+</span> <span class="n">state_update</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># compute the observed - computed residuals.</span>
            <span class="n">resids_omc</span> <span class="o">=</span> <span class="n">image_points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">updated_world_points</span><span class="p">,</span>
                                                                             <span class="n">image</span><span class="o">=</span><span class="n">image_ind</span><span class="p">,</span>
                                                                             <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

            <span class="c1"># append 0s at the end because we are doing an update to stay closer to the original</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">resids_omc</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span>

            <span class="c1"># apply the sigmas depending on the number of dimensions</span>
            <span class="k">if</span> <span class="n">transform_matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out</span> <span class="o">*</span> <span class="n">transform_matrix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">transform_matrix</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="c1"># create the function that computes the jacobian matrix (2n+6 x 6) for the function we are trying to fit</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">pnp_jacobian_function</span><span class="p">(</span><span class="n">state_update</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

            <span class="c1"># get the updated world points</span>
            <span class="n">shifted_world_points</span> <span class="o">=</span> <span class="n">world_points</span> <span class="o">+</span> <span class="n">state_update</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">state_update</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>

            <span class="n">updated_world_points</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="nd">@shifted_world_points</span>

            <span class="c1"># build the jacobian matrix that predicts how a change in the world points changes the projected location of</span>
            <span class="c1"># the points</span>
            <span class="c1"># this is a n x 2 x 3 matrix</span>
            <span class="n">jac_ip_wrt_cp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compute_pixel_jacobian</span><span class="p">(</span><span class="n">updated_world_points</span><span class="p">,</span>
                                                                     <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span>
                                                                     <span class="n">image</span><span class="o">=</span><span class="n">image_ind</span><span class="p">)</span>

            <span class="c1"># build the jacobian matrix that predicts how a change in the orientation changes the projected location of</span>
            <span class="c1"># the points</span>
            <span class="c1"># this is a 2n x 3 matrix</span>
            <span class="n">jac_ip_wrt_or</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">jac_ip_wrt_cp</span> <span class="o">@</span> <span class="n">rot</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">shifted_world_points</span><span class="p">))</span> <span class="c1"># type: ignore</span>

            <span class="c1"># build the jacobian matrix that predicts how a change in the shift changes the projected location of</span>
            <span class="c1"># the points</span>
            <span class="c1"># this is a 2n x 3 matrix</span>
            <span class="n">jac_ip_wrt_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">jac_ip_wrt_cp</span><span class="nd">@rotation_matrix</span><span class="p">)</span> <span class="c1"># type: ignore</span>

            <span class="c1"># build the full jacobian matrix (the identity matrix at the bottom is because we are doing an update)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">jac_ip_wrt_shift</span><span class="p">,</span> <span class="n">jac_ip_wrt_or</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span>

            <span class="c1"># apply the transform matrix depending on the number of dimensions</span>
            <span class="k">if</span> <span class="n">transform_matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">transform_matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">out</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">transform_matrix</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="c1"># now solve the least squares problem</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">pnp_residual_function</span><span class="p">,</span>  <span class="c1"># function</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>  <span class="c1"># initial guess</span>
                            <span class="n">jac</span><span class="o">=</span><span class="n">pnp_jacobian_function</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span>  <span class="c1"># use Levenberg-Marquardt</span>
                            <span class="n">ftol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lsq_relative_error_tolerance</span><span class="p">,</span>  <span class="c1"># the tolerance in the change in residuals</span>
                            <span class="n">xtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lsq_relative_update_tolerance</span><span class="p">,</span>  <span class="c1"># tolerance in the update</span>
                            <span class="n">max_nfev</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lsq_iterations</span><span class="p">,</span>
                            <span class="n">x_scale</span><span class="o">=</span><span class="s1">&#39;jac&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="c1"># needed a better initial guess.  Do a single least squares fit</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">pnp_jacobian_function</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">pnp_residual_function</span><span class="p">(</span><span class="n">c</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">fit2</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">pnp_residual_function</span><span class="p">,</span>  <span class="c1"># function</span>
                                 <span class="n">guess</span><span class="p">,</span>  <span class="c1"># initial guess</span>
                                 <span class="n">jac</span><span class="o">=</span><span class="n">pnp_jacobian_function</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                                 <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span>  <span class="c1"># use Levenberg-Marquardt</span>
                                 <span class="n">ftol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lsq_relative_error_tolerance</span><span class="p">,</span>  <span class="c1"># the tolerance in the change in residuals</span>
                                 <span class="n">xtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lsq_relative_update_tolerance</span><span class="p">,</span>  <span class="c1"># tolerance in the update</span>
                                 <span class="n">max_nfev</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lsq_iterations</span><span class="p">,</span>
                                 <span class="n">x_scale</span><span class="o">=</span><span class="s1">&#39;jac&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fit2</span><span class="o">.</span><span class="n">cost</span> <span class="o">&lt;=</span> <span class="n">fit</span><span class="o">.</span><span class="n">cost</span><span class="p">):</span>
                <span class="n">fit</span> <span class="o">=</span> <span class="n">fit2</span>

        <span class="k">if</span> <span class="n">fit</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The PnP problem didn&#39;t converge&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">shift</span><span class="p">,</span> <span class="n">rotation</span> <span class="c1"># type: ignore</span></div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>