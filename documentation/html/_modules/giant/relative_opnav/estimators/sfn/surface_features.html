<!DOCTYPE html>

<html lang="en" data-content_root="../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.relative_opnav.estimators.sfn.surface_features &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../../index.html">
    <img class="logo" src="../../../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.relative_opnav.estimators.sfn.surface_features</h1><div class="highlight"><pre>
<span></span>


<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements the idea of a surface feature and surface feature catalog for GIANT.</span>

<span class="sd">Detailed Description</span>
<span class="sd">--------------------</span>

<span class="sd">In GIANT, a surface feature refers to a small path of surface from a body that is treated as an individual target to</span>
<span class="sd">identify in an image. A feature catalog is then a collection of these features that is used for tracking the features</span>
<span class="sd">together and determining which are visible/worthy to search for in a given image.  These capabilities are implemented in</span>
<span class="sd">the :class:`.SurfaceFeature`, :class:`.FeatureCatalog`, and :class:`.VisibleFeatureFinder` respectively.</span>

<span class="sd">In more detail, a :class:`.SurfaceFeature` in GIANT is essentially a wrapper around a DEM modeled as a traceable object</span>
<span class="sd">(a :class:`.KDTree` or :class:`.Shape`) that also contains some basic information about the DEM, including the normal</span>
<span class="sd">vector of the best fit plane through the DEM data, the center of the DEM, and the average ground sample distance of the</span>
<span class="sd">DEM.  Additionally, the :class:`.SurfaceFeature` class provides functionality for storing the DEM information itself on</span>
<span class="sd">disk until it is needed as well as managing at which point it can be unloaded from memory, which can be important for</span>
<span class="sd">long running processes.</span>

<span class="sd">The :class:`.FeatureCatalog` then stores a list of these features, as well as some numpy arrays which combine all of</span>
<span class="sd">the normal vectors, bounding box vertices, and locations into single contiguous arrays for computational efficiency.</span>
<span class="sd">These numpy arrays also get rotated/translated whenever the feature catalog gets rotated/translated, which means that</span>
<span class="sd">they are always in the current frame (which normally ends up being the camera frame). Additionally, this class provides</span>
<span class="sd">an option for filtering the features that are included when a call to the ``trace`` method is made.</span>

<span class="sd">Finally, the :class:`.VisibleFeatureFinder` operates on a feature catalog to identify which features are visible in an</span>
<span class="sd">image based on the current knowledge of the scene at the time of the image.  This filtering considers things like the</span>
<span class="sd">incidence and reflection angles, the ratio of the camera ground sample distance to the feature ground sample distance,</span>
<span class="sd">and the percentage of the feature predicted to actually be within the field of view of the camera.</span>

<span class="sd">For more in-depth details on each of these classes we encourage you to consider their documentation.</span>

<span class="sd">Lazy Loading/Unloading</span>
<span class="sd">----------------------</span>

<span class="sd">One of the key things about surface features are that they are usually pretty high resolution patches of surface (that</span>
<span class="sd">is patches of surface with small ground sample distances).  We can get away with these small ground sample distances</span>
<span class="sd">because the surface area each feature covers is also small, which means the size of any given feature is small.  Despite</span>
<span class="sd">this, we frequently have enough patches to globally cover the surface of the body we are imaging, and many times have</span>
<span class="sd">features that overlap each other so we actually have enough features to cover the surface 2-3 times over.  Beyond that,</span>
<span class="sd">we also typically have global coverage of the surface with features at varying ground sample distances.  All of this</span>
<span class="sd">combines to mean that feature catalogs are typically huge, particularly when compared with a typical global model for</span>
<span class="sd">a body.  In many cases, because of this size, it is infeasible or even impossible to store the entire feature catalog</span>
<span class="sd">in memory at once, even on modern systems.</span>

<span class="sd">To overcome this issue, we have implemented a lazy loading/unloading scheme for feature catalogs and surface features</span>
<span class="sd">in GIANT.  The way this scheme works is when we create a :class:`.SurfaceFeature`, instead of providing the DEM data</span>
<span class="sd">that represents the feature, we instead provide an absolute file path to a pickle file which contains just the DEM data</span>
<span class="sd">for the feature.  When doing this, the size of each :class:`.SurfaceFeature` object in the :class:`.FeatureCatalog` is</span>
<span class="sd">very small.  Then, when we actually need the DEM data for the feature, we load it into memory from the referenced file.</span>
<span class="sd">This dramatically decreases the memory footprint of our process, making it feasible to operate through a whole feature</span>
<span class="sd">catalog without using hundreds of GB of memory.</span>

<span class="sd">Now, this lazy loading is great at the start, but if we have a long running process that keeps using more and more</span>
<span class="sd">features we will eventually end up loading the entire feature catalog into memory anyway, which would ultimately</span>
<span class="sd">defeat the purpose of the lazy loading.  Therefore, we also provide an unloading mechanism, where the &quot;time&quot; since the</span>
<span class="sd">feature was last used (time here being the number of images since we last used the feature) is used to determine if we</span>
<span class="sd">should remove the feature from memory.  Additionally, we provide a check one the percentage of the total system memory</span>
<span class="sd">that the process is using and if we are over a certain percentage, we start unloading features regardless of when they</span>
<span class="sd">were last used.</span>

<span class="sd">The combination of the loading and unloading makes surface feature navigation possible in GIANT even on systems with</span>
<span class="sd">modest amounts of memory available to the system.  If you are working on a system with huge amounts of memory, you can</span>
<span class="sd">bypass these features, but for most people, even with large amounts of memory, we encourage leaving them on.  For more</span>
<span class="sd">details on how you can tune each of these capabilities, refer to the :class:`.FeatureCatalog` and</span>
<span class="sd">:class:`.SurfaceFeature` documentation.</span>

<span class="sd">One thing to note about using an absolute path to the file containing the DEM information for each feature is that it</span>
<span class="sd">makes feature catalogs brittle.  That is, unless the directory structure between 2 systems is the same, you cannot</span>
<span class="sd">directly transfer a feature catalog built on one system to another.  To help with doing this, we provide the methods</span>
<span class="sd">:meth:`.FeatureCatalog.update_feature_paths` and :meth:`.SurfaceFeature.update_path` which can be used to specify a</span>
<span class="sd">a new path for the files containing the surface feature DEMs.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">Generally a user will have minimal direct interaction with the classes in this module, as all of the interaction is</span>
<span class="sd">handled either by the :class:`.SurfaceFeatureNavigation` class for doing navigation or the</span>
<span class="sd">:mod:`.spc_to_feature_catalog` and :mod:`.tile_shape` scripts for importing/building a feature catalog.  If you do</span>
<span class="sd">need to interact directly with the classes in this documentation we encourage you to consult the class documentation</span>
<span class="sd">directly and to look at the use of these classes in the mentioned class/scripts for examples/insight.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span><span class="p">,</span> <span class="n">copy</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">psutil</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.shapes</span><span class="w"> </span><span class="kn">import</span> <span class="n">AxisAlignedBoundingBox</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.kdtree</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">Scene</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.rays</span><span class="w"> </span><span class="kn">import</span> <span class="n">INTERSECT_DTYPE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.rays</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera_models.camera_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">CameraModel</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NONENUM</span><span class="p">,</span> <span class="n">PATH</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span>


<span class="n">_PROCESS</span><span class="p">:</span> <span class="n">psutil</span><span class="o">.</span><span class="n">Process</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">Process</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module attribute contains the Process object for the current process at import time.</span>

<span class="sd">This is used to query memory use statistics for the system to use in the lazy load/unload evaluations.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="FeatureCatalog">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.html#giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FeatureCatalog</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents a collection of :class:`.SurfaceFeatures` for use in GIANT relative OpNav.</span>

<span class="sd">    In GIANT, a surface feature is used to represent a small patch of surface which we look for in an image to generate</span>
<span class="sd">    a bearing measurement to in the process of :class:`.SurfaceFeatureNavigation`.  Because we normally have many</span>
<span class="sd">    features in order to globally cover the surface, we need a special manager to handle all of these features, rather</span>
<span class="sd">    than making each one a :class:`.SceneObject` in a scene.  That is the purpose of this class.</span>

<span class="sd">    Essentially this class works as its own mini scene (in fact much of the code was copied from the :class:`.Scene`</span>
<span class="sd">    but without a :attr:`.Scene.light_obj`.  Somewhat confusingly though, this class is meant to be wrapped in a</span>
<span class="sd">    :class:`.SceneObject` and then stored as a :attr:`.Scene.target_obj` for processing.  To the user (and to the</span>
<span class="sd">    :class:`.Scene`) this will look like any other traceable object in GIANT for the most part.</span>

<span class="sd">    Internally, the features are filtered with the :attr:`include_features` attribute, which is a list of integer</span>
<span class="sd">    indices into the :attr:`features` list of which features to include while tracing.  Normally, however, a user won&#39;t</span>
<span class="sd">    interact with this attribute, which is instead handled by the :class:`.SurfaceFeatureNavigation` class.</span>

<span class="sd">    This class also collects some information about each feature into the :attr:`feature_normals`,</span>
<span class="sd">    :attr:`feature_locations`, and :attr:`feature_bounds` attributes, which are used to easily determine which features</span>
<span class="sd">    are visible for a given image in conjunction with the :class:`.VisibleFeatureFinder` class and the</span>
<span class="sd">    :class:`.SurfaceFeatureNavigation` class.</span>

<span class="sd">    Similar to a :class:`.KDTree`, when something requests to rotate or translate the feature catalog through the</span>
<span class="sd">    :meth:`rotate` and :meth:`translate` methods, the features themselves are not actually moved.  Instead the</span>
<span class="sd">    rotation/translation is stored and is used to rotate/translate the rays into the original feature catalog frame</span>
<span class="sd">    before ray tracing for performance reasons.  These methods do update the :attr:`feature_normals`,</span>
<span class="sd">    :attr:`feature_locations`, and :attr:`feature_bounds` attributes though.</span>

<span class="sd">    One of the keys of the :class:`.SurfaceFeature` class is that is provides a mechanism for lazy loading/unloading of</span>
<span class="sd">    the DEM data itself from memory.  This class provides 2 easy properties to change the control of this lazy</span>
<span class="sd">    load/unload through the :attr:`stale_count_unload_threshold` and :attr:`memory_percent_unload_threshold` which can</span>
<span class="sd">    be used to change the corresponding settings for all features in the catalog.</span>

<span class="sd">    Creating a feature catalog is a difficult process which has largely be automated into the</span>
<span class="sd">    :mod:`.spc_to_feature_catalog` and :mod:`.tile_shape` scripts, which we encourage you to consider at least as</span>
<span class="sd">    examples if you are building your own.  If you are making your own, once you have your list of</span>
<span class="sd">    :class:`.SurfaceFeature` objects, if you are using the lazy load/unload functionality, you should also provide a</span>
<span class="sd">    corresponding list of dictionaries which contain the bounding box vertices under key ``&#39;bounds&#39;`` and the feature</span>
<span class="sd">    DEM order under key ``&#39;order&#39;``.  Again, for an example of how to do this consider the :mod:`.tile_shape` script.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;SurfaceFeature&#39;</span><span class="p">],</span>
                 <span class="n">map_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;SurfaceFeature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">features</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of surface features contained in the catalog.</span>
<span class="sd">        </span>
<span class="sd">        Each element should be a :class:`.SurfaceFeature` object which describes the surface feature.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the largest order of any of the shapes used to represent the features.</span>
<span class="sd">                </span>
<span class="sd">        This is used to determine which ignore indices apply to the features in this catalog, for cases where multiple</span>
<span class="sd">        targets are included in a :class:`.Scene`.  In general a user does not need to worry about this number and </span>
<span class="sd">        should not modify it themselves</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_id_order</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">)))</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the number of digits required to represent all of the features in this catalog.</span>
<span class="sd">                </span>
<span class="sd">        This is used to determine which ignore indices apply to the features in this catalog, for cases where multiple</span>
<span class="sd">        targets are included in a :class:`.Scene`.  In general a user does not need to worry about this number and </span>
<span class="sd">        should not modify it themselves</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># temp variables for getting the bounds/locations/normals</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">find</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
            
            <span class="n">normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
            <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">body_fixed_center</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">feature</span><span class="o">.</span><span class="n">loaded</span> <span class="ow">and</span> <span class="p">(</span><span class="n">map_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">map_info</span><span class="p">[</span><span class="n">find</span><span class="p">][</span><span class="s1">&#39;order&#39;</span><span class="p">]))</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">map_info</span><span class="p">[</span><span class="n">find</span><span class="p">][</span><span class="s1">&#39;bounds&#39;</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">feature</span><span class="o">.</span><span class="n">bounding_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">forder</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="n">forder</span><span class="p">)</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">fnum_faces</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;num_faces&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">fnum_faces</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">normals</span><span class="p">:</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The normal vectors of the best fit plane for each feature expressed in the current external frame as a nx3 </span>
<span class="sd">        numpy array.</span>
<span class="sd">        </span>
<span class="sd">        Each row of this matrix corresponds to the same index into the :attr:`features` attribute.</span>
<span class="sd">        </span>
<span class="sd">        These vectors are rotated whenever the :meth:`rotate` method is called, therefore they should always be </span>
<span class="sd">        expressed in the internal frame (for instance in the camera frame), not in the base catalog frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The vertices of the bounding box of every feature as a nx3x8 numpy array.</span>

<span class="sd">        Each slice along the first axis of this matrix corresponds to the same index into the :attr:`features` </span>
<span class="sd">        attribute.</span>

<span class="sd">        These vectors are rotated whenever the :meth:`rotate` method is called and translated whenever the </span>
<span class="sd">        :meth:`translate` method is called, therefore they should always be </span>
<span class="sd">        expressed in the internal frame (for instance in the camera frame, not in the base catalog frame).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">locations</span><span class="p">:</span>
            <span class="n">locations</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_locations</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The vectors to the center of each feature expressed in the current external frame as a nx3 numpy array.</span>

<span class="sd">        Each row of this matrix corresponds to the same index into the :attr:`features` attribute.</span>

<span class="sd">        These vectors are rotated whenever the :meth:`rotate` method is called and translated whenever the </span>
<span class="sd">        :meth:`translate` method is called, therefore they should always be </span>
<span class="sd">        expressed in the internal frame (for instance in the camera frame, not in the base catalog frame).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">include_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of features to include when tracing this feature catalog.</span>
<span class="sd">        </span>
<span class="sd">        The list should contain the indices into the :attr:`features` list of the features that you want to trace.  </span>
<span class="sd">        </span>
<span class="sd">        If this is not specified, it is assumed that you want to trace all of the features in the scene and special </span>
<span class="sd">        handling is performed to see which are actually needed, so that only those are loaded into memory, as described </span>
<span class="sd">        in the :meth:`trace` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Rotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rotation that goes from the external frame to the original catalog frame.</span>
<span class="sd">        </span>
<span class="sd">        Note that this is the inverse of the rotation applied through the :meth:`rotate` method, and it is </span>
<span class="sd">        multiplicatively updated, not overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The translation vector that goes from the external frame to the original catalog frame.</span>
<span class="sd">        </span>
<span class="sd">        Note that this is the negative of the translation applied through the :meth:`translate` method, rotated into the </span>
<span class="sd">        original catalog frame and added to any existing position.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_bounding_boxes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">AxisAlignedBoundingBox</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary mapping feature index to :class:`.AxisAlignedBoundingBox` expressed in the original feature frame.</span>
<span class="sd">        </span>
<span class="sd">        This is only used when :attr:`include_features` is ``None`` and the :meth:`trace` method is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stale_count_unload_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The current stale count unload threshold for all of the features in the catalog.</span>

<span class="sd">        If this is ``None`` on a call to the :attr:`stale_count_unload_threshold` property, we&#39;ll just grab the value </span>
<span class="sd">        from the first feature in the list.  If we set to the :attr:`stale_count_unload_threshold` property well </span>
<span class="sd">        update this and all of the features in the catalog.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_percent_unload_threshold</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The current memory percent unload threshold for all of the features in the catalog.</span>
<span class="sd">        </span>
<span class="sd">        If this is ``None`` on a call to the :attr:`memory_percent_unload_threshold` property, we&#39;ll just grab the value </span>
<span class="sd">        from the first feature in the list.  If we set to the :attr:`memory_percent_unload_threshold` property well </span>
<span class="sd">        update this and all of the features in the catalog.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_finder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">CameraModel</span><span class="p">,</span> <span class="n">Scene</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is used to determine the visible features in the catalog.</span>
<span class="sd">        </span>
<span class="sd">        It will typically be an instance of the :class:`.VisibleFeatureFinder`.  </span>
<span class="sd">        </span>
<span class="sd">        We do not set this at initialization because it is typically set at run time and is frequently changed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the number of digits reserved for specifying facet ids for features in this catalog</span>
<span class="sd">                </span>
<span class="sd">        This is used to determine which ignore indices apply to the features in this catalog, for cases where multiple</span>
<span class="sd">        targets are included in a :class:`.Scene`.  In general a user does not need to worry about this number and </span>
<span class="sd">        should not modify it themselves</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_order</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stale_count_unload_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of times :meth:`not_found` must be called since the last :meth:`found` was called for a feature to</span>
<span class="sd">        be unloaded from memory.</span>

<span class="sd">        Setting to this property will change this value for all features contained in the catalog.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stale_count_unload_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stale_count_unload_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stale_count_unload_threshold</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stale_count_unload_threshold</span>

    <span class="nd">@stale_count_unload_threshold</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stale_count_unload_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stale_count_unload_threshold</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="n">feature</span><span class="o">.</span><span class="n">stale_count_unload_threshold</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">feature_finder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CameraModel</span><span class="p">,</span> <span class="n">Scene</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property returns the feature finder for this class, which is a callable that takes in a camera model,</span>
<span class="sd">        scene, and temperature and returns a list of indices into the :attr:`features` list and related.</span>

<span class="sd">        Typically this is an instance of :class:`.VisibleFeatureFinder`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_finder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_feature_finder</span> <span class="o">=</span> <span class="n">VisibleFeatureFinder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_finder</span>

    <span class="nd">@feature_finder</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">feature_finder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CameraModel</span><span class="p">,</span> <span class="n">Scene</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_finder</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">memory_percent_unload_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The memory percentage used by the current process at which point we begin unloading features that are not found</span>
<span class="sd">        regardless of how long its been since a feature was used.</span>

<span class="sd">        If you trust your system to handle swap appropriately you can set this to some value greater than 100 which will</span>
<span class="sd">        effectively disable this check.</span>

<span class="sd">        If you plan to run multiple instances of GIANT/SFN at the same time then you should probably set this value</span>
<span class="sd">        lower so that you limit the resources they are fighting over.</span>

<span class="sd">        Setting to this property will change this value for all features contained in the catalog.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_percent_unload_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_memory_percent_unload_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">memory_percent_unload_threshold</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_percent_unload_threshold</span>

    <span class="nd">@memory_percent_unload_threshold</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">memory_percent_unload_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_percent_unload_threshold</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="n">feature</span><span class="o">.</span><span class="n">memory_percent_unload_threshold</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="FeatureCatalog.update_feature_paths">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.update_feature_paths.html#giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.update_feature_paths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_feature_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_path</span><span class="p">:</span> <span class="n">PATH</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method goes through and updates the directory structure for each feature contained in the catalog.</span>

<span class="sd">        Updates are made through a call to :meth:`.SurfaceFeature.update_path`.  With the update, we are just changing</span>
<span class="sd">        the directory structure, not the file itself.  Therefore the input should end with a director, not a file, and</span>
<span class="sd">        the existing file name for each feature will be joined to this directory structure.</span>

<span class="sd">        For any features which do not make use of the lazy loading/unloading capabilities nothing will happen.</span>

<span class="sd">        :param new_path: The new directory structure to traverse to find the DEM file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>

            <span class="n">feature</span><span class="o">.</span><span class="n">update_path</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__init_from_pickle__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;SurfaceFeature&#39;</span><span class="p">],</span>
                             <span class="n">bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">normals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">locations</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">rotation</span><span class="p">:</span> <span class="n">Rotation</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">feature_bounding_boxes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">AxisAlignedBoundingBox</span><span class="p">],</span>
                             <span class="n">include_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">id_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FeatureCatalog&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class method is used to initialize the class from pickle, instead of you usual init method.</span>

<span class="sd">        Don&#39;t use this yourself!</span>

<span class="sd">        :param features: The list of features</span>
<span class="sd">        :param bounds: The vertices of the bounding boxes of the features as a nx3x18 array in the current frame</span>
<span class="sd">        :param normals: The normal vectors of the surface features in the current frame</span>
<span class="sd">        :param locations: The center of the features in the current frame</span>
<span class="sd">        :param rotation: The rotation from the external frame to the internal frame</span>
<span class="sd">        :param position: The translation from the external frame to the internal frame</span>
<span class="sd">        :param feature_bounding_boxes: A dictionary mapping feature index to an AxisAlignedBoundingBox in the original</span>
<span class="sd">                                       feature frame.  Usually this is empty</span>
<span class="sd">        :param include_features: A list of integers specifying which features to consider when tracing</span>
<span class="sd">        :param order: The order of the identity for this feature catalog, used to identify whether ignore indices</span>
<span class="sd">                      apply to it.</span>
<span class="sd">        :return: An initialized version of the class</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([])</span>

        <span class="n">out</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="n">features</span>
        <span class="n">out</span><span class="o">.</span><span class="n">feature_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="n">out</span><span class="o">.</span><span class="n">feature_normals</span> <span class="o">=</span> <span class="n">normals</span>
        <span class="n">out</span><span class="o">.</span><span class="n">feature_locations</span> <span class="o">=</span> <span class="n">locations</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_feature_bounding_boxes</span> <span class="o">=</span> <span class="n">feature_bounding_boxes</span>
        <span class="n">out</span><span class="o">.</span><span class="n">include_features</span> <span class="o">=</span> <span class="n">include_features</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">id_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_id_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_id_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">id_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to control how this class is pickled/unpickled</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_from_pickle__</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_normals</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">feature_locations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_feature_bounding_boxes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id_order</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AxisAlignedBoundingBox</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The approximate axis aligned bounding box of all of the features in the catalog.</span>

<span class="sd">        This is found by finding the minimum/maximum bound of the bounding box vertices (:attr:`feature_bounds`)</span>
<span class="sd">        rotated/translated into the current frame.  As such, it is only a rough estimate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># noinspection PyArgumentList</span>
        <span class="k">return</span> <span class="n">AxisAlignedBoundingBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

<div class="viewcode-block" id="FeatureCatalog.rotate">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.rotate.html#giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.rotate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the feature catalog.</span>

<span class="sd">        The rotation is applied to the :attr:`feature_bounds`, :attr:`feature_normals`, and :attr:`feature_locations`.</span>
<span class="sd">        It is not applied to the DEM data for each feature, instead, when rays are traced into the scene they are</span>
<span class="sd">        rotated into the base frame for the feature catalog before tracing.  This is generally more efficient because</span>
<span class="sd">        there are normally much fewer rays to trace than DEM points to rotate.</span>

<span class="sd">        :param rotation: The rotation to apply</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_normals</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_normals</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_locations</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_locations</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">*</span> <span class="n">rotation</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span></div>


<div class="viewcode-block" id="FeatureCatalog.translate">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.translate.html#giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.translate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translates the feature catalog.</span>

<span class="sd">        The translation is applied to the :attr:`feature_bounds` and :attr:`feature_locations`.  It is not applied to</span>
<span class="sd">        the DEM data for each feature, instead, when rays are traced into the scene they are translated into the base</span>
<span class="sd">        frame for the feature catalog before tracing.  This is generally more efficient because there are normally</span>
<span class="sd">        much fewer rays to trace than DEM points to rotate.</span>

<span class="sd">        :param translation: The translation to apply</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span> <span class="o">+=</span> <span class="n">translation</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_locations</span> <span class="o">+=</span> <span class="n">translation</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="n">translation</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">-=</span> <span class="n">translation</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="o">-</span><span class="n">translation</span></div>


<div class="viewcode-block" id="FeatureCatalog.get_first">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.get_first.html#giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.get_first">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_first</span><span class="p">(</span><span class="n">total_results</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">traced_rays</span><span class="p">:</span> <span class="n">Rays</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This static method identifies the first intersection for each ray when there is more than 1 feature intersected.</span>

<span class="sd">        Each feature in the scene is responsible for identifying the first intersection with itself for each ray.</span>
<span class="sd">        This method is then responsible for identifying which feature was struck first.</span>

<span class="sd">        This method works by considering the intersection for each ray with each feature, and then finding the</span>
<span class="sd">        the intersection with the minimum distance between the ray and the camera.  The result is a 1D array with</span>
<span class="sd">        dtype of :attr:`.INTERSECT_DTYPE`.</span>

<span class="sd">        A user will almost never use this method directly, as it is automatically called by the :meth:`trace` method.</span>

<span class="sd">        :param total_results: The first intersection for each ray with each feature in the catalog</span>
<span class="sd">        :param traced_rays: The rays that these results pertain to</span>
<span class="sd">        :return: The shrunk array specifying the first intersection for each array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">total_results</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">total_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nan_check</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">total_results</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nan_check</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">total_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">min_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">total_results</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">min_ind</span><span class="p">[</span><span class="n">nan_check</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">traced_rays</span><span class="p">[</span><span class="n">nan_check</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span>
                                                         <span class="n">total_results</span><span class="p">[</span><span class="s2">&quot;intersect&quot;</span><span class="p">][:,</span> <span class="n">nan_check</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total_results</span><span class="p">[</span><span class="n">min_ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_ind</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span></div>


<div class="viewcode-block" id="FeatureCatalog.trace">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.trace.html#giant.relative_opnav.estimators.sfn.surface_features.FeatureCatalog.trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">:</span> <span class="n">Rays</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method traces rays through the feature catalog, optionally filtering which features are included traced</span>
<span class="sd">        through the :attr:`include_features` attribute.</span>

<span class="sd">        The rays are first rotated/translated into the base frame of the feature catalog and are then traced through</span>
<span class="sd">        each active feature to look for intersections.  Only the first (shortest distance) intersection for each ray is</span>
<span class="sd">        returned.  The results are returned as a numpy array with type :attr:`.INTERSECT_DTYPE`.</span>

<span class="sd">        If the :attr:`include_features` attribute is set to ``None``, then this method will attempt to smartly only load</span>
<span class="sd">        features where the Rays intersect the bounding box of the feature, before &quot;lazy loading&quot; the feature.  This is</span>
<span class="sd">        typically only used in the case when you are tracing the full feature catalog to render a high resolution</span>
<span class="sd">        image.</span>

<span class="sd">        :param rays: The rays to trace through the feature catalog</span>
<span class="sd">        :return: A numpy array specifying where each ray intersected with type :attr:`.INTERSECT_DTYPE`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if we haven&#39;t specified which features to include then we include all of them but intersect</span>
        <span class="c1"># the bounding box for the feature first before trying to load it to save memory.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">include_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)))</span>
            <span class="n">check_bbox</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_bbox</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># rotate/translate the rays into the local frame defined for the feature catalog</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">rays_local</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rays_local</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rays_local</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">rays_local</span> <span class="o">=</span> <span class="n">rays</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through each included feature</span>
        <span class="k">for</span> <span class="n">feature_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_features</span><span class="p">:</span>
            <span class="n">feature</span><span class="p">:</span> <span class="n">SurfaceFeature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">feature_index</span><span class="p">]</span> 

            <span class="c1"># at this point we are rendering the whole feature catalog, but we don&#39;t want to have to load everything</span>
            <span class="c1"># into memory if we don&#39;t need it so we trace the bounding box first to ensure that the feature is</span>
            <span class="c1"># intersected before loading it</span>
            <span class="k">if</span> <span class="n">check_bbox</span><span class="p">:</span>
                <span class="c1"># in case we have an old feature catalog that doesn&#39;t had the bbox attribute yet</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_feature_bounding_boxes&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feature_bounding_boxes</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># check to see if we already have this bounding box</span>
                <span class="n">bbox</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AxisAlignedBoundingBox</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_bounding_boxes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feature_index</span><span class="p">)</span> 
                <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># figure out what the original bounds are in the body fixed frame without loading the shape</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_bounds</span><span class="p">[</span><span class="n">feature_index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@bounds</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">bounds</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># make the AABB</span>
                    <span class="n">bbox</span> <span class="o">=</span> <span class="n">AxisAlignedBoundingBox</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                  <span class="n">bounds</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># store it for future use</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feature_bounding_boxes</span><span class="p">[</span><span class="n">feature_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span>

                <span class="c1"># check if the bounding box is hit by any of the rays</span>
                <span class="n">bbox_results</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">bbox</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rays_local</span><span class="p">))</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox_results</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="c1"># if not notify the feature it wasn&#39;t found and move to the next feature</span>
                    <span class="n">feature</span><span class="o">.</span><span class="n">not_found</span><span class="p">()</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if it was notify the feature it was found</span>
                    <span class="n">feature</span><span class="o">.</span><span class="n">found</span><span class="p">()</span>

            <span class="c1"># get a copy of the ignore indices to modify which ones count for the current feature</span>
            <span class="n">original_ignore_inds</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">rays_local</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span>
            <span class="n">ignore_inds</span> <span class="o">=</span> <span class="n">rays_local</span><span class="o">.</span><span class="n">ignore</span>

            <span class="c1"># modify the ignore inds for ones that apply to this feature</span>
            <span class="k">if</span> <span class="n">ignore_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore_inds</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                    <span class="n">ignore_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ignore_inds</span><span class="p">]</span><span class="o">*</span><span class="n">rays_local</span><span class="o">.</span><span class="n">num_rays</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ignore_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ignore_inds</span><span class="p">)</span>

                <span class="n">ignore_inds</span><span class="p">[</span><span class="n">ignore_inds</span> <span class="o">//</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="n">feature_index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">ignore_inds</span><span class="p">[</span><span class="n">ignore_inds</span> <span class="o">//</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">feature_index</span><span class="p">]</span> <span class="o">%=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># trace the feature</span>
            <span class="n">feature_results</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rays_local</span><span class="p">)</span>

            <span class="c1"># reset the original ignore inds</span>
            <span class="n">rays_local</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">original_ignore_inds</span>

            <span class="c1"># update the id for the intersect face based on the current feature index</span>
            <span class="n">feature_results</span><span class="p">[</span><span class="s2">&quot;facet&quot;</span><span class="p">][</span><span class="n">feature_results</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">feature_index</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># store the results</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_results</span><span class="p">)</span>

        <span class="c1"># now figure out with intersection was first for any ray with multiple intersects</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">INTERSECT_DTYPE</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_first</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">rays_local</span><span class="p">)</span>

        <span class="c1"># now rotate/translate the result back into the frame the rays started in</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;intersect&quot;</span><span class="p">][</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">intersects</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]][</span><span class="s2">&quot;intersect&quot;</span><span class="p">]</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]][</span><span class="s2">&quot;normal&quot;</span><span class="p">]</span>

            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;intersect&quot;</span><span class="p">][</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span>
                                              <span class="n">intersects</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">intersects</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;normal&quot;</span><span class="p">][</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span>
                                           <span class="n">normals</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">normals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># reset the include feature list</span>
        <span class="k">if</span> <span class="n">check_bbox</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">include_features</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">res</span></div>
</div>



<div class="viewcode-block" id="SurfaceFeature">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SurfaceFeature</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents a surface feature in GIANT.</span>

<span class="sd">    In GIANT, a surface feature is defined a small DEM of a patch of surface combined with a name, the average ground</span>
<span class="sd">    sample distance of the DEM in kilometers, and a best fit plane through the topography of the DEM.  The DEM itself is</span>
<span class="sd">    represented by a traceable object from the :mod:`.ray_tracer` module (typically either a :class:`.KDTree` or a</span>
<span class="sd">    :class:`.Surface` subclass) and is stored in the :attr:`shape` attribute. The best fit plane is represent by a</span>
<span class="sd">    normal vector, expressed in the body-fixed frame, and the location of the center of the plane, expressed in the</span>
<span class="sd">    body-fixed frame, which are stored in the :attr:`normal` and :attr:`body_fixed_center` attributes respectively.</span>
<span class="sd">    Finally, the name and the ground sample distance are stored in the :attr:`name` and :attr:`ground_sample_distance`</span>
<span class="sd">    attributes respectively.  These are all typically set at initialization of an instance of a surface feature.  We</span>
<span class="sd">    note here that typically all of these attributes stay in the original frame in which they are defined unless you are</span>
<span class="sd">    manually messing with things.  This is important for exporting your results to orbit determination software, which</span>
<span class="sd">    typically needs to know feature locations in a body fixed frame.</span>

<span class="sd">    Surface features are normally created through an external program, like SPC, or by tiling a very high resolution</span>
<span class="sd">    global shape model.  Both the process of ingesting a set of SPC features (called Maplets) and tiling a high</span>
<span class="sd">    resolution global shape model, are available in the :mod:`.spc_to_feature_catalog` and :mod:`.tile_shape` scripts</span>
<span class="sd">    respectively, therefore, it is rare that you will manually create surface features using this class.</span>

<span class="sd">    As discussed above, when doing surface feature navigation, the feature catalog is normally very large, as we</span>
<span class="sd">    typically globally tile a surface at very small ground sample distances with significant overlap between each tile.</span>
<span class="sd">    This means that it is usually infeasible to hold an entire feature catalog in memory at once.  To alleviate this</span>
<span class="sd">    issue, this class provides a lazy loading/unloading mechanism that only keeps the actual shape information (which</span>
<span class="sd">    is by far the biggest memory hog) in memory when it is needed.  With this mechanism, the DEM shape data is only</span>
<span class="sd">    loaded once something trying to access the :attr:`.shape` attribute of an instance of this class.  When this</span>
<span class="sd">    happens, the class will check if the DEM information has already been loaded into memory, and if not, it will load</span>
<span class="sd">    it automatically.  Then, after a specified number of images (controlled by the :attr:`stale_count_unload_threshold`</span>
<span class="sd">    attribute) have been processed which do not need the DEM information, it will automatically unload the information</span>
<span class="sd">    from memory. Additionally, features can be unloaded from memory every time their not found if the memory footprint</span>
<span class="sd">    of the current process as a percent of the total system memory exceeds the threshold specified in the</span>
<span class="sd">    :attr:`memory_percent_unload_threshold`.  This also can be controlled for all features in a</span>
<span class="sd">    :class:`.FeatureCatalog` through the :attr:`.FeatureCatalog.memory_percent_unload_threshold` property.</span>
<span class="sd">    This loading/unloading is managed by calls to the :meth:`found` and :meth:`not_found` methods of this class.</span>

<span class="sd">    The automatic loading and unloading of data is generally pretty invisible to the user outside of log messages, as it</span>
<span class="sd">    all happens automatically in the :class:`.SurfaceFeatureNavigation` and :class:`.FindVisibleFeatures` classes.  That</span>
<span class="sd">    being said, you may need to consider tuning how quickly things are unloaded from memory, which can easily be set for</span>
<span class="sd">    all features in a catalog through the :attr:`.FeatureCatalog.stale_count_unload_threshold` attribute.  Typically</span>
<span class="sd">    you want to set this sufficiently large enough that you are not frequently loading/unloading the same features over</span>
<span class="sd">    and over again, but small enough that you don&#39;t overwhelm the memory capabilities of your filter.  On modern solid</span>
<span class="sd">    state hard drives, the read speeds are generally fast enough that you can set this number fairly low, even if you</span>
<span class="sd">    end up loading/unloading more than absolutely necessary.  On older hard drives with slower read speeds you will</span>
<span class="sd">    generally what to try to make this as large as possible without consistently forcing your system to use swap.  It</span>
<span class="sd">    can take some experimentation to find the sweet spot, but we do want to stress that ultimately you are not affect</span>
<span class="sd">    the results you are generating here, just the speed at which those results can be generated.</span>

<span class="sd">    To use this automatic loading/unloading, when initializing the class, instead of the providing the traceable DEM</span>
<span class="sd">    data to the shape argument, instead provide a string or Path object that points to a pickle file containing the DEM</span>
<span class="sd">    data as the first object in the file.</span>

<span class="sd">    Generally you will not interact with surface features directly all that frequently, and instead will interact with a</span>
<span class="sd">    catalog of surface features through the :class:`.FeatureCatalog` class.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        When using the lazy load/unload feature of this class pickle files are read.  While in general these pickle</span>
<span class="sd">        files have been created by GIANT and are completely safe, if the pickle files are somehow compromised or you</span>
<span class="sd">        received them from an untrusted source they could be used to execute arbitrary code on your system, therefore</span>
<span class="sd">        you should carefully verify that your pickle files have not been tampered with before using them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PATH</span><span class="p">,</span> <span class="n">KDTree</span><span class="p">,</span> <span class="n">Shape</span><span class="p">],</span> <span class="n">normal</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">body_fixed_center</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ground_sample_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stale_count_unload_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">memory_percent_unload_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">90</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param shape: The shape object that represents the DEM topography for the feature as a :class:`.KDTree` or</span>
<span class="sd">                      :class:`.Shape`, or the path to the file containing the shape object as a ``str`` or ``Path``.</span>
<span class="sd">        :param normal: The normal vector for the best fit plane to the DEM topography in the body-fixed frame</span>
<span class="sd">        :param body_fixed_center: The center of the best fit plane to the DEM topography in the body-fixed frame</span>
<span class="sd">        :param name: The name of the feature</span>
<span class="sd">        :param ground_sample_distance: The average ground sample distance of the DEM topography in kilometers.</span>
<span class="sd">        :param stale_count_unload_threshold: The number of times a feature must be marked as :meth:`not_found` for it</span>
<span class="sd">                                             to be unloaded from memory.</span>
<span class="sd">        :param memory_percent_unload_threshold: The size of the memory footprint of the current process as the percent</span>
<span class="sd">                                                of the total system memory before features are unloaded from memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">KDTree</span><span class="p">,</span> <span class="n">Shape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This private attribute is used to store the actual shape data or ``None`` if the shape data has not been loaded.</span>
<span class="sd">        </span>
<span class="sd">        To always access the shape data, use the :attr:`shape` property instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PATH</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This private attribute is use to store the path to the file containing the DEM data as a pickle file.</span>
<span class="sd">        </span>
<span class="sd">        This should generally be an absolute path.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">KDTree</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The normal vector of the best fit plane through the DEM expressed in the body-fixed frame as a length 3 numpy </span>
<span class="sd">        array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">body_fixed_center</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">body_fixed_center</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The vector from the center of the body to the middle of the best fit plane of the DEM expressed in the </span>
<span class="sd">        body-fixed frame as a length 3 numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the feature as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ground_sample_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">ground_sample_distance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The average ground sample distance of the feature DEM in units of kilometers or ``None``.</span>
<span class="sd">        </span>
<span class="sd">        If ``None`` then scaling filtering will not be performed for this feature in the :class:`VisibleFeatureFinder`</span>
<span class="sd">        class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of times :meth:`not_found` has been called since the last time :meth:`found` was called.</span>
<span class="sd">        </span>
<span class="sd">        This is used to determine when the feature should be unloaded from memory.  Generally you should treat this as</span>
<span class="sd">        read only.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stale_count_unload_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">stale_count_unload_threshold</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of times :meth:`not_found` must be called since the last :meth:`found` was called for the feature to</span>
<span class="sd">        be unloaded from memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">memory_percent_unload_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">memory_percent_unload_threshold</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The memory percentage used by the current process at which point we begin unloading features that are not found </span>
<span class="sd">        regardless of how long its been since a feature was used.</span>
<span class="sd">        </span>
<span class="sd">        If you trust your system to handle swap appropriately you can set this to some value greater than 100 which will</span>
<span class="sd">        effectively disable this check.</span>
<span class="sd">        </span>
<span class="sd">        If you plan to run multiple instances of GIANT/SFN at the same time then you should probably set this value </span>
<span class="sd">        lower so that you limit the resources they are fighting over.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Shape</span><span class="p">,</span> <span class="n">KDTree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property gives the traceable object that represents the DEM.</span>

<span class="sd">        This will always return a traceable object (either a :class:`.KDTree` or a :class:`.Shape`, but if the DEM data</span>
<span class="sd">        hasn&#39;t been loaded from disk yet there may be a slight delay while it is retrieved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
            
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AxisAlignedBoundingBox</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property returns the bounding box for the feature by retrieving the bounding box from the traceable shape</span>
<span class="sd">        object.</span>

<span class="sd">        If for some reason the traceable shape object does not have a ``bounding_box`` attribute, ``None`` is returned.</span>

<span class="sd">        Note that this property will access the Shape property, so if the DEM shape data has not yet been loaded from</span>
<span class="sd">        disk it will be loaded and there may be a slight delay.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property simply returns whether the shape data is actively loaded into memory or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

<div class="viewcode-block" id="SurfaceFeature.load">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.load.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.load">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loads the shape information from disk.</span>

<span class="sd">        Typically a user will not use this method directly as it is automatically called by the :attr:`shape` and</span>
<span class="sd">        :attr:`bounding_box` properties when required.</span>

<span class="sd">        :raises ValueError: If the shape file information is not available</span>
<span class="sd">        :raises IOError: If the shape file is not available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape file not available&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> successfully Loaded...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SurfaceFeature.update_path">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.update_path.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.update_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_path</span><span class="p">:</span> <span class="n">PATH</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This updates the absolute directory structure to the file containing the DEM data for this shape.</span>

<span class="sd">        This only changes the directory structure, not the file itself, therefore it extracts the actual file name from</span>
<span class="sd">        the current path and appends it to the new path (that is, new_path should simply be a directory structure, not</span>
<span class="sd">        a full file path).  If you want to change the full file you can use :meth:`update_file`.</span>

<span class="sd">        If this feature is not a lazy load feature then this method will do nothing.</span>
<span class="sd">        :param new_path: The new directory structure to navigate to find the file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="SurfaceFeature.update_file">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.update_file.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.update_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_file</span><span class="p">:</span> <span class="n">PATH</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This updates the pointer to the file containing the DEM data for this feature.</span>

<span class="sd">        If you are just updating the directory structure and not the file itself see the :meth:`update_path` method.</span>

<span class="sd">        :param new_file: The file containing the DEM data for this feature.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span> <span class="o">=</span> <span class="n">new_file</span></div>


<div class="viewcode-block" id="SurfaceFeature.found">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.found.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.found">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">found</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the feature is found in an image and will be processed.</span>

<span class="sd">        It resets the :attr:`n_not_found` counter to 0.</span>

<span class="sd">        Typically a user will not use this method directly as it is automatically called by the</span>
<span class="sd">        :class:`.VisualFeatureFinder` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="SurfaceFeature.not_found">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.not_found.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.not_found">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">not_found</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the feature is not found in an image.</span>

<span class="sd">        It increments the :attr:`n_not_found` counter by 1.  If the :attr:`n_not_found` counter is then greater than the</span>
<span class="sd">        :attr:`stale_count_unload_threshold`, the shape data will be unloaded from memory.  Additionally, if the memory</span>
<span class="sd">        footprint of the current process is using more than :attr:`memory_percent_unload_threshold` then, regardless of</span>
<span class="sd">        how long its been since this feature was last used, the shape data will be unloaded from memory.</span>

<span class="sd">        Typically a user will not use this method directly as it is automatically called by the</span>
<span class="sd">        :class:`.VisualFeatureFinder` class.</span>

<span class="sd">        If the instance of this class was provided the shape object directly, instead of the file containing the shape</span>
<span class="sd">        data then this method will not try to unload, though it will still increase the counter for posterity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="c1"># this is just for old models before we implemented the counter</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;n_not_found&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># make sure this is a lazy load/unload feature</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stale_count_unload_threshold</span><span class="p">:</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unloading feature </span><span class="si">{}</span><span class="s2"> because it hasn&#39;t been used recently.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">elif</span> <span class="n">_PROCESS</span><span class="o">.</span><span class="n">memory_percent</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_percent_unload_threshold</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unloading feature </span><span class="si">{}</span><span class="s2"> because memory usage is at </span><span class="si">{}</span><span class="s2">%.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                                                        <span class="n">_PROCESS</span><span class="o">.</span><span class="n">memory_percent</span><span class="p">()))</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_not_found</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="SurfaceFeature.trace">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.trace.html#giant.relative_opnav.estimators.sfn.surface_features.SurfaceFeature.trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">:</span> <span class="n">Rays</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method traces the provided rays through the feature DEM.</span>

<span class="sd">        The trace it handled by the :meth:`~.Shape.trace` method of the DEM object directly.  Because we retrieve this</span>
<span class="sd">        method through the :attr:`shape` attribute, if the shape is not already in memory, it will be loaded.</span>
<span class="sd">        :param rays: the rays to trace against the DEM shape object.</span>
<span class="sd">        :return: A numpy array of type :attr:`INTERSECT_DTYPE` specifying the results of the ray trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="VisibleFeatureFinderOptions">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.VisibleFeatureFinderOptions.html#giant.relative_opnav.estimators.sfn.surface_features.VisibleFeatureFinderOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VisibleFeatureFinderOptions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This dataclass serves as one way to control the settings for the :class:`.VisibleFeatureFinder` at initialization.</span>

<span class="sd">    You can set any of the options on an instance of this dataclass and pass it to the :class:`.VisibleFeatureFinder` at</span>
<span class="sd">    initialization (or through the method :meth:`.VisibleFeatureFinder.apply_options`) to set the settings</span>
<span class="sd">    on the class.  This class is the preferred way of setting options on the class due to ease of use in IDEs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The index into the target list tor the scene object that contains the feature catalog, or ``None`` to </span>
<span class="sd">    automatically deduce the index</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">feature_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of feature names to test against (useful for filtering if you only want to use a subset of features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">off_boresight_angle_maximum</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum angle between the boresight and the line of sight to a feature in degrees.  This is useful to avoid </span>
<span class="sd">    overflows in the other checks by throwing things out that are way outside the field of view.  The default (if </span>
<span class="sd">    left as ``None``) is ``1.5*camera_model.field_of_view``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gsd_scaling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The ratio allowed between the ground sample distance of the camera and the ground sample distance of the feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reflectance_angle_maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">70</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum reflectance angle (angle between the line of sight vector and the feature normal vector) in degrees.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">incident_angle_maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">70</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum incident angle (angle between the incoming light vector and the feature normal vector) in degrees.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">percent_in_fov</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The percentage of the feature that is in the field of view based on a bounding box test. This should be between 0 </span>
<span class="sd">    and 100</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="VisibleFeatureFinder">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.VisibleFeatureFinder.html#giant.relative_opnav.estimators.sfn.surface_features.VisibleFeatureFinder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VisibleFeatureFinder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class creates a callable which is used to filter features that are visible in an image.</span>

<span class="sd">    The features are filtered in a number of ways.  First, they can be directly filtered by name using the</span>
<span class="sd">    :attr:`feature_list` attribute. Next, the features are filter based on the angle between the line of sight vector to</span>
<span class="sd">    the feature and the camera boresight vector, using the :attr:`off_boresight_angle_maximum` attribute.  Then,</span>
<span class="sd">    the features are filtered based on the reflection angle (angle between the line of sight vector and feature normal</span>
<span class="sd">    vector, using the :attr:`reflectance_angle_maximum` attribute.  Then, the features are filtered based on the</span>
<span class="sd">    incidence angle (angle between the sun direction vector and the feature normal vector) using the</span>
<span class="sd">    :attr:`incident_angle_maximum` attribute.  The the features are filtered based on the ratio of the camera GSD at the</span>
<span class="sd">    feature location and the GSD of the feature, using the :attr:`gsd_scaling` attribute.  Finally the features are</span>
<span class="sd">    filtered based on the percentage of the feature that is in the FOV of the camera, using the :attr:`percent_in_fov`</span>
<span class="sd">    attribute.  For each of these filtering passes, the only the features that met the preceding filters are considered</span>
<span class="sd">    for efficiency.</span>

<span class="sd">    After initializing this class with the appropriate data, you can generate a list of the visible feature indices</span>
<span class="sd">    (index into the :attr:`.FeatureCatalog.features` list and related) by calling the result and providing the</span>
<span class="sd">    temperature of the camera.  This assumes that the scene/feature catalog/light source have been appropriately</span>
<span class="sd">    placed in the camera frame already, so typically you should ensure that you provide a reference (not a copy) of the</span>
<span class="sd">    feature catalog and the scene.</span>

<span class="sd">    Typically a user will not interact directly with this class and instead it will be managed by the</span>
<span class="sd">    :class:`.SurfaceFeatureNavigation` class.  If you do want to use it manually, provide the appropriate inputs</span>
<span class="sd">    to the class constructor, update the scene to place everything in the camera frame at the time you want to identify</span>
<span class="sd">    visible features, and then call the instance of this class providing the camera temperature at the time you want to</span>
<span class="sd">    identify the visible features.  The resulting list of indices can be used to index into the</span>
<span class="sd">    :attr:`.FeatureCatalog.features` list and related.</span>

<span class="sd">    To specify the settings for this class, you can either use keyword arguments or the</span>
<span class="sd">    :class:`.VisibleFeatureFinderOptions` dataclass, which is the preferred method.  It is not recommended to mix</span>
<span class="sd">    methods as this can lead to unexpected results</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_catalog</span><span class="p">:</span> <span class="n">FeatureCatalog</span><span class="p">,</span>
                 <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VisibleFeatureFinderOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">feature_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">off_boresight_angle_maximum</span><span class="p">:</span> <span class="n">NONENUM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">gsd_scaling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">reflectance_angle_maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="n">incident_angle_maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="n">percent_in_fov</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param feature_catalog: The feature catalog that specifies the features we care considering</span>
<span class="sd">        :param options: A dataclass specifying the options to set for this instance.  If provided it takes preference</span>
<span class="sd">                        over all key word arguments, therefore it is not recommended to mix methods.</span>
<span class="sd">        :param feature_list: A list of feature names to test against (useful for filtering if you only want to use a</span>
<span class="sd">                             subset of features</span>
<span class="sd">        :param off_boresight_angle_maximum: The maximum angle between the boresight and the line of sight to a feature</span>
<span class="sd">                                            in degrees.  This is useful to avoid</span>
<span class="sd">                                            overflows in the other checks by throwing things out that are way outside</span>
<span class="sd">                                            the field of view.  The default (if left as ``None``) is</span>
<span class="sd">                                            ``1.5*camera_model.field_of_view``</span>
<span class="sd">        :param gsd_scaling: The ratio allowed between the ground sample distance of the camera and the ground sample</span>
<span class="sd">                            distance of the feature.</span>
<span class="sd">        :param reflectance_angle_maximum: The maximum reflectance angle (angle between the line of sight vector and the</span>
<span class="sd">                                          feature normal vector) in degrees.</span>
<span class="sd">        :param incident_angle_maximum: The maximum incident angle (angle between the incoming light vector and the</span>
<span class="sd">                                       feature normal vector) in degrees.</span>
<span class="sd">        :param percent_in_fov: The percentage of the feature that is in the field of view based on a bounding box test.</span>
<span class="sd">                               This should be between 0 and 100</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="p">:</span> <span class="n">FeatureCatalog</span> <span class="o">=</span> <span class="n">feature_catalog</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The catalog of features we are looking through.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">feature_list</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is used to filter features by name.</span>

<span class="sd">        You can use this list to process only a subset of features (which are still filtered through the other processes</span>
<span class="sd">        of this class) which may be useful if you have a large model with many features.  If this is a list of strings, </span>
<span class="sd">        the only features who&#39;s :attr:`.SurfaceFeature.name` attribute are contained in this list are considered (note</span>
<span class="sd">        that the name must match exactly for this to work).</span>

<span class="sd">        If this is left as ``None`` then all features in the feature catalog are considered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the maximum fov extent based on the camera field of view</span>
        <span class="k">if</span> <span class="n">off_boresight_angle_maximum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">off_boresight_angle_maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">off_boresight_angle_maximum</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">off_boresight_angle_maximum</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum angle between the feature location and the camera boresight in degrees.</span>

<span class="sd">        This check is used to avoid features that are far outside of the camera FOV to avoid overflows in the projection</span>
<span class="sd">        of the feature bounding box vectors onto the image that can occasionally incorrectly label the feature as being</span>
<span class="sd">        within the field of view.</span>

<span class="sd">        The off boresight angle is computed as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \theta = \cos^{-1}\left(\frac{\left[\begin{array}{ccc}{0 &amp; 0 &amp; 1}\end{array}\right]\mathbf{x}_{iC}}</span>
<span class="sd">            {\|\mathbf{x}_{iC}\|}\right)</span>

<span class="sd">        where :math:`theta` is the view angle in degrees, :math:`\cos^{-1}` is the arc cosine in degrees, </span>
<span class="sd">        :math:`\mathbf{x}_{iC}` is the vector from the camera center to the :math:`i^{th}` feature in the camera frame </span>
<span class="sd">        from :attr:`.FeatureCatalog.feature_locations`, and :math:`\|\bullet\|` is the 2 norm of the vector.  </span>
<span class="sd">        Features are marked as possibly visible if :math:`\theta` is less than this attribute.</span>

<span class="sd">        Typically this angle should be set to a multiple of the half diagonal field of view of the camera, which is what</span>
<span class="sd">        the default for this parameter is (if left as ``None``).  The maximum value for this should be 180 degrees </span>
<span class="sd">        (which is unlikely to ever be reached).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gsd_scaling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">gsd_scaling</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ratio between the camera ground sample distance and the ground sample distance of the feature itself that </span>
<span class="sd">        is allowed for a feature to be considered visible.</span>

<span class="sd">        This should be a value greater than or equal to 1.</span>

<span class="sd">        For a feature to be considered visible it must meet the requirement of</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{1}{s} &lt;= \frac{g_c}{g_f} &lt;= s</span>

<span class="sd">        where :math:`s` is the ``gsd_scaling``, :math:`g_c` is the ground sample distance of the camera computed using </span>
<span class="sd">        :meth:`.CameraModel.compute_ground_sample_distance`, and :math:`g_f` is the ground sample distance of the </span>
<span class="sd">        feature stored as :attr:`.SurfaceFeature.ground_sample_distance`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reflectance_angle_maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reflectance_angle_maximum</span><span class="p">)</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum reflectance angle in degrees for a feature to be considered visible.</span>

<span class="sd">        The reflectance angle is defined as the angle between the normal vector for the feature and the unit vector </span>
<span class="sd">        from the feature to the camera center.  It is computed as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \gamma_r = \cos^{-1}\left(\hat{\mathbf{x}}_r^T\hat{\mathbf{n}}_i\right)</span>

<span class="sd">        where :math:`\gamma_r` is the reflectance angle in degrees, :math:`\cos^{-1}` is the arc cosine in degrees,</span>
<span class="sd">        :math:`\hat{\mathbf{x}}_{ri}^T` is the unit vector from the :math:`i^{th}` feature to the camera center </span>
<span class="sd">        expressed in the camera frame (computed using :attr:`.FeatureCatalog`.feature_locations`), and </span>
<span class="sd">        :math:`\hat{\mathbf{n}}_i` is the unit normal vector for the :math:`i^{th}` feature in the camera frame.</span>

<span class="sd">        Features are marked as possibly visible if :math:`\gamma_r` is less than this attribute.</span>

<span class="sd">        Typically, since most features are well approximated by a flat plate, this angle should not exceed 90 degrees as </span>
<span class="sd">        an absolute maximum, which would imply you are viewing the feature completely from the side.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle_maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">incident_angle_maximum</span><span class="p">)</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum incident angle in degrees for a feature to be considered visible.</span>

<span class="sd">        The incident angle is defined as the angle between the normal vector for the feature and the unit vector </span>
<span class="sd">        from the feature to the sun.  It is computed as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \gamma_i = \cos^{-1}\left(\hat{\mathbf{x}}_{ij}^T\hat{\mathbf{n}}_j\right)</span>

<span class="sd">        where :math:`\gamma_i` is the incident angle in degrees, :math:`\cos^{-1}` is the arc cosine in degrees,</span>
<span class="sd">        :math:`\hat{\mathbf{x}}_{ij}^T` is the unit vector from the :math:`j^{th}` feature to the sun </span>
<span class="sd">        expressed in the camera frame (computed using :attr:`.SceneObject.position` of :attr:`.Scene.light_obj`), and </span>
<span class="sd">        :math:`\hat{\mathbf{n}}_j` is the unit normal vector for the :math:`j^{th}` feature in the camera frame.</span>

<span class="sd">        Features are marked as possibly visible if :math:`\gamma_i` is less than this attribute.</span>

<span class="sd">        Typically, since most features are well approximated by a flat plate, this angle should not exceed 90 degrees </span>
<span class="sd">        as an absolute maximum, which would imply the feature is illuminated completely from the side.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">percent_in_fov</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">percent_in_fov</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The percentage of the predicted feature feature_bounds in the image plane that falls within the FOV of the </span>
<span class="sd">        camera.</span>
<span class="sd">        </span>
<span class="sd">        This should be a number &lt;= 100.  </span>
<span class="sd">        </span>
<span class="sd">        The actual percentage of the feature contained in the FOV is computed by </span>
<span class="sd">        </span>
<span class="sd">        #. projecting the bounding box vertices of the feature onto the image using </span>
<span class="sd">           :meth:`.CameraModel.project_onto_image` and the :attr:`.FeatureCatalog.feature_bounds` attribute.</span>
<span class="sd">        #. determining the axis aligned bounding box in the image by finding the min and max pixels of the projected </span>
<span class="sd">           points</span>
<span class="sd">        #. determining the overlap between the AABB of the feature in the image and the AABB of the image </span>
<span class="sd">           ``(0-&gt;n_cols, 0-&gt;n_rows)``</span>
<span class="sd">        #. computing the percent as the overlap area divided by the area of the AABB of the feature in the image.</span>
<span class="sd">        </span>
<span class="sd">        If this computed percentage is greater than or equal to this attribute, then the feature is possibly visible </span>
<span class="sd">        (depending on further checks).  If it is less than this attribute then the feature is not considered visible and</span>
<span class="sd">        no more checks are performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># apply the options from the options structure</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_gsds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">f</span><span class="o">.</span><span class="n">ground_sample_distance</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">))</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This private attribute stores the GSD for each feature as a numpy array to make logical indexing easier.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">])</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This private attribute stores the name for each feature as a numpy array to make logical indexing easier.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VisibleFeatureFinder.apply_options">
<a class="viewcode-back" href="../../../../../relative_opnav/estimators/sfn/surface_features/giant.relative_opnav.estimators.sfn.surface_features.VisibleFeatureFinder.apply_options.html#giant.relative_opnav.estimators.sfn.surface_features.VisibleFeatureFinder.apply_options">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">VisibleFeatureFinderOptions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method applies the input options to the current instance.</span>

<span class="sd">        The input options should be an instance of :class:`.VisibleFeatureFinderOptions`.</span>

<span class="sd">        When calling this method every setting will be updated, even ones you did not specifically set in the provided</span>
<span class="sd">        ``options`` input.  Any you did not specifically modify will be reset to the default value.  Typically the best</span>
<span class="sd">        way to change a single setting is through direct attribute access on this class, or by maintaining a copy of the</span>
<span class="sd">        original options structure used to initialize this class and then updating it before calling this method.</span>

<span class="sd">        :param options: The options to apply to the current instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_list</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">feature_list</span>

        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># compute the maximum fov extent based on the camera field of view</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gsd_scaling</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">gsd_scaling</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reflectance_angle_maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">reflectance_angle_maximum</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle_maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">incident_angle_maximum</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">percent_in_fov</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">percent_in_fov</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera_model</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The call method of this class determines which features are currently visible based off of the current scene</span>
<span class="sd">        setup and the provided filter inputs stored in the attributes of this class.</span>

<span class="sd">        The visible features are returned as a list of integers that index into the :attr:`.FeatureCatalog.features`</span>
<span class="sd">        list and related.</span>

<span class="sd">        If a feature is identified as not visible for the current settings, its :attr:`.SurfaceFeature.not_found` method</span>
<span class="sd">        is called so we can evaluate if the DEM data should be unloaded.  If a feature is identified as found, its</span>
<span class="sd">        :attr:`.SurfaceFeature.found` method is called so the DEM data can be loaded if need be.</span>

<span class="sd">        :param temperature: The temperature of the camera at the current time.  Used for projection of points</span>
<span class="sd">        :return: A list of integers that specify which features are visible according to the current state of the</span>
<span class="sd">                 :attr:`scene`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># figure out which target to consider</span>
        <span class="n">target_use</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="p">:</span>
                <span class="n">target_use</span> <span class="o">=</span> <span class="n">target</span>

        <span class="k">if</span> <span class="n">target_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to determine which target holds the feature catalog.  Please provide a scene&#39;</span>
                             <span class="s1">&#39;which contains the feature catalog in it.&#39;</span><span class="p">)</span>

        <span class="c1"># set the off boresight angle maximum if it hasn&#39;t been set yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">camera_model</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">)</span>  <span class="c1"># restrict to &lt;= 180</span>

        <span class="c1"># assume that the boresight of the camera goes through the center of the pixel array</span>
        <span class="n">boresight_pixel</span> <span class="o">=</span> <span class="p">[(</span><span class="n">camera_model</span><span class="o">.</span><span class="n">n_cols</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">camera_model</span><span class="o">.</span><span class="n">n_rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">boresight_vector</span> <span class="o">=</span> <span class="n">camera_model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="n">boresight_pixel</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>


        <span class="c1"># get the unit vectors from the camera to the features</span>
        <span class="n">reflectance_vectors</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_locations</span> <span class="o">/</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_locations</span><span class="p">,</span>
                                              <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># first check the feature list</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">visible_feature_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visible_feature_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_names</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">visible_feature_bool</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">not_found</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># second check the boresight vector offset</span>
        <span class="n">visible_feature_bool</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">reflectance_vectors</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">@</span> <span class="n">boresight_vector</span><span class="p">)</span> <span class="o">&gt;=</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">off_boresight_angle_maximum</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visible_feature_bool</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">not_found</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># now check the reflectance angle</span>
        <span class="n">visible_feature_bool</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="o">-</span><span class="n">reflectance_vectors</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_normals</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reflectance_angle_maximum</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visible_feature_bool</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">not_found</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># now check the incidence angle</span>
        <span class="k">assert</span> <span class="n">scene</span><span class="o">.</span><span class="n">light_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">sun_direction</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">light_obj</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="n">target_use</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">sun_direction</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sun_direction</span><span class="p">)</span>
        <span class="n">visible_feature_bool</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_normals</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">@</span> <span class="n">sun_direction</span><span class="p">)</span> <span class="o">&gt;=</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incident_angle_maximum</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># now check the ground sample distance</span>
        <span class="n">gsd_ratio</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">camera_model</span><span class="o">.</span><span class="n">compute_ground_sample_distance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_locations</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">target_normal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_normals</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span>
        <span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_gsds</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span>

        <span class="c1"># need to mark anything as NAN as valid here because it means we don&#39;t have a GSD for that feature</span>
        <span class="n">visible_feature_bool</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">gsd_ratio</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">gsd_ratio</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsd_scaling</span><span class="p">)</span> <span class="o">&amp;</span>
                                                                            <span class="p">(</span><span class="n">gsd_ratio</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">gsd_scaling</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visible_feature_bool</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">not_found</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">feature_image_bounds</span> <span class="o">=</span> <span class="n">camera_model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">feature_bounds</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]),</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">visible_feature_bool</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">feature_image_bounds_min</span> <span class="o">=</span> <span class="n">feature_image_bounds</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">feature_image_bounds_max</span> <span class="o">=</span> <span class="n">feature_image_bounds</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">max_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">camera_model</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="n">camera_model</span><span class="o">.</span><span class="n">n_rows</span><span class="p">]</span>

        <span class="n">interior_check_min</span> <span class="o">=</span> <span class="p">((</span><span class="n">feature_image_bounds_min</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                              <span class="p">(</span><span class="n">feature_image_bounds_min</span> <span class="o">&lt;=</span> <span class="n">max_bounds</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">interior_check_max</span> <span class="o">=</span> <span class="p">((</span><span class="n">feature_image_bounds_max</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                              <span class="p">(</span><span class="n">feature_image_bounds_max</span> <span class="o">&lt;=</span> <span class="n">max_bounds</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># figure out features that are fully visible</span>
        <span class="n">temp_visible_features</span> <span class="o">=</span> <span class="n">interior_check_min</span> <span class="o">&amp;</span> <span class="n">interior_check_max</span>

        <span class="c1"># check features that are partially visible</span>
        <span class="n">partially_v_features</span> <span class="o">=</span> <span class="p">(</span><span class="n">interior_check_min</span> <span class="o">|</span> <span class="n">interior_check_max</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">temp_visible_features</span>

        <span class="c1"># determine the overlap of partially visible features</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">feature_image_bounds_max</span><span class="p">[</span><span class="n">partially_v_features</span><span class="p">],</span> <span class="n">max_bounds</span><span class="p">)</span> <span class="o">-</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">feature_image_bounds_min</span><span class="p">[</span><span class="n">partially_v_features</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">percent_overlap</span> <span class="o">=</span> <span class="n">area</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">feature_image_bounds_max</span><span class="p">[</span><span class="n">partially_v_features</span><span class="p">]</span> <span class="o">-</span>
                                       <span class="n">feature_image_bounds_min</span><span class="p">[</span><span class="n">partially_v_features</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">temp_visible_features</span><span class="p">[</span><span class="n">partially_v_features</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent_overlap</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">percent_in_fov</span><span class="o">/</span><span class="mf">100.0</span>

        <span class="c1"># now update the boolean list</span>
        <span class="n">visible_feature_bool</span><span class="p">[</span><span class="n">visible_feature_bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_visible_features</span>

        <span class="c1"># now walk through the list and call found/not_found respectively</span>
        <span class="n">visible_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">find</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_catalog</span><span class="o">.</span><span class="n">features</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">visible_feature_bool</span><span class="p">[</span><span class="n">find</span><span class="p">]:</span>
                <span class="n">visible_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find</span><span class="p">)</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">found</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">feature</span><span class="o">.</span><span class="n">not_found</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">visible_features</span></div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>