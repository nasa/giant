<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.relative_opnav.estimators.limb_matching &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../index.html">
    <img class="logo" src="../../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.relative_opnav.estimators.limb_matching</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides the capability to locate the relative position of any target body by matching the observed limb in</span>
<span class="sd">an image with the shape model of the target.</span>

<span class="sd">Description of the Technique</span>
<span class="sd">----------------------------</span>

<span class="sd">Limb matching is a form of OpNav which produces a full 3DOF relative position measurement between the target and the</span>
<span class="sd">camera.  It is a sister technique of ellipse matching, but extended to general bodies.  It does this by matching</span>
<span class="sd">observed limb points in an image to surface points on the shape model and then solving the PnP problem (essentially</span>
<span class="sd">triangulation). As such, this can be a very powerful measurement because it is less sensitive to errors in the a priori</span>
<span class="sd">knowledge of your range to the target than cross correlation, provides more information than just the bearing to the</span>
<span class="sd">target for processing in a filter, and is more computationally efficient.  That being said, the line-of-sight/bearing</span>
<span class="sd">component of the estimate is generally slightly less accurate than cross correlation (when there is good a priori</span>
<span class="sd">knowledge of the shape and the range to the target). This is because limb matching only makes use of the visible</span>
<span class="sd">limb, while cross correlation makes use of all of the visible target.</span>

<span class="sd">Because matching the observed limb to a surface point is not a well defined problem for general bodies (not ellipsoidal)</span>
<span class="sd">this technique is iterative.  It keeps pairing the observed limbs with the correct surface points as the relative</span>
<span class="sd">position between the target and the camera is refined.  In addition, the limb pairing process needs the a priori</span>
<span class="sd">bearing of the target to be fairly close to the actual location of the target in the image.  Therefore, the algorithm</span>
<span class="sd">generally proceeds as follows:</span>

<span class="sd">#. If requested, identify the center of the target in the image using a moment algorithm (:mod:`.moment_algorithm`) and</span>
<span class="sd">   move the target&#39;s a priori to be along the line of sight identified using the moment algorithm.</span>
<span class="sd">#. Identify the observed illuminate limb of the target in the image being processed using</span>
<span class="sd">   :meth:`.ImageProcessing.identify_subpixel_limbs` or :class:`.LimbScanner`</span>
<span class="sd">#. Pair the extracted limb points to possible surface points on the target shape using the current estimate of the state</span>
<span class="sd">#. Solve a linear least squares problem to update the state</span>
<span class="sd">#. Repeat steps 2-4 until convergence or maximum number of iterations exceeded</span>

<span class="sd">Further details on the algorithm can be found `here &lt;https://bit.ly/3mQnB5J&gt;`_.</span>

<span class="sd">.. note::</span>

<span class="sd">    This implements limb based OpNav for irregular bodies.  For regular bodies, like planets and moons, see</span>
<span class="sd">    :mod:`.ellipse_matching` which will be more efficient and accurate.</span>

<span class="sd">Typically this technique is used once the body is fully resolved in the image (around at least 50 pixels in apparent</span>
<span class="sd">diameter) and then can be used as long as the limb is visible in the image. For accurate results, this does require an</span>
<span class="sd">accurate shape model of the target, at least up to an unknown scale.  In addition, this technique can be sensitive to</span>
<span class="sd">errors in the knowledge of the relative orientation of the target frame to the image frame, therefore you need to have a</span>
<span class="sd">pretty good idea of its pole and spin state.  If you don&#39;t have these things then this technique may still work but with</span>
<span class="sd">degraded results.  For very irregular bodies (bodies that are not mostly convex) this technique may be more dependent on</span>
<span class="sd">at least a decent a priori relative state between the camera and the target, as if the initial limb pairing is very far</span>
<span class="sd">off it may never recover.</span>

<span class="sd">Tuning</span>
<span class="sd">------</span>

<span class="sd">There are a few parameters to tune for this method.  The main thing that may make a difference is the choice and tuning</span>
<span class="sd">for the limb extraction routines.  There are 2 categories of routines you can choose from.  The first is edge</span>
<span class="sd">detection, where the limbs are extracted using only the image and the sun direction.  To tune the edge detection limb</span>
<span class="sd">extraction routines refer to the :class:`.LimbEdgeDetection` class.</span>

<span class="sd">The other option for limb extraction is limb scanning.  In limb scanning, predicted illumination values based on the</span>
<span class="sd">shape model and a prior state are correlated with extracted scan lines to locate the limbs in the image.  This technique</span>
<span class="sd">can be quite accurate (if the shape model is accurate) but is typically much slower and the extraction must be repeated</span>
<span class="sd">each iteration.  The general tunings to use for limb scanning are from the :class:`.LimbScanner` class:</span>

<span class="sd">============================================ ===========================================================================</span>
<span class="sd">Parameter                                    Description</span>
<span class="sd">============================================ ===========================================================================</span>
<span class="sd">:attr:`.LimbScanner.number_of_scan_lines`    The number of limb points to extract from the image</span>
<span class="sd">:attr:`.LimbScanner.scan_range`              The extent of the limb to use centered on the sun line in radians (should</span>
<span class="sd">                                             be &lt;= np.pi/2)</span>
<span class="sd">:attr:`.LimbScanner.number_of_sample_points` The number of samples to take along each scan line</span>
<span class="sd">============================================ ===========================================================================</span>

<span class="sd">There are a few other things that can be tuned but they generally have limited effect.  See the :class:`.LimbScanner`</span>
<span class="sd">class for more details.</span>

<span class="sd">In addition, there are a few knobs that can be tweaked on the class itself.</span>

<span class="sd">========================================== =============================================================================</span>
<span class="sd">Parameter                                  Description</span>
<span class="sd">========================================== =============================================================================</span>
<span class="sd">:attr:`.LimbMatching.extraction_method`    Chooses the limb extraction method to be image processing or limb scanning.</span>
<span class="sd">:attr:`.LimbMatching.max_iters`            The maximum number of iterations to perform.</span>
<span class="sd">:attr:`.LimbMatching.recenter`             A flag specifying whether to use a moment algorithm to set the initial guess</span>
<span class="sd">                                           at the line of sight to the target or not.  If your a priori state knowledge</span>
<span class="sd">                                           is bad enough that the predicted location of the target is outside of the</span>
<span class="sd">                                           observed target in the image then you should set this to ``True``.</span>
<span class="sd">:attr:`.LimbMatching.discard_outliers`     A flag specifying whether to remove outliers each iteration step.  Generally</span>
<span class="sd">                                           this should be left to ``True``.</span>
<span class="sd">========================================== =============================================================================</span>


<span class="sd">Beyond this, you only need to ensure that you have a fairly accurate shape model of the target, the knowledge of the sun</span>
<span class="sd">direction in the image frame is good, and the knowledge of the rotation between the principal frame and the camera frame</span>
<span class="sd">is good.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">The class provided in this module is usually not used by the user directly, instead it is usually interfaced with</span>
<span class="sd">through the :class:`.RelativeOpNav` class using the identifier :attr:`~.RelativeOpNav.limb_matching`.  For more</span>
<span class="sd">details on using the :class:`.RelativeOpNav` interface, please refer to the :mod:`.relnav_class` documentation.  For</span>
<span class="sd">more details on using the technique class directly, as well as a description of the ``details`` dictionaries produced</span>
<span class="sd">by this technique, refer to the following class documentation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.estimator_interface_abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">RelNavObservablesType</span><span class="p">,</span> <span class="n">RelNavEstimator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.outlier_identifier</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_outliers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNavImage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">SceneObject</span><span class="p">,</span> <span class="n">Scene</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators._limb_pairer</span><span class="w"> </span><span class="kn">import</span> <span class="n">LimbPairer</span><span class="p">,</span> <span class="n">LimbPairerOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.moment_algorithm</span><span class="w"> </span><span class="kn">import</span> <span class="n">MomentAlgorithm</span><span class="p">,</span> <span class="n">MomentAlgorithmOptions</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NONEARRAY</span>

<div class="viewcode-block" id="LimbMatchingOptions">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/limb_matching/giant.relative_opnav.estimators.limb_matching.LimbMatchingOptions.html#giant.relative_opnav.estimators.limb_matching.LimbMatchingOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LimbMatchingOptions</span><span class="p">(</span><span class="n">LimbPairerOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param extraction_method: The method to use to extract the observed limbs from the image.  Should be</span>
<span class="sd">                                ``&#39;LIMB_SCANNING&#39;`` or ``&#39;EDGE_DETECTION&#39;``.  See :class:`.LimbExtractionMethods` for</span>
<span class="sd">                                details.</span>
<span class="sd">    :param limb_edge_detection_options: The options to use to configure the limb edge detector</span>
<span class="sd">    :param limb_scanner_options: The options to use to configure the limb scanner</span>
<span class="sd">    :param state_atol: the absolute tolerance state convergence criteria (np.abs(update) &lt; state_atol).all())</span>
<span class="sd">    :param state_rtol: the relative tolerance state convergence criteria (np.abs(update)/state &lt; state_rtol).all())</span>
<span class="sd">    :param residual_atol: the absolute tolerance residual convergence criteria</span>
<span class="sd">    :param residual_rtol: the relative tolerance residual convergence criteria</span>
<span class="sd">    :param max_iters: maximum number of iterations for iterative horizon relative navigation</span>
<span class="sd">    :param recenter: A flag to estimate the center using the moment algorithm to get a fast rough estimate of the</span>
<span class="sd">                        center-of-figure</span>
<span class="sd">    :param discard_outliers: A flag to use Median Absolute Deviation to find outliers and get rid of</span>
<span class="sd">                                them</span>
<span class="sd">    :param create_gif: A flag specifying whether to build a gif of the iterations.</span>
<span class="sd">    :param gif_file: the file to save the gif to, optionally with 2 positional format arguments for the image date</span>
<span class="sd">                        and target name being processed</span>
<span class="sd">    :param interpolator: The type of image interpolator to use if the extraction method is set to LIMB_SCANNING.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">state_atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The absolute tolerance state convergence criteria (np.abs(update) &lt; state_atol).all())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">state_rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The relative tolerance state convergence criteria (np.abs(update)/state &lt; state_rtol).all())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">residual_atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The absolute tolerance convergence criteria for residuals </span>
<span class="sd">    (abs(new_resid_ss - old_resid_ss) &lt; residual_atol).all())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">residual_rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The relative tolerance convergence criteria for residuals</span>
<span class="sd">    (abs(new_resid_ss - old_resid_ss)/old_resid_ss &lt; residual_rtol).all())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum number of iterations to attempt in the limb-matching algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">recenter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag to estimate the center using the moment algorithm to get a fast rough estimate of the</span>
<span class="sd">    center-of-figure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">discard_outliers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag specifying whether to attempt to remove outliers in the limb pairs each iteration. </span>
<span class="sd">    </span>
<span class="sd">    For most targets this flag is strongly encouraged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">create_gif</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flag specifying whether to create a gif of the iteration process for review.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gif_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;limb_match_summary_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.gif&#39;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The file to save the gif to.</span>
<span class="sd">    </span>
<span class="sd">    This can optionally can include 2 format locators for the image date and target name to distinguish the gif </span>
<span class="sd">    files from each other.  The image date will be supplied as the first argument to format and the target name will </span>
<span class="sd">    be supplied as the second argument.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="LimbMatching">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/limb_matching/giant.relative_opnav.estimators.limb_matching.LimbMatching.html#giant.relative_opnav.estimators.limb_matching.LimbMatching">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LimbMatching</span><span class="p">(</span><span class="n">LimbPairer</span><span class="p">,</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">LimbMatchingOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements GIANT&#39;s version of limb based OpNav for irregular bodies.</span>

<span class="sd">    The class provides an interface to perform limb based OpNav for each target body that is predicted to be in an</span>
<span class="sd">    image.  It does this by looping through each target object contained in the :attr:`.Scene.target_objs` attribute</span>
<span class="sd">    that is requested.  For each of the targets, the algorithm:</span>

<span class="sd">    #. Places the target along the line of sight identified from the image using the :mod:`.moment_algorithm` if</span>
<span class="sd">       requested</span>
<span class="sd">    #. Extracts observed limb points from the image and pairs them with the target based on the expected apparent</span>
<span class="sd">       diameter of the target and the extent of the identified limbs</span>
<span class="sd">    #. Identifies what points on the surface of the target likely correspond to the identified limb points in the image</span>
<span class="sd">    #. Computes the update to the relative position between the target and the camera that better aligns the observed</span>
<span class="sd">       limbs with the predicted limb points on the target surface.</span>

<span class="sd">    Steps 2-4 are repeated until convergence, divergence, or the maximum number of iteration steps are performed.</span>

<span class="sd">    In step 3, the paired image limb to surface points are filtered for outliers using the :func:`.get_outliers`</span>
<span class="sd">    function, if requested with the :attr:`discard_outliers` attribute.</span>

<span class="sd">    The convergence for the technique is controlled through the parameters :attr:`max_iters`, :attr:`state_rtol`,</span>
<span class="sd">    :attr:`state_atol`, :attr:`residual_rtol`, and :attr:`residual_atol`.  If the fit diverges or is unsuccessful for</span>
<span class="sd">    any reason, iteration will stop and the observed limb points and relative position will be set to NaN.</span>

<span class="sd">    When all of the required data has been successfully loaded into an instance of this class, the :meth:`estimate`</span>
<span class="sd">    method is used to perform the estimation for the requested image.  The results are stored into the</span>
<span class="sd">    :attr:`observed_bearings` attribute for the observed limb locations and the :attr:`observed_positions` attribute for</span>
<span class="sd">    the estimated relative position between the target and the camera. In addition, the predicted location for the limbs</span>
<span class="sd">    for each target are stored in the :attr:`computed_bearings` attribute and the a priori relative position between the</span>
<span class="sd">    target and the camera is stored in the :attr:`computed_positions` attribute. Finally, the details about the fit are</span>
<span class="sd">    stored as a dictionary in the appropriate element in the :attr:`details` attribute.  Specifically, these</span>
<span class="sd">    dictionaries will contain the following keys.</span>

<span class="sd">    =========================== ========================================================================================</span>
<span class="sd">    Key                         Description</span>
<span class="sd">    =========================== ========================================================================================</span>
<span class="sd">    ``&#39;Jacobian&#39;``              The Jacobian matrix from the last completed iteration.  Only available if successful.</span>
<span class="sd">    ``&#39;Inlier Ratio&#39;``          The ratio of inliers to outliers for the last completed iteration.  Only available if</span>
<span class="sd">                                successful.</span>
<span class="sd">    ``&#39;Covariance&#39;``            The 3x3 covariance matrix for the estimated relative position in the camera frame based</span>
<span class="sd">                                on the residuals.  This is only available if successful</span>
<span class="sd">    ``&#39;Number of iterations&#39;``  The number of iterations that the system converged in.  This is only available if</span>
<span class="sd">                                successful.</span>
<span class="sd">    ``&#39;Surface Limb Points&#39;``   The surface points that correspond to the limb points in the target fixed target</span>
<span class="sd">                                centered frame.</span>
<span class="sd">    ``&#39;Failed&#39;``                A message indicating why the fit failed.  This will only be present if the fit failed</span>
<span class="sd">                                (so you could do something like ``&#39;Failed&#39; in limb_matching.details[target_ind]`` to</span>
<span class="sd">                                check if something failed.  The message should be a human readable description of what</span>
<span class="sd">                                called the failure.</span>
<span class="sd">    ``&#39;Prior Residuals&#39;``       The sum of square of the residuals from the prior iteration.  This is only available if</span>
<span class="sd">                                the fit failed due to divergence.</span>
<span class="sd">    ``&#39;Current Residuals&#39;``     The sum of square of the residuals from the current iteration.  This is only available</span>
<span class="sd">                                if the fit failed due to divergence.</span>
<span class="sd">    =========================== ========================================================================================</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Before calling the :meth:`estimate` method be sure that the scene has been updated to correspond to the correct</span>
<span class="sd">        image time.  This class does not update the scene automatically.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">technique</span> <span class="o">=</span> <span class="s1">&#39;limb_matching&#39;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The name of the technique identifier in the :class:`.RelativeOpNav` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">observable_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LIMB</span><span class="p">,</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">RELATIVE_POSITION</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The type of observables this technique generates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LimbMatchingOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param scene: The :class:`.Scene` object containing the target, light, and obscuring objects.</span>
<span class="sd">        :param camera: The :class:`.Camera` object containing the camera model and images to be utilized</span>
<span class="sd">        :param image_processing: The :class:`.ImageProcessing` object to be used to process the images</span>
<span class="sd">        :param options: A dataclass specifying the options to set for this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">LimbMatchingOptions</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="n">moment_options</span> <span class="o">=</span> <span class="n">MomentAlgorithmOptions</span><span class="p">(</span><span class="n">apply_phase_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_apparent_area</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># the moment algorithm instance to use if recentering has been requested.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_algorithm</span><span class="p">:</span> <span class="n">MomentAlgorithm</span> <span class="o">=</span> <span class="n">MomentAlgorithm</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">moment_options</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The moment algorithm instance to use to recenter if we are using limb scanning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">limbs_camera</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NONEARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The limb surface points with respect to the center of the target</span>

<span class="sd">        Until :meth:`estimate` is called this list will be filled with ``None``.</span>

<span class="sd">        Each element of this list corresponds to the same element in the :attr:`.Scene.target_objs` list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># these attributes are used for handling the gif generation and should not be modified by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_ax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_fig</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_limbs_line</span> <span class="o">=</span> <span class="kc">None</span>
        
<div class="viewcode-block" id="LimbMatching.compute_jacobian">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/limb_matching/giant.relative_opnav.estimators.limb_matching.LimbMatching.compute_jacobian.html#giant.relative_opnav.estimators.limb_matching.LimbMatching.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_object</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span> <span class="n">center</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">center_direction</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">limb_points_image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">limb_points_camera</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">relative_position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">scan_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the linear change in the measurements (the distance between the predicted</span>
<span class="sd">        and observed limb points and the scan center) with respect to a change in the state vector.</span>

<span class="sd">        Mathematically the rows of the Jacobian matrix are given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial d_i}{\partial \mathbf{s}}=\frac{\partial d_i}{\partial\mathbf{x}_i}</span>
<span class="sd">            \frac{\partial\mathbf{x}_i}{\partial\mathbf{p}_c}\frac{\partial\mathbf{p}_c}{\partial\mathbf{s}}</span>

<span class="sd">        where :math:`d_i` is the distance along the scan vector between the predicted limb pixel location and the scan</span>
<span class="sd">        center, :math:`\mathbf{s}` is the the state vector that is being estimated, :math:`\mathbf{x}_i` is the pixel</span>
<span class="sd">        location of the predicted limb point, and :math:`\mathbf{p}_c` is the predicted limb point in the camera frame.</span>
<span class="sd">        In addition</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{d_i}{\mathbf{x}_i} = \frac{\mathbf{x}_i-\mathbf{c}}{\|\mathbf{x}_i-\mathbf{c}\|}</span>

<span class="sd">        is the linear change in the distance given a change in the limb pixel location where :math:`\mathbf{c}` is the</span>
<span class="sd">        scan center, :math:`\frac{\partial\mathbf{x}_i}{\partial\mathbf{p}_c}` is the linear change in the limb pixel</span>
<span class="sd">        location given a change in the limb camera frame vector which is defined by the camera model, and</span>
<span class="sd">        :math:`\frac{\partial\mathbf{p}_c}{\partial\mathbf{s}}` is the change in the limb camera frame vector given a</span>
<span class="sd">        change in the state vector, which is defined by the shape model.</span>

<span class="sd">        :param target_object: target object under consideration</span>
<span class="sd">        :param center: The pixel location of the center of the scan rays</span>
<span class="sd">        :param center_direction: the unit vector through the pixel location of the center of the scan rays in the camera</span>
<span class="sd">                                 frame</span>
<span class="sd">        :param limb_points_image: The predicted limb locations in the image in units of pixels</span>
<span class="sd">        :param limb_points_camera: The predicted limb vectors in the camera frame</span>
<span class="sd">        :param relative_position: The current estimate of the position vector from the camera to the target</span>
<span class="sd">        :param scan_vector: The unit vectors from the scan center to the limb points in the image.</span>
<span class="sd">        :param temperature: The temperature of the camera at the time the image was captured</span>
<span class="sd">        :return: The nxm jacobian matrix as a numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute how the predicted limbs change given a change in the state vector</span>
        <span class="n">limb_jacobian</span> <span class="o">=</span> <span class="n">target_object</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">compute_limb_jacobian</span><span class="p">(</span><span class="n">center_direction</span><span class="p">,</span> <span class="n">scan_vector</span><span class="p">,</span> <span class="n">limb_points_camera</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Predict how the pixel locations change given a change in the limb points</span>
        <span class="n">camera_jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compute_pixel_jacobian</span><span class="p">(</span><span class="n">limb_points_camera</span><span class="p">,</span>
                                                                   <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># Compute the distance from the scan center to the limb points in units of pixels</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">limb_points_image</span> <span class="o">-</span> <span class="n">center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Compute the predicted change in the distance given a change in the relative position from the camera to</span>
        <span class="c1"># the target</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span> <span class="o">/</span> <span class="n">distance</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">camera_jacobian</span> <span class="o">@</span> <span class="n">limb_jacobian</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up the limb match summary gif.</span>

<span class="sd">        This prepares the figure and the gif writer and initializes some data.  It is only intended for internal use by</span>
<span class="sd">        the class itself.</span>

<span class="sd">        :param image: The image being processed</span>
<span class="sd">        :param target:  The target being processed</span>
<span class="sd">        :param target_ind:  The index of the target being processed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># since matplotlib can cause problems sometimes only import it if a gif was requested</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.animation</span><span class="w"> </span><span class="kn">import</span> <span class="n">PillowWriter</span>

        <span class="c1"># create the figure and set the layout to tight</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_layout_engine</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>

        <span class="c1"># grab the primary axes</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="c1"># show the image in the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>

        <span class="c1"># Show the predicted location of the limbs based on the a priori</span>
        <span class="c1"># pair the limbs</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">___</span><span class="p">,</span> <span class="n">____</span><span class="p">,</span> <span class="n">predicted_limbs_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_and_pair_limbs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">)</span>

        <span class="n">extracted_limbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">extracted_limbs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># Show the limb points found in the image</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">extracted_limbs</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;extracted limb points&#39;</span><span class="p">)</span>

        <span class="c1"># make the gif writer</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">PillowWriter</span><span class="p">(</span><span class="n">fps</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="c1"># determine the output file and prepare the writer</span>
        <span class="n">out_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gif_file</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                                        <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">writer</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">out_file</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

        <span class="c1"># plot the line and save it for latter</span>
        <span class="n">limbs_line</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">predicted_limbs_image</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;predicted limb&#39;</span><span class="p">)</span>

        <span class="c1"># make a legend</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

        <span class="c1"># zoom in on the region of interest</span>
        <span class="c1"># noinspection PyArgumentList</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">extracted_limbs</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span> <span class="n">extracted_limbs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># store everything for later use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_fig</span> <span class="o">=</span> <span class="n">fig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_limbs_line</span> <span class="o">=</span> <span class="n">limbs_line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span> <span class="o">=</span> <span class="n">writer</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This captures a new frame in the GIF after updating the location of the predicted limb points</span>

<span class="sd">        :meth:`_prepare_gif` must have been called before this method.</span>

<span class="sd">        This is only intended for internal use by the class itself.</span>

<span class="sd">        :param target_ind: the index of the target being considered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># update the location of the predicted limbs in the image</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gif_limbs_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">bearings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">bearings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_limbs_line</span><span class="o">.</span><span class="n">set_offsets</span><span class="p">(</span><span class="n">bearings</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># add the frame to the gif</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span><span class="o">.</span><span class="n">grab_frame</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_finish_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finish writing the gif and clean up the matplotlib stuff.</span>

<span class="sd">        :meth:`_prepare_gif` must have been called before this method.</span>

<span class="sd">        This is only intended for internal use by the class itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># finish the gif</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

        <span class="c1"># close the figure</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gif_fig</span><span class="p">)</span>

        <span class="c1"># reset everything to None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_fig</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_ax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_limbs_line</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="LimbMatching.estimate">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/limb_matching/giant.relative_opnav.estimators.limb_matching.LimbMatching.estimate.html#giant.relative_opnav.estimators.limb_matching.LimbMatching.estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method identifies the position of each target in the camera frame using limb matching.</span>

<span class="sd">        This method first extracts limb observations from an image and matches them to the targets in the scene.  Then,</span>
<span class="sd">        for each target, the position is estimated from the limb observations by pairing the observed limb locations</span>
<span class="sd">        to possible surface locations on the target that could have produced the limb using the current estimate of the</span>
<span class="sd">        state (:meth:`pair_limbs`) and then updating the state vector based on the residuals between the extracted and</span>
<span class="sd">        predicted limbs in a least squares fashion.  This process is repeated until convergence or the maximum number of</span>
<span class="sd">        iterations are reached.</span>

<span class="sd">        Optionally, along the way, if the :attr:`create_gif` flag is set to ``True``, then this class will also create a</span>
<span class="sd">        gif showing how the predicted limb locations change for each iteration.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Before calling this method be sure that the scene has been updated to correspond to the correct</span>
<span class="sd">            image time.  This method does not update the scene automatically.</span>

<span class="sd">        :param image: The image the unresolved algorithm should be applied to as an OpNavImage</span>
<span class="sd">        :param include_targets: An argument specifying which targets should be processed for this image.  If ``None``</span>
<span class="sd">                                then all are processed (no, the irony is not lost on me...)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If we were requested to recenter using a moment algorithm then do it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recenter</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;recentering&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Estimate the center using the moment algorithm to get a fast rough estimate of the cof</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_moment_algorithm</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">include_targets</span><span class="o">=</span><span class="n">include_targets</span><span class="p">)</span>

        <span class="c1"># Process each object in the scene</span>
        <span class="k">for</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_generator</span><span class="p">(</span><span class="n">include_targets</span><span class="o">=</span><span class="n">include_targets</span><span class="p">):</span>

            <span class="c1"># Store the relative position between the object and the camera in the camera frame</span>
            <span class="n">relative_position</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computed_positions</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">relative_position</span>
            
            <span class="n">bearings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_algorithm</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>

            <span class="c1"># recenter based on the moment algorithm estimates</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recenter</span> <span class="ow">and</span> <span class="n">bearings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">bearings</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">new_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="n">bearings</span><span class="p">,</span>
                                                                <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
                <span class="n">new_position</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                <span class="n">target</span><span class="o">.</span><span class="n">change_position</span><span class="p">(</span><span class="n">new_position</span><span class="p">)</span>
                <span class="n">relative_position</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># predefine inliers for the angry inspector...</span>
            <span class="n">inliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="n">stop_process</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">jacobian</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">residual_distances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">iter_num</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">residual_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

            <span class="c1"># Iterate for the specified number of iterations</span>
            <span class="k">for</span> <span class="n">iter_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iters</span><span class="p">):</span>
                <span class="c1"># extract and pair the limbs</span>
                <span class="p">(</span><span class="n">scan_center</span><span class="p">,</span> <span class="n">scan_center_dir</span><span class="p">,</span>
                 <span class="n">scan_dirs_camera</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limbs_camera</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_and_pair_limbs</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;unable to find any limbs for target </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_ind</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Failed&#39;</span><span class="p">:</span> <span class="s2">&quot;Unable to find any limbs for target in the image&quot;</span><span class="p">}</span>
                    <span class="n">stop_process</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

                <span class="c1"># Drop any invalid limbs</span>
                <span class="n">valid_test</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="c1"># type: ignore</span>
                              <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># type: ignore</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">valid_test</span><span class="p">]</span> <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">valid_test</span><span class="p">]</span> <span class="c1"># type: ignore</span>

                <span class="c1"># Convert the extracted limb points in the image into unit vectors in the camera frame</span>
                <span class="n">extracted_limbs_camera</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                                                                          <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
                <span class="c1"># Put everything onto the image plane at z=1</span>
                <span class="n">extracted_limbs_camera</span> <span class="o">/=</span> <span class="n">extracted_limbs_camera</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># Get the distance between the extracted limb points in the image</span>
                <span class="c1"># and the scan center location in the image</span>
                <span class="n">observed_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">scan_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
                                                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># If we are making a gif then update the predicted limb locations and grab the frame</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_gif</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">iter_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_gif</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_gif</span><span class="p">(</span><span class="n">target_ind</span><span class="p">)</span>

                <span class="c1"># Compute the residual distances</span>
                <span class="n">residual_distances</span> <span class="o">=</span> <span class="n">observed_distances</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">-</span>  <span class="c1"># type: ignore</span>
                                                                         <span class="n">scan_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># If we were told to reject outliers at each step</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_outliers</span><span class="p">:</span>
                    <span class="c1"># Use Median Absolute Deviation to find outliers and get rid of them</span>
                    <span class="n">inliers</span> <span class="o">=</span> <span class="o">~</span><span class="n">get_outliers</span><span class="p">(</span><span class="n">residual_distances</span><span class="p">)</span>

                    <span class="n">residual_distances</span> <span class="o">=</span> <span class="n">residual_distances</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">inliers</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">limbs_camera</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limbs_camera</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">inliers</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                    <span class="n">scan_dirs_use</span> <span class="o">=</span> <span class="n">scan_dirs_camera</span><span class="p">[:,</span> <span class="n">inliers</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">scan_dirs_camera</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">scan_dirs_use</span> <span class="o">=</span> <span class="n">scan_dirs_camera</span>

                <span class="c1"># Compute the Jacobian matrix based on the predicted/observed limb locations</span>
                <span class="c1"># noinspection PyTypeChecker</span>
                <span class="n">jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">scan_center</span><span class="p">,</span> <span class="n">scan_center_dir</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">limbs_camera</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                                                 <span class="n">relative_position</span><span class="p">,</span>
                                                 <span class="n">scan_dirs_use</span><span class="p">,</span>
                                                 <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

                <span class="c1"># Check where the jacobian is invalid</span>
                <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># If the jacobian is invalid everywhere something probably went wrong, break out</span>
                <span class="k">if</span> <span class="n">nans</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;invalid jacobian&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Failed&#39;</span><span class="p">:</span> <span class="s1">&#39;The fit failed because the computed Jacobian was all NaN&#39;</span><span class="p">}</span>
                    <span class="n">stop_process</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_gif</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_gif</span><span class="p">()</span>
                    <span class="k">break</span>

                <span class="c1"># Calculate the update to the state vector using LLS</span>
                <span class="n">update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">jacobian</span><span class="p">[</span><span class="o">~</span><span class="n">nans</span><span class="p">],</span> <span class="n">residual_distances</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">~</span><span class="n">nans</span><span class="p">],</span>
                                         <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># If a large update was requested then only do part of the update to avoid over updating</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">update</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">relative_position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">scale</span> <span class="o">*=</span> <span class="mi">2</span>

                <span class="c1"># Apply the scaled update</span>
                <span class="n">relative_position</span> <span class="o">+=</span> <span class="n">update</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">/</span> <span class="n">scale</span>

                <span class="c1"># Change the position of the object to the estimated position</span>
                <span class="n">target</span><span class="o">.</span><span class="n">change_position</span><span class="p">(</span><span class="n">relative_position</span><span class="p">)</span>

                <span class="n">residual_ss_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">residual_distances</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Check if we&#39;ve converged, and if so break out</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">update</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">/</span> <span class="n">relative_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_rtol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;converged in </span><span class="si">{}</span><span class="s1"> iterations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_num</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">update</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_atol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;converged in </span><span class="si">{}</span><span class="s1"> iterations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_num</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">residual_ss_new</span> <span class="o">-</span> <span class="n">residual_ss</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_atol</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;converged in </span><span class="si">{}</span><span class="s1"> iterations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_num</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">residual_ss_new</span> <span class="o">-</span> <span class="n">residual_ss</span><span class="p">)</span><span class="o">/</span><span class="n">residual_ss_new</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_rtol</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;converged in </span><span class="si">{}</span><span class="s1"> iterations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_num</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">residual_ss</span> <span class="o">&lt;</span> <span class="n">residual_ss_new</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Estimation is diverging for target </span><span class="si">{</span><span class="n">target_ind</span><span class="si">}</span><span class="s1"> after </span><span class="si">{</span><span class="n">iter_num</span><span class="si">}</span><span class="s1"> iterations. &#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;Divergence is </span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">residual_ss_new</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">residual_ss</span><span class="p">)</span><span class="o">/</span><span class="n">residual_ss</span><span class="si">}</span><span class="s1">. &#39;</span>
                                  <span class="s1">&#39;Stopping iteration&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Failed&#39;</span><span class="p">:</span> <span class="s1">&#39;The fit failed because it was diverging.&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;Prior Residuals&#39;</span><span class="p">:</span> <span class="n">residual_ss</span><span class="p">,</span>
                                                <span class="s1">&#39;Current Residuals&#39;</span><span class="p">:</span> <span class="n">residual_ss_new</span><span class="p">}</span>
                    <span class="n">stop_process</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

                <span class="n">residual_ss</span> <span class="o">=</span> <span class="n">residual_ss_new</span>

            <span class="c1"># Close out the writer if we were making a gif</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_gif</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_finish_gif</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">stop_process</span><span class="p">:</span>
                <span class="c1"># we failed so we should set things to NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_positions</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Update the final set of limbs observed in the image that were used for the estimation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][:,</span> <span class="n">inliers</span><span class="p">]</span>  <span class="c1"># type: ignore</span>


                <span class="c1"># store the solved for state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_positions</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># get the limb points in the target fixed target centered frame</span>
                <span class="c1"># noinspection PyUnresolvedReferences</span>
                <span class="n">target_centered_fixed_limb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limbs_camera</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">target_centered_fixed_limb</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="nd">@target_centered_fixed_limb</span>

                <span class="c1"># store the details of the fit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Jacobian&#39;</span><span class="p">:</span> <span class="n">jacobian</span><span class="p">,</span>
                                            <span class="s1">&#39;Inlier Ratio&#39;</span><span class="p">:</span> <span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">inliers</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                                            <span class="s1">&#39;Covariance&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">jacobian</span><span class="o">.</span><span class="n">T</span><span class="nd">@jacobian</span><span class="p">)</span><span class="o">*</span><span class="n">residual_distances</span><span class="o">.</span><span class="n">var</span><span class="p">(),</span>  <span class="c1"># type: ignore</span>
                                            <span class="s1">&#39;Number of Iterations&#39;</span><span class="p">:</span> <span class="n">iter_num</span><span class="p">,</span>
                                            <span class="s2">&quot;Surface Limb Points&quot;</span><span class="p">:</span> <span class="n">target_centered_fixed_limb</span><span class="p">}</span></div>


<div class="viewcode-block" id="LimbMatching.reset">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/limb_matching/giant.relative_opnav.estimators.limb_matching.LimbMatching.reset.html#giant.relative_opnav.estimators.limb_matching.LimbMatching.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets the observed/computed attributes, the details attribute, and the gif attributes to have</span>
<span class="sd">        ``None``.</span>

<span class="sd">        This method is called by :class:`.RelativeOpNav` between images to ensure that data is not accidentally applied</span>
<span class="sd">        from one image to the next.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_ax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_fig</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_writer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gif_limbs_line</span> <span class="o">=</span> <span class="kc">None</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>