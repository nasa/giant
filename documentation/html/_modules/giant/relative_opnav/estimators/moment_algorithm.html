<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.relative_opnav.estimators.moment_algorithm &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../index.html">
    <img class="logo" src="../../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.relative_opnav.estimators.moment_algorithm</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a class which implements a moment based (center of illumination) center finding RelNav technique.</span>

<span class="sd">Description of the Technique</span>
<span class="sd">----------------------------</span>

<span class="sd">The moment algorithm is the technique that you typically use when your target begins to become resolved in your images,</span>
<span class="sd">but you still don&#39;t have an accurate shape model for doing a more advanced technique like :mod:`.limb_matching` or</span>
<span class="sd">:mod:`cross_correlation`.  Generally, this only is used for a short while when the target is between 5 and 100 pixels</span>
<span class="sd">in apparent diameter) as you attempt to build a shape model of the target to begin using the more advanced and more</span>
<span class="sd">accurate techniques, however, there is no hard limit on when you can and can&#39;t use this technique.  You can even use it</span>
<span class="sd">when the target is still unresolved or when the target is very large in the image, but in these cases (as in most cases)</span>
<span class="sd">there are much more accurate methods that can be used.</span>

<span class="sd">In order to extract the center finding observables from this method a few steps are followed.  First, we predict roughly</span>
<span class="sd">how many pixels we expect the illuminated portion our target to subtend based on the a priori scene knowledge and</span>
<span class="sd">assuming a spherical target.  We then use this predicted area to set the minimum number of connected pixels we are</span>
<span class="sd">going to consider a possible target in the image (this can be turned off using option :attr:`.use_apparent_area`.</span>
<span class="sd">We then segment the image into foreground/background objects using method :meth:`.segment_image` from image processing.</span>
<span class="sd">For each target in the image we are processing, we then identify the closest segmented object from the image to the</span>
<span class="sd">target and assume that this is the location of the target in the actual image (if you have multiple targets in an image</span>
<span class="sd">then it is somewhat important that your a priori scene is at least moderately accurate to ensure that this pairing works</span>
<span class="sd">correctly).  Finally, we take the foreground objects around the identified segment (to account for possible portions of</span>
<span class="sd">the target that may be separated from the main clump of illumination, such as along the limb) and compute the center of</span>
<span class="sd">illumination using a moment algorithm.  The center of illumination is then corrected for phase angle effects (if</span>
<span class="sd">requested) and the resulting center-of-figure measurements are stored.</span>

<span class="sd">Tuning</span>
<span class="sd">------</span>

<span class="sd">There are a few things that can be tuned for using this technique.  The first set is the tuning parameters for</span>
<span class="sd">segmenting an image into foreground/background objects from the :class:`.ImageProcessing` class.  These are</span>

<span class="sd">============================================= ==========================================================================</span>
<span class="sd">Parameter                                     Description</span>
<span class="sd">============================================= ==========================================================================</span>
<span class="sd">:attr:`.ImageSegmenter.otsu_levels`           The number of levels to attempt to segments the histogram into using</span>
<span class="sd">                                              multi-level Otsu thresholding.</span>
<span class="sd">:attr:`.ImageSegmenter.minimum_segment_area`  The minimum size of a segment for it to be considered a foreground object.</span>
<span class="sd">                                              This can be determined automatically using the :attr:`use_apparent_area`</span>
<span class="sd">                                              flag of this class.</span>
<span class="sd">:attr:`.ImageSegmenter.minimum_segment_dn`    The minimum DN value for a segment to be considered foreground.  This can</span>
<span class="sd">                                              be used to help separate background segments that are slightly brighter</span>
<span class="sd">                                              due to stray light or other noise issues.</span>
<span class="sd">============================================= ==========================================================================</span>

<span class="sd">For more details on using these attributes see the :meth:`.ImageProcessing.segment_image` documentation.</span>

<span class="sd">In addition, there are some tuning parameters on this class itself.  The first is the search radius.</span>
<span class="sd">The search radius is controlled by :attr:`search_distance` attribute.  This should be a number or ``None``.</span>
<span class="sd">If this is not ``None``, then the distance from the centroid of the nearest segment to the predicted target u</span>
<span class="sd">location must be less than this value.  Therefore, you should set this value to account for the expected</span>
<span class="sd">center-of-figure to center-of-brightness shift as well as the uncertainty in the a priori location of the target</span>
<span class="sd">in the scene, while being careful not to set too large of a value if there are multiple targets in the scene to</span>
<span class="sd">avoid ambiguity.  If this is ``None``, then the closest segment is always paired with the target (there is no</span>
<span class="sd">search region considered) unless the segment has already been paired to another target in the scene.</span>

<span class="sd">This technique can predict what the minimum segment area should be in the image using the predicted apparent areas</span>
<span class="sd">for each target.  This can be useful to automatically set the :attr:`.ImageProcessing.minimum_segment_area` based on</span>
<span class="sd">the targets and the a priori location in the camera frame.  Because this is just an approximation, a margin of</span>
<span class="sd">safety is included with :attr:`apparent_area_margin_of_safety`, which is used to shrink the predicted apparent area</span>
<span class="sd">to account for the assumptions about the spherical target and possible errors in the a priori scene information.</span>
<span class="sd">You can turn off this feature and just use the set minimum segment area by setting :attr:`use_apparent_area` to</span>
<span class="sd">``False``.</span>

<span class="sd">Whether the phase correction is applied or not is controlled by the boolean flag :attr:`apply_phase_correction`.</span>
<span class="sd">The information that is passed to the phase correction routines are controlled by the :attr:`phase_correction_type`</span>
<span class="sd">and :attr:`brdf` attributes.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">The class provided in this module is usually not used by the user directly, instead it is usually interfaced with</span>
<span class="sd">through the :class:`.RelativeOpNav` class using the identifier :attr:`~.RelativeOpNav.moment_algorithm`.  For more</span>
<span class="sd">details on using the :class:`.RelativeOpNav` interface, please refer to the :mod:`.relnav_class` documentation.  For</span>
<span class="sd">more details on using the technique class directly, as well as a description of the ``details`` dictionaries produced</span>
<span class="sd">by this technique, refer to the following class documentation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span>  <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.point_spread_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Moment</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNavImage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">Scene</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.user_option_configured</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserOptionConfigured</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image_processing.image_segmenter</span><span class="w"> </span><span class="kn">import</span> <span class="n">ImageSegmenter</span><span class="p">,</span> <span class="n">ImageSegmenterOptions</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.estimator_interface_abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">RelNavObservablesType</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.unresolved</span><span class="w"> </span><span class="kn">import</span> <span class="n">PhaseCorrector</span><span class="p">,</span> <span class="n">PhaseCorrectorOptions</span>

<div class="viewcode-block" id="MomentAlgorithmOptions">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/moment_algorithm/giant.relative_opnav.estimators.moment_algorithm.MomentAlgorithmOptions.html#giant.relative_opnav.estimators.moment_algorithm.MomentAlgorithmOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MomentAlgorithmOptions</span><span class="p">(</span><span class="n">PhaseCorrectorOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param use_apparent_area: A boolean flag specifying whether to predict the minimum apparent area we should</span>
<span class="sd">                                consider when segmenting the image into foreground/background objects.</span>
<span class="sd">    :param apparent_area_margin_of_safety: The margin of safety we will use to decrease the predicted apparent area</span>
<span class="sd">                                            to account for errors in the a priori scene/shape model as well as errors</span>
<span class="sd">                                            introduced by assuming a spherical object.  The predicted apparent area</span>
<span class="sd">                                            will be divided by this number and then supplied as the</span>
<span class="sd">                                            :attr:`~.ImageProcessing.minimum_segment_area` attribute.  This should</span>
<span class="sd">                                            always be &gt;= 1.</span>
<span class="sd">    :param search_distance: The search radius to search around the predicted centers for the observed centers of</span>
<span class="sd">                            the target objects.  This is used as a limit, so that if the closest segmented object to</span>
<span class="sd">                            a predicted target location is greater than this then the target is treated as not</span>
<span class="sd">                            found.  Additionally, if multiple segmented regions fall within this distance of the</span>
<span class="sd">                            target then we treat it as ambiguous and not found.</span>
<span class="sd">    :param apply_phase_correction: A boolean flag specifying whether to apply the phase correction to the observed</span>
<span class="sd">                                    center of brightness to get closer to the center of figure based on the predicted</span>
<span class="sd">                                    apparent diameter of the object.</span>
<span class="sd">    :param phase_correction_type: The type of phase correction to use.  Should be one of the PhaseCorrectionType</span>
<span class="sd">                                    enum values</span>
<span class="sd">    :param brdf: The illumination model to use to compute the illumination values if the ``RASTERED`` phase</span>
<span class="sd">                    correction type is used.  If the ``RASTERED`` phase correction type is not used this is ignored.</span>
<span class="sd">                    If this is left as ``None`` and the ``Rastered`` phase correction type is used, this will default</span>
<span class="sd">                    to the McEwen Model, :class:`.McEwenIllumination`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_apparent_area</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A boolean flag specifying whether to use the predicted apparent area (number of pixels) of the illuminated </span>
<span class="sd">    target in the image to threshold what is considered a foreground object in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">apparent_area_margin_of_safety</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The margin of safety used to decrease the predicted apparent area for each target.</span>
<span class="sd">    </span>
<span class="sd">    This value should always be &gt;= 1, as the predicted area is divided by this to get the effective minimum apparent</span>
<span class="sd">    area for the targets.  This is included to account for errors in the a priori scene/shape model for the targets</span>
<span class="sd">    as well as the errors introduced by assuming spherical targets.  Since there is only one margin of safety for </span>
<span class="sd">    all targets in a scene, you should set this based on the expected worst case for all of the targets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">search_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Half of the distance to search around the predicted centers for the observed centers of the target objects in </span>
<span class="sd">    pixels.</span>
<span class="sd">    </span>
<span class="sd">    This is also used to identify ambiguous target to segmented area pairings.  That is, if 2 segmented areas are </span>
<span class="sd">    within this value of the predicted center of figure for a target, then that target is treated as not found and a</span>
<span class="sd">    warning is printed.</span>
<span class="sd">    </span>
<span class="sd">    If this is ``None`` then the closest segmented object from the image to the predicted center of figure of the </span>
<span class="sd">    target in the image is always chosen.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">apply_phase_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A boolean flag specifying whether to apply the phase correction or not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">image_segmenter_options</span><span class="p">:</span> <span class="n">ImageSegmenterOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The options to use to configure the image segmenter for detecting the object in the image</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="MomentAlgorithm">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/moment_algorithm/giant.relative_opnav.estimators.moment_algorithm.MomentAlgorithm.html#giant.relative_opnav.estimators.moment_algorithm.MomentAlgorithm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MomentAlgorithm</span><span class="p">(</span><span class="n">UserOptionConfigured</span><span class="p">[</span><span class="n">MomentAlgorithmOptions</span><span class="p">],</span> <span class="n">PhaseCorrector</span><span class="p">,</span> <span class="n">MomentAlgorithmOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements GIANT&#39;s version of moment based center finding for extracting bearing measurements to resolved</span>
<span class="sd">    or or unresolved targets in an image.</span>

<span class="sd">    The class provides an interface to perform moment based center for each target body that is predicted to be in an</span>
<span class="sd">    image.  It does this by looping through each target object contained in the :attr:`.Scene.target_objs` attribute</span>
<span class="sd">    that is is requested.  For each of the targets, the algorithm:</span>

<span class="sd">    #. Predicts the location of the target in the image using the a priori knowledge of the scene</span>
<span class="sd">    #. Predicts the apparent area of the target in the scene assuming a spherical target.</span>
<span class="sd">    #. Segments the image into foreground/background objects using the smallest expected apparent area of all</span>
<span class="sd">       targets as the minimum segment area.  This is done using :meth:`.ImageProcessing.segment_image`</span>
<span class="sd">    #. Identifies the closest foreground segment to the predicted target location that is also within the user</span>
<span class="sd">       specified search radius.  If the closest segment is also the closest segment for another target in the image,</span>
<span class="sd">       then both targets are recorded as not found.  If no segments are within the search radius of the predicted</span>
<span class="sd">       target center then the target is marked as not found.</span>
<span class="sd">    #. Takes the foreground objects around the identified segment and finds the centroid of the illuminated areas</span>
<span class="sd">       using a moment algorithm to compute the observed center of brightness.</span>
<span class="sd">    #. If requested, corrects the observed center of brightness to the observed center of figure using the</span>
<span class="sd">       :meth:`.compute_phase_correction`.</span>

<span class="sd">    For more details on the image segmentation, along with possible tuning parameters, refer to the</span>
<span class="sd">    :meth:`.ImageProcessing.segment_image` documentation.</span>

<span class="sd">    The search radius is controlled by :attr:`.search_distance` attribute.  This should be a number or ``None``.</span>
<span class="sd">    If this is not ``None``, then the distance from the centroid of the nearest segment to the predicted target u</span>
<span class="sd">    location must be less than this value.  Therefore, you should set this value to account for the expected</span>
<span class="sd">    center-of-figure to center-of-brightness shift as well as the uncertainty in the a priori location of the target</span>
<span class="sd">    in the scene, while being careful not to set too large of a value if there are multiple targets in the scene to</span>
<span class="sd">    avoid ambiguity.  If this is ``None``, then the closest segment is always paired with the target (there is no</span>
<span class="sd">    search region considered) unless the segment has already been paired to another target in the scene.</span>

<span class="sd">    This technique can predict what the minimum segment area should be in the image using the predicted apparent areas</span>
<span class="sd">    for each target.  This can be useful to automatically set the :attr:`.ImageProcessing.minimum_segment_area` based on</span>
<span class="sd">    the targets and the a priori location in the camera frame.  Because this is just an approximation, a margin of</span>
<span class="sd">    safety is included with :attr:`apparent_area_margin_of_safety`, which is used to shrink the predicted apparent area</span>
<span class="sd">    to account for the assumptions about the spherical target and possible errors in the a priori scene information.</span>
<span class="sd">    You can turn off this feature and just use the set minimum segment area by setting :attr:`use_apparent_area` to</span>
<span class="sd">    ``False``.</span>

<span class="sd">    Whether the phase correction is applied or not is controlled by the boolean flag :attr:`apply_phase_correction`.</span>
<span class="sd">    The information that is passed to the phase correction routines are controlled by the :attr:`phase_correction_type`</span>
<span class="sd">    and :attr:`brdf` attributes.</span>

<span class="sd">    When all of the required data has been successfully loaded into an instance of this class, the :meth:`estimate`</span>
<span class="sd">    method is used to extract the observed centers of the target bodies predicted to be in the requested image.  The</span>
<span class="sd">    results are stored into the :attr:`observed_bearings` attribute. In addition, the predicted location for each target</span>
<span class="sd">    is stored in the :attr:`computed_bearings` attribute. Finally, the details about the fit are stored as a</span>
<span class="sd">    dictionary in the appropriate element in the :attr:`details` attribute.  Specifically, these dictionaries will</span>
<span class="sd">    contain the following keys.</span>

<span class="sd">    ====================== =============================================================================================</span>
<span class="sd">    Key                    Description</span>
<span class="sd">    ====================== =============================================================================================</span>
<span class="sd">    ``&#39;Fit&#39;``              The fit moment object.  Only available if successful.</span>
<span class="sd">    ``&#39;Phase Correction&#39;`` The phase correction vector used to convert from center of brightness to center of figure.</span>
<span class="sd">                           This will only be available if the fit was successful.  If :attr:`apply_phase_correction` is</span>
<span class="sd">                           ``False`` then this will be an array of 0.</span>
<span class="sd">    ``&#39;Observed Area&#39;``    The area (number of pixels that were considered foreground) observed for this target.</span>
<span class="sd">                           This is only available if the fit was successful.</span>
<span class="sd">    ``&#39;Predicted Area&#39;``   The area (number of pixels that were considered foreground) predicted for this target.</span>
<span class="sd">                           This is only available if the fit was successful.</span>
<span class="sd">    ``&#39;Failed&#39;``           A message indicating why the fit failed.  This will only be present if the fit failed (so you</span>
<span class="sd">                           could do something like ``&#39;Failed&#39; in moment_algorithm.details[target_ind]`` to check if</span>
<span class="sd">                           something failed.  The message should be a human readable description of what called the</span>
<span class="sd">                           failure.</span>
<span class="sd">    ``&#39;Found Segments&#39;``   All of the segments that were found in the image.  This is a tuple of all of the returned</span>
<span class="sd">                           values from :meth:`.ImageProcessing.segment_image`.  This is only included if the fit failed</span>
<span class="sd">                           for some reason.</span>
<span class="sd">    ====================== =============================================================================================</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Before calling the :meth:`estimate` method be sure that the scene has been updated to correspond to the correct</span>
<span class="sd">        image time.  This class does not update the scene automatically.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">technique</span> <span class="o">=</span> <span class="s1">&#39;moment_algorithm&#39;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The name of the technique identifier in the :class:`.RelativeOpNav` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">observable_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The type of observables this technique generates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span>
                <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentAlgorithmOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param scene: The :class:`.Scene` object containing the target, light, and obscuring objects.</span>
<span class="sd">        :param camera: The :class:`.Camera` object containing the camera model and images to be utilized</span>
<span class="sd">        :param image_processing: The :class:`.ImageProcessing` object to be used to process the images</span>
<span class="sd">        :param options: A dataclass specifying the options to set for this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">MomentAlgorithmOptions</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">image_segmenter</span> <span class="o">=</span> <span class="n">ImageSegmenter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_segmenter_options</span><span class="p">)</span>

<div class="viewcode-block" id="MomentAlgorithm.estimate">
<a class="viewcode-back" href="../../../../relative_opnav/estimators/moment_algorithm/giant.relative_opnav.estimators.moment_algorithm.MomentAlgorithm.estimate.html#giant.relative_opnav.estimators.moment_algorithm.MomentAlgorithm.estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method extracts the observed center of figure for each requested target object from the supplied image.</span>

<span class="sd">        This method works by first predicting the location of the center-of-figure of the target objects in the image,</span>
<span class="sd">        then segmenting the current image into foreground/background objects using :meth:`.segment_image`, matching the</span>
<span class="sd">        expected targets with the segmented foreground objects using a nearest neighbor search, using a moment algorithm</span>
<span class="sd">        to compute a more accurate observed center-of-brightness for each target, and then finally correcting the</span>
<span class="sd">        observed center of brightness to the center of figure using a phase correction, if requested.  The results are</span>
<span class="sd">        stored into the :attr:`computed_bearings`, :attr:`observed_bearings`, and :attr:`details` attributes.  If a</span>
<span class="sd">        target object cannot be matched to an observed foreground object then a warning is printed and NaN values are</span>
<span class="sd">        stored. For a more in depth description of what is happening refer to the class documentation.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Before calling this method be sure that the scene has been updated to correspond to the correct</span>
<span class="sd">            image time.  This method does not update the scene automatically.</span>

<span class="sd">        :param image: The image the unresolved algorithm should be applied to as an OpNavImage</span>
<span class="sd">        :param include_targets: An argument specifying which targets should be processed for this image.  If ``None``</span>
<span class="sd">                                then all are processed (no, the irony is not lost on me...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store the original segment area from image processing in case we overwrite it</span>
        <span class="n">original_segment_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_segmenter</span><span class="o">.</span><span class="n">minimum_segment_area</span>

        <span class="c1"># loop through the requested targets and compute their expected apparent area</span>
        <span class="n">expected_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_generator</span><span class="p">(</span><span class="n">include_targets</span><span class="p">):</span>
            <span class="c1"># compute the phase angle</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">phase_angle</span><span class="p">(</span><span class="n">target_ind</span><span class="p">)</span>

            <span class="c1"># predict the apparent radius in pixels</span>
            <span class="n">apparent_diameter</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_apparent_diameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
            <span class="n">apparent_radius</span> <span class="o">=</span> <span class="n">apparent_diameter</span><span class="o">/</span><span class="mi">2</span>

            <span class="c1"># compute the predicted area in pixels assuming a projected circle for the illuminated limb and an ellipse</span>
            <span class="c1"># for the terminator</span>
            <span class="k">if</span> <span class="n">phase</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="c1"># if our phase angle is less than 90 degrees then we add half the terminator ellipse area to half the</span>
                <span class="c1"># limb circle area.</span>
                <span class="n">expected_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">apparent_radius</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if our phase angle is greater than 90 degrees then we subtract half the terminator ellipse area from</span>
                <span class="c1"># half the limb circle area.</span>
                <span class="n">expected_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">apparent_radius</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">)))</span>

        <span class="c1"># now if we are to use the minimum area for segmenting the image</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_apparent_area</span><span class="p">:</span>
            <span class="c1"># get the minimum area corrected by the margin of safety</span>
            <span class="n">minimum_area</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">expected_areas</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">apparent_area_margin_of_safety</span>
            <span class="c1"># set it to the appropriate attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_segmenter</span><span class="o">.</span><span class="n">minimum_segment_area</span> <span class="o">=</span> <span class="n">minimum_area</span>

        <span class="c1"># Now segment the image using Otsu/connected components</span>
        <span class="n">segments</span><span class="p">,</span> <span class="n">foreground</span><span class="p">,</span> <span class="n">segment_stats</span><span class="p">,</span> <span class="n">segment_centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_segmenter</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="n">used_segments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through each requested target</span>
        <span class="k">for</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_generator</span><span class="p">(</span><span class="n">include_targets</span><span class="p">):</span>

            <span class="c1"># store the relative position</span>
            <span class="n">relative_position</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># predict where the target should be</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">relative_position</span><span class="p">,</span>
                                                                                      <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

            <span class="c1"># figure out which segment is closest</span>
            <span class="n">closest_ind</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">closest_distance</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">segment_ind</span><span class="p">,</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_centroids</span><span class="p">):</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centroid</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">closest_ind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">closest_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_distance</span><span class="p">:</span>
                            <span class="n">closest_ind</span> <span class="o">=</span> <span class="n">segment_ind</span>
                            <span class="n">closest_distance</span> <span class="o">=</span> <span class="n">distance</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">closest_ind</span> <span class="o">=</span> <span class="n">segment_ind</span>
                        <span class="n">closest_distance</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">closest_distance</span><span class="p">:</span>
                        <span class="n">closest_ind</span> <span class="o">=</span> <span class="n">segment_ind</span>
                        <span class="n">closest_distance</span> <span class="o">=</span> <span class="n">distance</span>

            <span class="c1"># check if nothing met the tolerance</span>
            <span class="k">if</span> <span class="n">closest_ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No segmented foreground objects are within the requested search region of target &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target_ind</span><span class="si">}</span><span class="s1">. There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_centroids</span><span class="p">)</span><span class="si">}</span><span class="s1"> found in the image.&#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;Please consider adjusting your search region or changing the image &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;processing settings.&#39;</span><span class="p">)</span>

                <span class="c1"># set the failure message in details</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Failed&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;This target is not with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_distance</span><span class="si">}</span><span class="s2"> of any segmented&quot;</span>
                                                      <span class="sa">f</span><span class="s2">&quot;area in the image.  There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_centroids</span><span class="p">)</span><span class="si">}</span><span class="s2"> found &quot;</span>
                                                      <span class="sa">f</span><span class="s2">&quot;in the image.&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;Found Segments&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">foreground</span><span class="p">,</span> <span class="n">segment_stats</span><span class="p">,</span> <span class="n">segment_centroids</span><span class="p">)}</span>
                <span class="k">continue</span>

            <span class="c1"># check if we already used this segment</span>
            <span class="k">if</span> <span class="n">closest_ind</span> <span class="ow">in</span> <span class="n">used_segments</span><span class="p">:</span>
                <span class="c1"># TODO: consider using the predicted area/observed area ratio to break ties.</span>
                <span class="n">other_target</span> <span class="o">=</span> <span class="n">used_segments</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">closest_ind</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Target </span><span class="si">{</span><span class="n">target_ind</span><span class="si">}</span><span class="s1"> is closest to segment </span><span class="si">{</span><span class="n">closest_ind</span><span class="si">}</span><span class="s1"> which is also the closest &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;segment to target </span><span class="si">{</span><span class="n">other_target</span><span class="si">}</span><span class="s1">.  This ambiguity cannot be broken.  Please consider &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;adjusting the apriori scene conditions to be better or adjusting the image processing &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;settings to find more or less segmented object&#39;</span><span class="p">)</span>
                <span class="c1"># set the other observed bearing to np.nan</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">other_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="c1"># set this observed bearing to np.nan</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="c1"># set the other details to indicate the failure</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">other_target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Failed&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;This target and target </span><span class="si">{</span><span class="n">target_ind</span><span class="si">}</span><span class="s2"> are both closest to &quot;</span>
                                                        <span class="sa">f</span><span class="s2">&quot;segment </span><span class="si">{</span><span class="n">closest_ind</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">segment_centroids</span><span class="p">[</span><span class="n">closest_ind</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                                                        <span class="sa">f</span><span class="s2">&quot;leading to ambiguity.&quot;</span><span class="p">,</span>
                                              <span class="s2">&quot;Found Segments&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">foreground</span><span class="p">,</span> <span class="n">segment_stats</span><span class="p">,</span>
                                                                 <span class="n">segment_centroids</span><span class="p">)}</span>

                <span class="c1"># set the details for this target to indicate the failure</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Failed&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;This target and target </span><span class="si">{</span><span class="n">other_target</span><span class="si">}</span><span class="s2"> are both closest to &quot;</span>
                                                      <span class="sa">f</span><span class="s2">&quot;segment </span><span class="si">{</span><span class="n">closest_ind</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">segment_centroids</span><span class="p">[</span><span class="n">closest_ind</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                                                      <span class="sa">f</span><span class="s2">&quot;leading to ambiguity.&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;Found Segments&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">foreground</span><span class="p">,</span> <span class="n">segment_stats</span><span class="p">,</span> <span class="n">segment_centroids</span><span class="p">)}</span>

                <span class="k">continue</span>

            <span class="c1"># store which segment was used</span>
            <span class="n">used_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_ind</span><span class="p">)</span>

            <span class="c1"># get the observed centroid for the segmented area</span>
            <span class="c1"># extract the region around the blob frm the found segment.  Include some extra pixels to capture things</span>
            <span class="c1"># like the terminator.  Use a fudge factor of 1/tenth of the sqrt of the area with a minimum of 10 pixels</span>
            <span class="n">fudge_factor</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">segment_stats</span><span class="p">[</span><span class="n">closest_ind</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">])</span><span class="o">*</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">top_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">segment_stats</span><span class="p">[</span><span class="n">closest_ind</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_TOP</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_LEFT</span><span class="p">]]</span> <span class="o">-</span>
                                <span class="n">fudge_factor</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">top_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">top_left</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">bottom_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">top_left</span> <span class="o">+</span> <span class="n">segment_stats</span><span class="p">[</span><span class="n">closest_ind</span><span class="p">,</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_HEIGHT</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_WIDTH</span><span class="p">]]</span> <span class="o">+</span>
                                   <span class="mi">2</span><span class="o">*</span><span class="n">fudge_factor</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># no need to clip bottom right because the slice will</span>

            <span class="n">use_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">use_image</span><span class="p">[</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">foreground</span><span class="p">[</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># get the x/y pixel location where we are including in centroiding</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">use_image</span><span class="p">)</span>

            <span class="c1"># compute the center of the illumination of the blob (centroid)</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">Moment</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">image</span><span class="p">[</span><span class="n">use_image</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

            <span class="c1"># store the location of the centroid, which is the observed center of brightness</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">centroid</span>

            <span class="c1"># apply the phase correction if requested</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_phase_correction</span><span class="p">:</span>
                <span class="n">correction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_phase_correction</span><span class="p">(</span><span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">observed_bearings</span> <span class="o">+=</span> <span class="n">correction</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># store the details about the fit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Fit&#39;</span><span class="p">:</span> <span class="n">fit</span><span class="p">,</span>
                                        <span class="s1">&#39;Phase Correction&#39;</span><span class="p">:</span> <span class="n">correction</span><span class="p">,</span>
                                        <span class="s1">&#39;Observed Area&#39;</span><span class="p">:</span> <span class="n">use_image</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                                        <span class="s1">&#39;Predicted Area&#39;</span><span class="p">:</span> <span class="n">expected_areas</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]}</span>

        <span class="c1"># reset the image processing minimum segment area in case we messed with it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_segmenter</span><span class="o">.</span><span class="n">minimum_segment_area</span> <span class="o">=</span> <span class="n">original_segment_area</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>