<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.relative_opnav.relnav_class &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.relative_opnav.relnav_class</h1><div class="highlight"><pre>
<span></span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a subclass of the :class:`.OpNav` class for performing relative OpNav.</span>

<span class="sd">Interface Description</span>
<span class="sd">---------------------</span>

<span class="sd">In GIANT, Relative OpNav refers to the process of identifying targets of interest in an image.  These targets can be</span>
<span class="sd">natural bodies, surface features on natural bodies, or even man made objects.  Typically the result of identifying</span>
<span class="sd">these targets in images is line-of-sight or bearing measurements to the target in the image, which, when coupled with</span>
<span class="sd">the knowledge of the camera inertial pointing (possibly from the :mod:`.stellar_opnav` module) gives inertial bearing</span>
<span class="sd">measurements that can be ingested in a navigation filter.  A couple of techniques result in different types of</span>
<span class="sd">observations, but these are discussed in more detail for the appropriate techniques.</span>

<span class="sd">The :class:`RelativeOpNav` class is the primary interface for performing relative OpNav in GIANT, and in general is what</span>
<span class="sd">the user will interact with to process images.  It provides direct access to all of the estimators for doing different</span>
<span class="sd">types of RelNav for editing settings, and additionally provides ``{technique}_estimate`` methods which process each</span>
<span class="sd">requested image by updating the :attr:`~.RelativeOpNav.scene` to reflect the **a priori** conditions at the image time,</span>
<span class="sd">applying the specified technique to the image to extract the observables, and then storing the extracted observations</span>
<span class="sd">and details about those observations for you. The typical scheme for these methods is ``{module_name}_estimate`` for</span>
<span class="sd">instance ``cross_correlation_estimate``. In addition to these methods, this class also provides a :meth:`auto_estimate`</span>
<span class="sd">method, which attempts to automatically pick the appropriate RelNav technique to use for each image based on the type of</span>
<span class="sd">target being identified and the **a priori** knowledge of the apparent diameter of the object in the image.</span>
<span class="sd">Specifically, this method chooses from the 5 most typical RelNav techniques, :mod:`.unresolved`,</span>
<span class="sd">:mod:`.moment_algorithm`, :mod:`.cross_correlation`, :mod:`.limb_matching`, and :mod:`.sfn`. More details on how this</span>
<span class="sd">decision is made are provided in the :meth:`.auto_estimate` documentation.  For typical users, this method is all that</span>
<span class="sd">they will need for doing RelNav, however, the lower-level methods for force choosing the method are provided for more</span>
<span class="sd">advanced analysis.</span>

<span class="sd">For example, we could do something like the following (from the directory containing ``sample_data`` as generated by a</span>
<span class="sd">call to :mod:`.generate_sample_data`):</span>

<span class="sd">    &gt;&gt;&gt; import pickle</span>
<span class="sd">    &gt;&gt;&gt; from giant.relative_opnav import RelativeOpNav</span>
<span class="sd">    &gt;&gt;&gt; with open(&#39;sample_data/camera.pickle&#39;, &#39;rb&#39;) as input_file:</span>
<span class="sd">    ...     camera = pickle.load(input_file)</span>
<span class="sd">    &gt;&gt;&gt; with open(&#39;sample_data/kdtree.pickle&#39;, &#39;rb&#39;) as input_file:</span>
<span class="sd">    ...     target = pickle.load(input_file)</span>
<span class="sd">    &gt;&gt;&gt; from giant.scripts.generate_sample_data import (target_position, target_orientation,</span>
<span class="sd">    ...                                                 sun_position, sun_orientation)</span>
<span class="sd">    &gt;&gt;&gt; from giant.ray_tracer.scene import Scene, SceneObject</span>
<span class="sd">    &gt;&gt;&gt; from giant.ray_tracer.shapes import Point</span>
<span class="sd">    &gt;&gt;&gt; camera.only_short_on()</span>
<span class="sd">    &gt;&gt;&gt; scene = Scene(camera, SceneObject(target, position_function=target_position, orientation_function=target_orientation, name=&#39;Itokawa&#39;),</span>
<span class="sd">    ...                   light_obj=SceneObject(Point, position_function=sun_position, orientation_function=sun_orientation, name=&#39;Sun&#39;))</span>
<span class="sd">    &gt;&gt;&gt; my_relnav = RelativeOpNav(camera, scene)</span>
<span class="sd">    &gt;&gt;&gt; my_relnav.auto_estimate()</span>

<span class="sd">To generate RelNav observables for each short exposure image in the camera.</span>

<span class="sd">Extending RelativeOpNav With New Techniques</span>
<span class="sd">-------------------------------------------</span>

<span class="sd">In addition to the built in techniques from GIANT it is possible to extend the :class:&#39;.RelativeOpNav` object with new</span>
<span class="sd">techniques using the :meth:`.RelativeOpNav.register` class method/decorator.  Using this method to register a new</span>
<span class="sd">technique creates all the typical attributes/methods for the technique in the :class:`.RelativeOpNav` class without</span>
<span class="sd">having to subclass it, including ``{technique}_estimate``, ``{technique}_details`` replacing ``{technique}`` with the</span>
<span class="sd">name of the technique.  It will also package the results for you into the appropriate attribute (</span>
<span class="sd">:attr:`.center_finding_results`, :attr:`.relative_position_results`, :attr:`.landmark_results`&#39;, :attr:`.limb_results`,</span>
<span class="sd">and :attr:`.saved_templates`) depending on the type of observables generated.</span>

<span class="sd">Therefore, to register a new template we could do something like</span>

<span class="sd">.. code::</span>

<span class="sd">    @RelativeOpNav.register</span>
<span class="sd">    class MyNewTechnique(RelNavEstimator):</span>
<span class="sd">        technique = &quot;my_new_technique&quot;</span>
<span class="sd">        observable_type = [RelNavObservablesType.CENTER_FINDING, RelNavObservablesType.RELATIVE_POSITION]</span>
<span class="sd">        generates_templates = False</span>

<span class="sd">        def estimate(self, image, include_targets=None):</span>

<span class="sd">            # do the thing</span>
<span class="sd">            self.computed_bearings = [np.zeros(2) for _ in range(len(self.scene.target_objs))</span>
<span class="sd">            self.computed_positions = [np.zeros(3) for _ in range(len(self.scene.target_objs))</span>
<span class="sd">            self.observed_bearings = [np.zeros(2) for _ in range(len(self.scene.target_objs))</span>
<span class="sd">            self.observed_positions = [np.zeros(3) for _ in range(len(self.scene.target_objs))</span>

<span class="sd">            self.details = [{&#39;status&#39;: &quot;we did the thing!&quot;} for _ in range(len(self.scene.taget_objs))]</span>

<span class="sd">which would register ``MyNewTechnique`` to name ``my_new_technique`` so that we could do something like</span>
<span class="sd">``relnav.my_new_technique_estimate()`` where ``relnav`` is an instance of :class:`RelativeOpNav`.  Note that the</span>
<span class="sd">registration must be done before creating an instance of :class:`RelativeOpNav`. Therefore, the code containing the</span>
<span class="sd">above example would needs to be imported before intializing the :class:`RelativeOpNav`.</span>

<span class="sd">For a more general description of the steps needed to perform relative navigation, refer to the :mod:`.relative_opnav`</span>
<span class="sd">documentation.  For a more in-depth examination of the :class:`RelativeOpNav` class, continue through the following</span>
<span class="sd">class documentation. For more details on adding new techniques to the :class:`RelativeOpNav` class, see the</span>
<span class="sd">:mod:`.relnav_estimators` documentation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partialmethod</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.opnav_class</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNav</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">SceneObject</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.shapes</span><span class="w"> </span><span class="kn">import</span> <span class="n">Ellipsoid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNavImage</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">PATH</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RelNavObservablesType</span><span class="p">,</span> <span class="n">RelNavEstimator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.limb_matching</span><span class="w"> </span><span class="kn">import</span> <span class="n">LimbMatching</span><span class="p">,</span> <span class="n">LimbMatchingOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.ellipse_matching</span><span class="w"> </span><span class="kn">import</span> <span class="n">EllipseMatching</span><span class="p">,</span> <span class="n">EllipseMatchingOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.moment_algorithm</span><span class="w"> </span><span class="kn">import</span> <span class="n">MomentAlgorithm</span><span class="p">,</span> <span class="n">MomentAlgorithmOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.unresolved</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnresolvedCenterFinding</span><span class="p">,</span> <span class="n">UnresolvedCenterFindingOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.cross_correlation</span><span class="w"> </span><span class="kn">import</span> <span class="n">XCorrCenterFinding</span><span class="p">,</span> <span class="n">XCorrCenterFindingOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.constraint_matching</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstraintMatching</span><span class="p">,</span> <span class="n">ConstraintMatchingOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.sfn</span><span class="w"> </span><span class="kn">import</span> <span class="n">FeatureCatalog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.relative_opnav.estimators.sfn</span><span class="w"> </span><span class="kn">import</span> <span class="n">SurfaceFeatureNavigation</span><span class="p">,</span> <span class="n">SurfaceFeatureNavigationOptions</span>




<span class="n">RESULTS_DTYPE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;predicted&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span> <span class="p">(</span><span class="s1">&#39;measured&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span> <span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;U3&#39;</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;observation date&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime64[us]&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;landmark id&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;target position&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span> <span class="p">(</span><span class="s1">&#39;target name&#39;</span><span class="p">,</span> <span class="s1">&#39;U64&#39;</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;target body&#39;</span><span class="p">,</span> <span class="s1">&#39;U64&#39;</span><span class="p">)])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The numpy structured datatype used to package most RelNav observables.  </span>

<span class="sd">For an overview of how structured data types work in numpy, refer to https://numpy.org/doc/stable/user/basics.rec.html</span>

<span class="sd">The following table describes the typical purpose of each field.  Occasionally these conventions may not be followed, in</span>
<span class="sd">which case it will be clearly documented in the documentation for the RelNav type.</span>

<span class="sd">================ ================ ======================================================================================</span>
<span class="sd">Field            Type             Description</span>
<span class="sd">================ ================ ======================================================================================</span>
<span class="sd">predicted        3 element double The predicted observable based on the a priori state knowledge.  For most bearing type</span>
<span class="sd">                                  measurements, only the first 2 components of the array are used and are (x, y) or </span>
<span class="sd">                                  (column, row) in units of pixels.  For most vector measurements (3DP) all 3 components </span>
<span class="sd">                                  are used and are (x, y, z) in kilometers.</span>
<span class="sd">measured         3 element double The measured observable from the image.  For most bearing type</span>
<span class="sd">                                  measurements, only the first 2 components of the array are used and are (x, y) or </span>
<span class="sd">                                  (column, row) in units of pixels.  For most vector measurements (3DP) all 3 components </span>
<span class="sd">                                  are used and are (x, y, z) in kilometers.</span>
<span class="sd">type             3 characters     The type of the measurement.  Options typically are ``&#39;cof&#39;`` to indicate a bearing </span>
<span class="sd">                                  measurement to the center-of-figure of the target, ``&#39;lim&#39;`` to indicate a bearing </span>
<span class="sd">                                  measurement to a point on the limb of the target, ``&#39;lmk&#39;`` to indicate a bearing </span>
<span class="sd">                                  measurement to a surface feature on the target, ``&#39;3dp&#39;`` to indicate a relative </span>
<span class="sd">                                  position measurement from the center of figure of the target to the camera, and</span>
<span class="sd">                                  ``&#39;con&#39;`` to indicate an image constraint measurement where the same feature is </span>
<span class="sd">                                  observed in 2 different images.</span>
<span class="sd">observation date datetime         The date/time of the observation.  This is the same as :attr:`.Image.observation_date`</span>
<span class="sd">                                  but is included here for convenience (so you don&#39;t need the full image to know when</span>
<span class="sd">                                  the observation was taken).</span>
<span class="sd">landmark id      integer          An identifier for the landmark that was targeted.  For measurements to the center of </span>
<span class="sd">                                  figure of the target this is always 0.  For measurements to landmarks and limbs, this </span>
<span class="sd">                                  will be the index into the list of targets.  For image constraint measurements, this </span>
<span class="sd">                                  will be the key to use to pair the observations together.</span>
<span class="sd">target position  3 element double The location of the target in the target-fixed frame.  For center of figure </span>
<span class="sd">                                  measurements this will always be zero.  For landmark and limb measurements it will be </span>
<span class="sd">                                  the target-fixed location in kilometers.  For image constraint measurements, it will</span>
<span class="sd">                                  generally be zero, unless the constraint is generated from a known feature in which </span>
<span class="sd">                                  case it will be the target-fixed location in kilometers.</span>
<span class="sd">target name      str              A string giving the name of the target. For center of figure measurements this </span>
<span class="sd">                                  will be ``&#39;{} cof&#39;`` where {} is replaced with the name of the target from the </span>
<span class="sd">                                  :attr:`.SceneObject.name` attribute.  For limb observations, it will be </span>
<span class="sd">                                  ``&#39;LIMB{:.4g}|{:.4g}|{:.4g}&#39; where the 3 {:.4g} will be replaced with the target fixed</span>
<span class="sd">                                  location of the limb.  For landmark observations, it will be the name of the landmark </span>
<span class="sd">                                  observed from the :attr:`.SurfaceFeature.name` attribute. For image constraint </span>
<span class="sd">                                  observations it will be ``&#39;CONST{}&#39;`` where ``&#39;{}&#39;`` will be replaced by the key</span>
<span class="sd">                                  number for the constraint, unless the constraint was generated from a known feature, </span>
<span class="sd">                                  in which case it will be the feature name.</span>
<span class="sd">target body      str              The name of the body hosting the target, retrieved from the :attr:`.SceneObject.name` </span>
<span class="sd">                                  attribute.</span>
<span class="sd">================ ================ ======================================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="RelativeOpNav">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.html#giant.relative_opnav.relnav_class.RelativeOpNav">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RelativeOpNav</span><span class="p">(</span><span class="n">OpNav</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class serves as the main user interface for performing relative optical navigation.</span>

<span class="sd">    The class acts as a container for the :class:`.Camera`, :class:`.ImageProcessing`, and :class:`.Scene` instances as</span>
<span class="sd">    well as for instance of all of the registered RelNav techniques.  By default the registered RelNav techniques are</span>
<span class="sd">    :class:`.XCorrCenterFinding` to :attr:`cross_correlation`, :class:`.EllipseMatching&#39; to :attr:`ellipse_matching`,</span>
<span class="sd">    :class:`.LimbMatching` to :attr:`limb_matching`, :class:`.MomentAlgorithm` to :attr:`.moment_algorithm`, and</span>
<span class="sd">    :class:`.UnresolvedCenterFinding` to :attr:`.unresolved`.  Besides storing all of these objects, it handles data</span>
<span class="sd">    transfer and collection between the different objects.  Therefore, in general this class will be the exclusive</span>
<span class="sd">    interface for doing Relative OpNav.</span>

<span class="sd">    For each registered technique, this class provides a few useful capabilities.  First, it creates a property that</span>
<span class="sd">    returns the current instance of the class that implements the technique to make it easy to edit/modify properties.</span>
<span class="sd">    Second, it provides a ``{technique}_estimate`` method which can be used to apply the technique to specific or all</span>
<span class="sd">    image/target pairs.  These ``_estimate`` methods also handle collecting and storing the data from the initialized</span>
<span class="sd">    objects as well as providing the appropriate data to the objects.  Finally, for each registered technique this</span>
<span class="sd">    class provides the opportunity to pass either a pre-initialized instance of the object as a key word argument</span>
<span class="sd">    (using ``{technique}=instance``) or the keyword arguments to use to initialize the instance (using</span>
<span class="sd">    ``{technique}_options=UserOptions``) as part of the ``__init__`` method for this class.</span>

<span class="sd">    This class also provides a simple method for automatically determining which RelNav technique to use based on the</span>
<span class="sd">    expected apparent diameter of a target in the image, as well as the type of the shape representing the target in the</span>
<span class="sd">    scene.  This method, :meth:`auto_estimate` is generally sufficient for use for most missions that are doing typical</span>
<span class="sd">    RelNav type work and really makes doing RelNav easy.</span>

<span class="sd">    For most RelNav types, the results will be collected and stored in the :attr:`center_finding_results`,</span>
<span class="sd">    :attr:`relative_position_results`, :attr:`landmark_results`, :attr:`limb_results` and :attr:`saved_templates`,</span>
<span class="sd">    depending on the type of RelNav used (where each type is stored will be described in the class documentation for the</span>
<span class="sd">    technique).  In addition, each technique can store more details about what occurred in the fit to the</span>
<span class="sd">    ``{technique}_details`` attributes which are lists of lists where the outer list corresponds to the images and the</span>
<span class="sd">    inner lists corresponds to the targets in the scene.  Typically these details are stored as dictionaries with</span>
<span class="sd">    detailed key names to indicate what each value means, but they can technically be any python object.  The</span>
<span class="sd">    documentation for each technique will describe what is included in the details output.</span>

<span class="sd">    When initializing this class, most of the initial options can be set using the ``*_options`` inputs with</span>
<span class="sd">    dictionaries specifying the keyword arguments and values. Alternatively, you can provide already initialized</span>
<span class="sd">    instances of the objects if you want a little more control or want to use a subclass instead of the registered</span>
<span class="sd">    class itself.  You should see the documentation for the registered techniques and the :class:`.ImageProcessing`</span>
<span class="sd">    class for more details about what settings can be specified at initialization.</span>

<span class="sd">    It is possible to register new techniques to use with this class, which will automatically create many of the</span>
<span class="sd">    benefits just discussed.  For details on how to do this, refer to the :mod:`.relnav_class`,</span>
<span class="sd">    :mod:`.relnav_estimators`, and :meth:`register` documentation for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_registered_techniques</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cross_correlation&quot;</span><span class="p">:</span> <span class="n">XCorrCenterFinding</span><span class="p">,</span>
                              <span class="s2">&quot;ellipse_matching&quot;</span><span class="p">:</span> <span class="n">EllipseMatching</span><span class="p">,</span>
                              <span class="s2">&quot;limb_matching&quot;</span><span class="p">:</span> <span class="n">LimbMatching</span><span class="p">,</span>
                              <span class="s2">&quot;moment_algorithm&quot;</span><span class="p">:</span> <span class="n">MomentAlgorithm</span><span class="p">,</span>
                              <span class="s2">&quot;unresolved&quot;</span><span class="p">:</span> <span class="n">UnresolvedCenterFinding</span><span class="p">,</span>
                              <span class="s2">&quot;constraint_matching&quot;</span><span class="p">:</span> <span class="n">ConstraintMatching</span><span class="p">}</span>  <span class="c1"># type: Dict[str, Type[RelNavEstimator]]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This dictionary contains all registered techniques with the RelativeOpNav class.</span>
<span class="sd">    </span>
<span class="sd">    The dictionary maps technique name to the class that implements the techniques, and is updated by the </span>
<span class="sd">    :meth:`register` method/decorator.  A user will not typically interact with this directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_builtins</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cross_correlation&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;ellipse_matching&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;limb_matching&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;moment_algorithm&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;unresolved&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;constraint_matching&quot;</span><span class="p">]</span>  <span class="c1"># type: List[str]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The list contains the built in techniques that are pre-registered with the RelativeOpNav class.  </span>
<span class="sd">    </span>
<span class="sd">    It is included simply to check what has already been initialized so that we don&#39;t duplicate effort in the init </span>
<span class="sd">    method.  While these could all be treated as a typical registered technique, they are handled specially for tab </span>
<span class="sd">    completion and static type checking purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span><span class="p">,</span> <span class="n">extended_body_cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">save_templates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">cross_correlation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">XCorrCenterFinding</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">cross_correlation_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">XCorrCenterFindingOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">unresolved</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">UnresolvedCenterFinding</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">unresolved_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">UnresolvedCenterFindingOptions</span><span class="p">]</span> <span class="o">=</span> <span class="n">UnresolvedCenterFindingOptions</span><span class="p">(),</span>
                 <span class="n">ellipse_matching</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EllipseMatching</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">ellipse_matching_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EllipseMatchingOptions</span><span class="p">]</span> <span class="o">=</span> <span class="n">EllipseMatchingOptions</span><span class="p">(),</span>
                 <span class="n">limb_matching</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LimbMatching</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">limb_matching_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LimbMatchingOptions</span><span class="p">]</span> <span class="o">=</span> <span class="n">LimbMatchingOptions</span><span class="p">(),</span>
                 <span class="n">moment_algorithm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentAlgorithm</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">moment_algorithm_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MomentAlgorithmOptions</span><span class="p">]</span> <span class="o">=</span> <span class="n">MomentAlgorithmOptions</span><span class="p">(),</span>
                 <span class="n">constraint_matching</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ConstraintMatching</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">constraint_matching_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ConstraintMatchingOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">sfn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SurfaceFeatureNavigation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">sfn_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SurfaceFeatureNavigationOptions</span><span class="p">]</span> <span class="o">=</span> <span class="n">SurfaceFeatureNavigationOptions</span><span class="p">(),</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param camera: The :class:`.Camera` containing the camera model and images to be analyzed</span>
<span class="sd">        :param scene: The :class:`.Scene` describing the a priori knowledge of the relative state between the camera and</span>
<span class="sd">                      the targets</span>
<span class="sd">        :param extended_body_cutoff: The apparent diameter threshold in pixels at which :meth:`auto_estimate` will</span>
<span class="sd">                                     switch from using unresolved techniques to using resolved techniques for</span>
<span class="sd">                                     extracting observables from the images.</span>
<span class="sd">        :param save_templates: A flag specifying whether to save the templates generated for cross-correlation based</span>
<span class="sd">                               techniques to the :attr:`saved_templates` attribute.</span>
<span class="sd">        :param cross_correlation: An already initialized instance of :class:`.XCorrCenterFinding` (or a subclass).  If</span>
<span class="sd">                                  not ``None`` then ``cross_correlation_options`` are ignored.</span>
<span class="sd">        :param cross_correlation_options: The options to pass to the :class:`.XCorrCenterFinding` class</span>
<span class="sd">                                         constructor.  These are ignored if argument ``cross_correlation is not ``None``</span>
<span class="sd">        :param unresolved: An already initialized instance of :class:`.UnresolvedCenterFinding` (or a subclass).  If</span>
<span class="sd">                           not ``None`` then ``unresolved_options`` are ignored.</span>
<span class="sd">        :param unresolved_options: The options to pass to the :class:`.UnresolvedCenterFinding` class</span>
<span class="sd">                                  constructor. These are ignored if argument ``unresolved`` is not ``None``</span>
<span class="sd">        :param ellipse_matching: An already initialized instance of :class:`.EllipseMatching` (or a subclass).</span>
<span class="sd">                                 If not ``None`` then ``ellipse_matching_options`` are ignored.</span>
<span class="sd">        :param ellipse_matching_options: The options to pass to the :class:`.EllipseMatching` class</span>
<span class="sd">                                        constructor. These are ignored if argument ``ellipse_matching`` is not ``None``</span>
<span class="sd">        :param limb_matching: An already initialized instance of :class:`.LimbMatching` (or a subclass).  If not</span>
<span class="sd">                              ``None`` then ``limb_matching_options`` are ignored</span>
<span class="sd">        :param limb_matching_options: The options to pass to the :class:`.LimbMatching` class constructor.</span>
<span class="sd">                                     These are ignored if argument ``limb_matching`` is not ``None``.</span>
<span class="sd">        :param moment_algorithm: An already initialized instance of :class:`.MomentAlgorithm` (or a subclass).  If not</span>
<span class="sd">                                 ``None`` then ``moment_algorithm_options`` are ignored.</span>
<span class="sd">        :param moment_algorithm_options: The options to pass to the :class:`.MomentAlgorithm` class</span>
<span class="sd">                                        constructor.  These are ignored if argument ``moment_algorithm`` is not</span>
<span class="sd">                                        ``None``.</span>
<span class="sd">        :param constraint_matching: An already initialized instance of :class:`.ConstraingMatching` (or a subclass).  If</span>
<span class="sd">                                    not ``None`` then ``constraint_matching_kwargs`` are ignored.</span>
<span class="sd">        :param constraint_matching_kwargs: The keyword arguments to pass to the :class:`.ConstraingMatching` class</span>
<span class="sd">                                           constructor. These are ignored if argument ``constraint_matching`` is not</span>
<span class="sd">                                           ``None``.</span>
<span class="sd">        :param sfn: An already initialized instance of :class:`.SurfaceFeatureNavigation` (or a subclass).  If not</span>
<span class="sd">                    ``None`` then ``sfn_options`` are ignored.</span>
<span class="sd">        :param sfn_options: The options to pass to the :class:`.SurfaceFeatureNavigation` class constructor.</span>
<span class="sd">                           These are ignored if argument ``sfn`` is not ``None``.</span>
<span class="sd">        :param kwargs: Extra arguments for other registered RelNav techniques.  These should take the same form as above</span>
<span class="sd">                       (``{technique_name}={technique_instance}`` or ``{technique_name}_options=technique_nameOptions()``).  Any that are</span>
<span class="sd">                       not supplied are defaulted to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make a call to the super class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>

        <span class="c1"># initialize the auto update flag to false.  It will be set with the scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_update</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># set the scene, which also sets the _auto_update attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scene</span> <span class="o">=</span> <span class="n">scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="n">scene</span>

        <span class="c1"># initialize the variables to store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_finding_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)),</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)</span>  <span class="c1"># type: np.ndarray</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This array contains center finding results after a center finding technique is used for each image in the </span>
<span class="sd">        camera.</span>
<span class="sd">        </span>
<span class="sd">        The array is a nxm array with the :attr:`.RESULTS_DTYPE`, where n is the number of images in the camera (all </span>
<span class="sd">        images, not just turned on) and m is the number of targets in the scene.  This is initialized to a zero array.</span>
<span class="sd">        The best way to check if an entry is still empty is that all of the string columns will be 0 length.  If a </span>
<span class="sd">        method fails for a particular image/target, the array will instead be filled with NaN for the predicted column.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">relative_position_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)),</span>
                                                  <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)</span>  <span class="c1"># type: np.ndarray</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This array contains relative position results after a relative position technique is used for each image in the </span>
<span class="sd">        camera.</span>

<span class="sd">        The array is a nxm array with the :attr:`.RESULTS_DTYPE`, where n is the number of images in the camera (all </span>
<span class="sd">        images, not just turned on) and m is the number of targets in the scene.  This is initialized to a zero array.</span>
<span class="sd">        The best way to check if an entry is still empty is that all of the string columns will be 0 length.  If a </span>
<span class="sd">        method fails for a particular image/target, the array will instead be filled with NaN for the predicted column.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">landmark_results</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>  <span class="c1"># type: List[List[NONEARRAY]]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list of lists contains landmark results for each image/target in the scene after a landmark technique is </span>
<span class="sd">        used.</span>

<span class="sd">        The list of lists is nxm, where n is the number of images in the camera (all images, not just turned on) and m </span>
<span class="sd">        is the number of targets in the scene.  Each list element is initialized to ``None`` and is only filled in when </span>
<span class="sd">        a landmark technique is applied to the image/target combination.  The result after a landmark technique has been </span>
<span class="sd">        applied will be a 1D numpy array with dtype :attr:`.RESULTS_DTYPE` with a size equal to the number of processed </span>
<span class="sd">        landmarks in the image/target pair.  Each element can (and likely will) have a different length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matching_results</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>  <span class="c1"># type: List[List[NONEARRAY]]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list of lists contains image constraint results for all images/targets in the scene after an image </span>
<span class="sd">        constraint technique is used.</span>

<span class="sd">        The list of lists is nxm, where n is the number of images in the camera (all images, not just turned on) and m </span>
<span class="sd">        is the number of targets in the scene.  Each list element is initialized to ``None`` and is only filled in when </span>
<span class="sd">        an image constraint technique is applied to the image/target combination.  The result after a image constraint </span>
<span class="sd">        technique has been applied will be a 1D numpy array with dtype :attr:`.RESULTS_DTYPE` with a size equal to the </span>
<span class="sd">        number of matched features in the image to other images. The pairs can be retrieved using the ``landmark id`` </span>
<span class="sd">        column of each element.  The same landmark id indicates the same landmark, even in different images. you can </span>
<span class="sd">        also use the function :func:`.pair_constraints_from_results` which will take in this attribute and return lists</span>
<span class="sd">        with all of the paired observations.  Each element can (and likely will) have a different length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">limb_results</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>  <span class="c1"># type: List[List[NONEARRAY]]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list of lists contains limb results for each image/target in the scene after a limb technique is </span>
<span class="sd">        used.</span>

<span class="sd">        The list of lists is nxm, where n is the number of images in the camera (all images, not just turned on) and m </span>
<span class="sd">        is the number of targets in the scene.  Each list element is initialized to ``None`` and is only filled in when </span>
<span class="sd">        a limb technique is applied to the image/target combination.  The result after a limb technique has been </span>
<span class="sd">        applied will be a 1D numpy array with dtype :attr:`.RESULTS_DTYPE` with a size equal to the number of processed </span>
<span class="sd">        limbs in the image/target pair.  Each element can have a different length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">saved_templates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="kc">None</span> <span class="o">|</span> <span class="n">DOUBLE_ARRAY</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list of lists contains the templates generated by many of the techniques for inspection.</span>
<span class="sd">        </span>
<span class="sd">        The list of lists is nxm, where n is the number of images in the camera (all images, not just turned on) and m </span>
<span class="sd">        is the number of targets in the scene.  Each list element is initialized to ``None`` and is only filled in when</span>
<span class="sd">        a method that generates a template is applied to the image/target pair. Each element is generally stored as </span>
<span class="sd">        either a 2D numpy array containing the template (if doing center finding), or as a list of numpy arrays</span>
<span class="sd">        containing the templates for each landmark (if doing landmark navigation)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_templates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">save_templates</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This flag specifies whether to save rendered templates from techniques that rely on cross-correlation.</span>
<span class="sd">        </span>
<span class="sd">        While it can be nice to have the templates, especially for generating summary displays or trying to investigate </span>
<span class="sd">        whether results are reasonable visually, they can take up a lot of memory, so be sure to consider this before </span>
<span class="sd">        turning this option on.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extended_body_cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">extended_body_cutoff</span><span class="p">)</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The apparent diameter of a target in pixels when we should switch from using unresolved techniques to </span>
<span class="sd">        resolved techniques for center finding.</span>
<span class="sd">        </span>
<span class="sd">        This is only used in :meth:`auto_estimate` and is further described in that documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store the classes that do the hard work</span>

        <span class="c1"># unresolved</span>
        <span class="k">if</span> <span class="n">unresolved</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">unresolved</span> <span class="o">=</span> <span class="n">UnresolvedCenterFinding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">unresolved_options</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_unresolved</span> <span class="o">=</span> <span class="n">unresolved</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unresolved_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.unresolved` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>

<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>

<span class="sd">        If an image/target pair has not been processed by the :mod:`.unresolved` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>

<span class="sd">        For a description of what the provided details include, see the :attr:`.UnresolvedCenterFinding.details` </span>
<span class="sd">        documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># cross correlation</span>
        <span class="k">if</span> <span class="n">cross_correlation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">cross_correlation</span> <span class="o">=</span> <span class="n">XCorrCenterFinding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">cross_correlation_options</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_cross_correlation</span> <span class="o">=</span> <span class="n">cross_correlation</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">cross_correlation_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.cross_correlation` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>

<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>

<span class="sd">        If an image/target pair has not been processed by the :mod:`.cross_correlation` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>

<span class="sd">        For a description of what the provided details include, see the :attr:`.XCorrCenterFinding.details` </span>
<span class="sd">        documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># sfn</span>
        <span class="k">if</span> <span class="n">sfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sfn</span> <span class="o">=</span> <span class="n">SurfaceFeatureNavigation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="n">sfn_options</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_sfn</span> <span class="o">=</span> <span class="n">sfn</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">sfn_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.sfn` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>

<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>

<span class="sd">        If an image/target pair has not been processed by the :mod:`.sfn` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>

<span class="sd">        For a description of what the provided details include, see the :attr:`.SurfaceFeatureNavigation.details` </span>
<span class="sd">        documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># limb matching</span>
        <span class="k">if</span> <span class="n">limb_matching</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_matching</span> <span class="o">=</span> <span class="n">LimbMatching</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">limb_matching_options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_limb_matching</span> <span class="o">=</span> <span class="n">limb_matching</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">limb_matching_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.limb_matching` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>

<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>

<span class="sd">        If an image/target pair has not been processed by the :mod:`.limb_matching` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>

<span class="sd">        For a description of what the provided details include, see the :attr:`.LimbMatching.details` documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ellipse matching</span>
        <span class="k">if</span> <span class="n">ellipse_matching</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ellipse_matching</span> <span class="o">=</span> <span class="n">EllipseMatching</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">ellipse_matching_options</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_ellipse_matching</span> <span class="o">=</span> <span class="n">ellipse_matching</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ellipse_matching_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.ellipse_matching` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>
<span class="sd">        </span>
<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>
<span class="sd">        </span>
<span class="sd">        If an image/target pair has not been processed by the :mod:`.ellipse_matching` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>
<span class="sd">        </span>
<span class="sd">        For a description of what the provided details include, see the :attr:`.EllipseMatching.details` documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># moment algorithm</span>
        <span class="k">if</span> <span class="n">moment_algorithm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">moment_algorithm</span> <span class="o">=</span> <span class="n">MomentAlgorithm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">moment_algorithm_options</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_algorithm</span> <span class="o">=</span> <span class="n">moment_algorithm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moment_algorithm_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.moment_algorithm` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>

<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>

<span class="sd">        If an image/target pair has not been processed by the :mod:`.moment_algorithm` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>

<span class="sd">        For a description of what the provided details include, see the :attr:`.MomentAlgorithm.details` documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># constraint matching</span>
        <span class="k">if</span> <span class="n">constraint_matching</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">constraint_matching</span> <span class="o">=</span> <span class="n">ConstraintMatching</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">constraint_matching_options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_matching</span> <span class="o">=</span> <span class="n">constraint_matching</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matching_details</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This attribute stores details from the :mod:`.constraint_matching` technique for each image/target pair that has </span>
<span class="sd">        been processed.</span>

<span class="sd">        The details are stored as a list of list of object (typically dictionaries) where each element of the outer list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Camera.images` list and each element of the inner list</span>
<span class="sd">        corresponds to the same element number in the :attr:`.Scene.target_objs` list.</span>

<span class="sd">        If an image/target pair has not been processed by the :mod:`.constraint_matching` technique then the corresponding</span>
<span class="sd">        element will still be set to ``None``. </span>

<span class="sd">        For a description of what the provided details include, see the :attr:`.ConstraintMatching.details` </span>
<span class="sd">        documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">technique</span><span class="p">,</span> <span class="n">technique_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registered_techniques</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">technique</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builtins</span><span class="p">:</span>  <span class="c1"># we&#39;ve already dealt with these so skip them</span>
                <span class="k">continue</span>

            <span class="n">internal</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">technique</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">technique</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">technique_options</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">technique</span><span class="o">+</span><span class="s1">&#39;_options&#39;</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">technique_obj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">technique_options</span><span class="p">))</span>

            <span class="c1"># make the details list for this technique</span>
            <span class="n">details</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s1">_details&#39;</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">details</span><span class="p">,</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">))])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scene</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Scene</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This property stores the scene describing the a priori conditions that the camera observed.</span>

<span class="sd">        This is used to communicate both where to expect the target in the image, as well as how to render what we think</span>
<span class="sd">        the target should look like for techniques that use cross correlation.  For more details see the :mod:`.scene`</span>
<span class="sd">        documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scene</span>

    <span class="nd">@scene</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Scene</span><span class="p">):</span>

        <span class="c1"># check to be sure this is a Scne</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Scene</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_scene</span> <span class="o">=</span> <span class="n">val</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_update</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># figure out if any of the objects can be placed automatically</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">target_objs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">position_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">orientation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_auto_update</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;scene must be a Scene or subclass&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cross_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XCorrCenterFinding</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``XCorrCenterFinding`` instance to use when extracting center finding observables from images using</span>
<span class="sd">        cross-correlation.</span>

<span class="sd">        This should be an instance of the :class:`.XCorrCenterFinding` class or a subclass.</span>

<span class="sd">        See the :class:`.XCorrCenterFinding` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cross_correlation</span>

    <span class="nd">@cross_correlation</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cross_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">XCorrCenterFinding</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">XCorrCenterFinding</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The cross_correlation object should probably subclass XCorrCenterFinding.  &quot;</span>
                 <span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the XCorrCenterFinding documentation for &quot;</span>
                 <span class="s2">&quot;details&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cross_correlation</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ellipse_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EllipseMatching</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``EllipseMatching`` instance to use when extracting center finding observables from images using</span>
<span class="sd">        cross-correlation.</span>

<span class="sd">        This should be an instance of the :class:`.EllipseMatching` class or a subclass.</span>

<span class="sd">        See the :class:`.EllipseMatching` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipse_matching</span>

    <span class="nd">@ellipse_matching</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ellipse_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">EllipseMatching</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">EllipseMatching</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The ellipse_matching object should probably subclass EllipseMatching.  &quot;</span>
                 <span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the EllipseMatching documentation for details&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ellipse_matching</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">limb_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LimbMatching</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``LimbMatching`` instance to use when extracting center finding observables from images using</span>
<span class="sd">        cross-correlation.</span>

<span class="sd">        This should be an instance of the :class:`.LimbMatching` class or a subclass.</span>

<span class="sd">        See the :class:`.LimbMatching` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limb_matching</span>

    <span class="nd">@limb_matching</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">limb_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">LimbMatching</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">LimbMatching</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The limb_matching object should probably subclass LimbMatching.  &quot;</span>
                 <span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the LimbMatching documentation for details&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_limb_matching</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">moment_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MomentAlgorithm</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``MomentAlgorithm`` instance to use when extracting center finding observables from images using</span>
<span class="sd">        cross-correlation.</span>

<span class="sd">        This should be an instance of the :class:`.MomentAlgorithm` class or a subclass.</span>

<span class="sd">        See the :class:`.MomentAlgorithm` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_algorithm</span>

    <span class="nd">@moment_algorithm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">moment_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">MomentAlgorithm</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">MomentAlgorithm</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The moment_algorithm object should probably subclass MomentAlgorithm.  &quot;</span>
                 <span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the MomentAlgorithm documentation for details&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_algorithm</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unresolved</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnresolvedCenterFinding</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``UnresolvedCenterFinding`` instance to use when extracting center finding observables from images using</span>
<span class="sd">        cross-correlation.</span>

<span class="sd">        This should be an instance of the :class:`.UnresolvedCenterFinding` class or a subclass.</span>

<span class="sd">        See the :class:`.UnresolvedCenterFinding` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unresolved</span>

    <span class="nd">@unresolved</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unresolved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">UnresolvedCenterFinding</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">UnresolvedCenterFinding</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The unresolved object should probably subclass UnresolvedCenterFinding.  &quot;</span>
                 <span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the UnresolvedCenterFinding documentation for &quot;</span>
                 <span class="s2">&quot;details&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unresolved</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constraint_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstraintMatching</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``ConstraintMatching`` instance to use when extracting constraint observables from images using keypoint</span>
<span class="sd">        matching.</span>

<span class="sd">        This should be an instance of the :class:`.ConstraintMatching` class or a subclass.</span>

<span class="sd">        See the :class:`.ConstraintMatching` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_matching</span>

    <span class="nd">@constraint_matching</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constraint_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ConstraintMatching</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ConstraintMatching</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The constraint_matching object should probably subclass ConstraintMatching.  &quot;</span>
                 <span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the ConstraintMatching documentation for &quot;</span>
                 <span class="s2">&quot;details&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_matching</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="RelativeOpNav.add_images">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.add_images.html#giant.relative_opnav.relnav_class.RelativeOpNav.add_images">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">PATH</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="n">PATH</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">,</span>
                   <span class="n">parse_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">preprocessor</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is essentially an alias to the :meth:`.Camera.add_images` method, but it also expands various lists to</span>
<span class="sd">        account for the new number of images.</span>

<span class="sd">        When you have already initialized a :class:`StellarOpNav` class you should *always* use this method to add</span>
<span class="sd">        images for consideration.</span>

<span class="sd">        The lists that are extended by this method are:</span>

<span class="sd">        * :attr:`center_finding_results`</span>
<span class="sd">        * :attr:`relative_position_results`</span>
<span class="sd">        * :attr:`limb_results`</span>
<span class="sd">        * :attr:`landmark_results`</span>
<span class="sd">        * :attr:`saved_templates`</span>
<span class="sd">        * All ``{technique}_details`` attributes</span>

<span class="sd">        See  :meth:`.Camera.add_images` for a description of the valid input for ``data``</span>

<span class="sd">        :param data:  The image data to be stored in the :attr:`.images` list</span>
<span class="sd">        :param parse_data:  A flag to specify whether to attempt to parse the metadata automatically for the images</span>
<span class="sd">        :param preprocessor: A flag to specify whether to run the preprocessor after loading an image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_images</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">parse_data</span><span class="o">=</span><span class="n">parse_data</span><span class="p">,</span> <span class="n">preprocessor</span><span class="o">=</span><span class="n">preprocessor</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">n_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="k">yield</span> <span class="n">data</span><span class="p">))()</span>
            <span class="n">n_images</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">number_of_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">center_finding_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">center_finding_results</span><span class="p">,</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_images</span><span class="p">,</span> <span class="n">number_of_targets</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_position_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">center_finding_results</span><span class="p">,</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_images</span><span class="p">,</span> <span class="n">number_of_targets</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">limb_results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_targets</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">landmark_results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_targets</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saved_templates</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_targets</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">technique</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registered_techniques</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># update all the details lists</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s1">_details&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_targets</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_technique_name</span><span class="p">(</span><span class="n">worker</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">RelNavEstimator</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method determines the name of the technique from the worker class or an instance of the worker class</span>

<span class="sd">        :raises ValueError: if the technique name is not an identifier</span>

<span class="sd">        :param worker: The worker class or an instance of the worker class</span>
<span class="sd">        :return: the name of the technique</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># figure out the name for this technique by checking the technique class attribute</span>
        <span class="n">technique</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="s1">&#39;technique&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">technique</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if the technique attribute wasn&#39;t set the use the defining module name</span>
            <span class="n">technique</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">technique</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Technique name </span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s1"> is not a valid identifier&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">technique</span>

<div class="viewcode-block" id="RelativeOpNav.register">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.register.html#giant.relative_opnav.relnav_class.RelativeOpNav.register">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">technique_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">RelNavEstimator</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">RelNavEstimator</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class method registers a new RelNav technique with the RelativeOpNav class.</span>

<span class="sd">        This method is intended to be used as a decorator, therefore typical use would look like</span>

<span class="sd">        .. code::</span>

<span class="sd">            @RelativeOpNav.register</span>
<span class="sd">            class MyNewClass(RelNavEstimator):</span>
<span class="sd">                pass</span>

<span class="sd">        When the module containing this code is imported, MyNewClass will be registered with the :class:`RelativeOpNav`</span>
<span class="sd">        class.  It is import to note here that registration must be done before creating an instance of</span>
<span class="sd">        :class:`RelativeOpNav`, so ensure that at some point the module with the new technique is imported.</span>
<span class="sd">        Alternatively you can use this as a standalone function call</span>

<span class="sd">        .. code::</span>

<span class="sd">            RelativeOpNav.register(MyNewClass)</span>

<span class="sd">        before creating an instance of :class:`RelativeOpNav`, but to do this you would have had to import the module</span>
<span class="sd">        containing the new technique anyway so the decorator method would have been fine as well.</span>

<span class="sd">        Registering a technique does a number of things.  First, it creates a new property that returns the instance</span>
<span class="sd">        of the class that defines the technique.  This property will be assigned to either the class attribute</span>
<span class="sd">        ``technique`` of the class representing the new technique, or the defining module of the new technique.</span>

<span class="sd">        Second, the new technique is registered so that one initializing the :class:`.RelativeOpNav` object, you can</span>
<span class="sd">        specify the technique name as a keyword argument to provide a pre-initialized version of the technique class, or</span>
<span class="sd">        you can specify the technique_name followed by _kwargs to specify the key word arguments to pass to the class at</span>
<span class="sd">        initialization.</span>

<span class="sd">        Third, a new method is created called ``{technique}_estimate`` where ``{technique}`` is replaced by the</span>
<span class="sd">        technique name.  This method, like the others named like it, will apply the technique to all images currently</span>
<span class="sd">        turned on in the camera for all targets and store the results.</span>

<span class="sd">        There are a few ways that this registration is controlled.  The first way you can control it is by specifying a</span>
<span class="sd">        name for the new technique as a class attribute of the class that implements the new technique.  This attribute</span>
<span class="sd">        should be called ``technique`` and should be a string.</span>

<span class="sd">        The second control is implemented through the class attribute ``observable_type``.  This attribute controls how</span>
<span class="sd">        the ``{technique}_estimate`` method is built and should be a string, a value from</span>
<span class="sd">        :class:`.RelNavObservablesType`, or a container of those values..  The type chooses how the types will be</span>
<span class="sd">        interpreted for the new technique. There are some common built in types that can be combined together for most</span>
<span class="sd">        RelNav observables (``&#39;CENTER-FINDING&#39;``, ``&#39;LIMB&#39;``, ``&#39;LANDMARK&#39;``, ``&#39;RELATIVE-POSITION&#39;``).  Setting</span>
<span class="sd">        these allows the :class:`.RelativeOpNav` class to automatically handle packaging the results from the</span>
<span class="sd">        estimation, so long as you followed the conventions laid out in the :mod:`.relative_opnav.estimators`</span>
<span class="sd">        documentation.  Alternatively, you can specify this to be ``&#39;CUSTOM&#39;`` (``&#39;CUSTOM&#39;`` cannot be an element in</span>
<span class="sd">        a container, it must be on its own), in which case the estimate method to use can be supplied using the</span>
<span class="sd">        ``relnav_estimator`` class attribute which should point to a function that takes a single argument, the</span>
<span class="sd">        current instance of the :class:`.RelativeOpNav` class.  Typically however, if you have to make a custom</span>
<span class="sd">        estimator method then there is minimal benefit to registering the new technique with the RelNav class.</span>

<span class="sd">        All of this assumes that the class describing the new technique is built according to the template provided by</span>
<span class="sd">        :class:`.RelNavEstimator`.  For more details on building/registering a new technique refer to the</span>
<span class="sd">        :mod:`.relative_opnav.estimators` documentation.  This also assumes that the technique has not already been</span>
<span class="sd">        registered.  If the technique has already been registered either a warning will be printed to screen, or an</span>
<span class="sd">        error raised (if the technique was registered with a different handler class first).</span>

<span class="sd">        :raises ValueError: If the technique name is not a valid identifier</span>
<span class="sd">        :raises ValueError: If the technique has already been registered with a different class</span>
<span class="sd">        :raises ValueError: If a custom type is chosen but the :attr:`~.RelNavEstimator.relnav_estimator` is ``None``</span>

<span class="sd">        .. note::</span>

<span class="sd">            This does not modify the implementation of the RelNav technique class in any way, it modifies the</span>
<span class="sd">            :class:`RelativeOpNav` class itself.  The returned class object will be exactly the same as what was input.</span>

<span class="sd">        :param technique_class: A class representing the new technique to use built according to the outline in</span>
<span class="sd">                                :mod:`.relative_opnav.estimators`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># figure out the name of the technique</span>
        <span class="n">technique</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_resolve_technique_name</span><span class="p">(</span><span class="n">technique_class</span><span class="p">)</span>

        <span class="c1"># set the internal name for the technique by prepending an underscore</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">technique</span>

        <span class="c1"># check if the technique has already been registered and either error or just return</span>
        <span class="k">if</span> <span class="n">technique</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_registered_techniques</span><span class="p">:</span>
            <span class="n">current_class</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_registered_techniques</span><span class="p">[</span><span class="n">technique</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">current_class</span> <span class="ow">is</span> <span class="n">technique_class</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Technique </span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s1"> already registered&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">technique_class</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Technique </span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s1"> already defined with </span><span class="si">{</span><span class="n">current_class</span><span class="si">}</span><span class="s1">. &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;Cannot override registered classes.  Please choose a new name for the &#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39;technique by setting the technique attribute of the new class.&#39;</span><span class="p">)</span>

        <span class="c1"># register the new technique in the class dictionary</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_registered_techniques</span><span class="p">[</span><span class="n">technique</span><span class="p">]</span> <span class="o">=</span> <span class="n">technique_class</span>

        <span class="c1"># define the getter/setter for the technique instance</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">technique_class</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s2"> object should probably subclass </span><span class="si">{</span><span class="n">technique_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.  &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;We&#39;ll assume you know what your doing for now but see the </span><span class="si">{</span><span class="n">technique_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;documentation for details&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="c1"># get the type of relnav this technique implements</span>
        <span class="n">observable_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">technique_class</span><span class="p">,</span> <span class="s1">&#39;observable_type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">observable_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">observable_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observable_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">observable_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="p">(</span><span class="n">observable_type</span><span class="o">.</span><span class="n">upper</span><span class="p">())]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observable_type</span><span class="p">,</span> <span class="n">RelNavObservablesType</span><span class="p">):</span>
            <span class="n">observable_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">observable_type</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">observable_type</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">RelNavObservablesType</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">RelNavObservablesType</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                    <span class="n">observable_type</span><span class="p">))</span>

        <span class="c1"># set the documentation for the property and make the property</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">technique_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instance to use when extracting &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="n">observable_type</span><span class="p">))</span><span class="si">}</span><span class="s2">] observables from images using </span><span class="si">{</span><span class="n">technique</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
               <span class="sa">f</span><span class="s2">&quot;This should be an instance of the </span><span class="si">{</span><span class="n">technique_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> class.  You can edit the class &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;attributes using this property.&quot;</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">technique</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">))</span>


        <span class="c1"># check if this is a custom type, and if so handle it</span>
        <span class="k">if</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CUSTOM</span> <span class="ow">in</span> <span class="n">observable_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">observable_type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;observable_type must only have 1 element if it is CUSTOM&#39;</span><span class="p">)</span>

            <span class="n">custom_handler</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">technique_class</span><span class="p">,</span> <span class="s1">&#39;relnav_handler&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">custom_handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to register technique </span><span class="si">{}</span><span class="s1"> &#39;</span>
                                 <span class="s1">&#39;which needs a custom handler but did not provide one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">technique</span><span class="p">))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">technique</span><span class="o">+</span><span class="s1">&#39;_estimate&#39;</span><span class="p">,</span> <span class="n">custom_handler</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise use the default</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">technique</span><span class="o">+</span><span class="s1">&#39;_estimate&#39;</span><span class="p">,</span> <span class="n">partialmethod</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">observable_type</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">technique_class</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_package_center_finding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span>
                                <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores center finding results in the center finding results attribute from the provider worker.</span>

<span class="sd">        :param worker: The worker that extracted the center finding observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        :param target: The target the observables are of</span>
<span class="sd">        :param image: The image the observables were extracted from</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if this wasn&#39;t processed for this target</span>
        <span class="k">if</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">center_finding_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">,</span>
                                    <span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">worker</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>  <span class="c1"># type: ignore</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>  <span class="c1"># type: ignore</span>
                                                   <span class="s1">&#39;cof&#39;</span><span class="p">,</span>  <span class="c1"># type</span>
                                                   <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span>  <span class="c1"># observation date</span>
                                                   <span class="n">target_ind</span><span class="p">,</span>  <span class="c1"># landmark id</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>  <span class="c1"># target position</span>
                                                   <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> COF&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>  <span class="c1"># target name</span>
                                                   <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># target body</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_package_relative_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span>
                                   <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores relative position results in the relative-position attribute from the provided worker</span>

<span class="sd">        :param worker: The worker that extracted the center finding observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        :param target: The target the observables are of</span>
<span class="sd">        :param image: The image the observables were extracted from</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if this wasn&#39;t processed for this target</span>
        <span class="k">if</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_positions</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">relative_position_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">,</span>
                                       <span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">computed_positions</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>  <span class="c1"># predicted</span>
                                                      <span class="n">worker</span><span class="o">.</span><span class="n">observed_positions</span><span class="p">[</span><span class="n">target_ind</span><span class="p">],</span>  <span class="c1"># measured</span>
                                                      <span class="s1">&#39;pos&#39;</span><span class="p">,</span>  <span class="c1"># type</span>
                                                      <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span>  <span class="c1"># observation date</span>
                                                      <span class="n">target_ind</span><span class="p">,</span>  <span class="c1"># landmark id</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>  <span class="c1"># target position</span>
                                                      <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> COF&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>  <span class="c1"># target name</span>
                                                      <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># target body</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_package_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span>
                       <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores limb results in the limbs attribute from the provided worker</span>

<span class="sd">        :param worker: The worker that extracted the center finding observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        :param target: The target the observables are of</span>
<span class="sd">        :param image: The image the observables were extracted from</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># check if the target was processed</span>
        <span class="k">if</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">limbs_camera</span><span class="p">:</span> <span class="n">NONEARRAY</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="s1">&#39;limbs_camera&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">))[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">limbs_camera</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to package limb observations.  The worker must provide a &#39;</span>
                             <span class="s1">&#39;limbs_camera attribute and fill it out when a target is processed&#39;</span><span class="p">)</span>

        <span class="c1"># store the limb observations for each limb used in the estimation</span>
        <span class="n">limb_obs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pred</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">limb_position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="c1"># type: ignore</span>
                                            <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="c1"># type: ignore</span>
                                            <span class="n">limbs_camera</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">limb_position_body</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">limb_position</span>
            <span class="n">limb_obs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pred</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">obs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="s1">&#39;lim&#39;</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                             <span class="n">limb_position_body</span><span class="p">,</span> <span class="s1">&#39;LIMB</span><span class="si">{:.4g}</span><span class="s1">|</span><span class="si">{:.4g}</span><span class="s1">|</span><span class="si">{:.4g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">limb_position_body</span><span class="p">),</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">limb_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limb_obs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_package_landmarks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span>
                           <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores landmark results in the landmarks attribute from the provided worker</span>

<span class="sd">        :param worker: The worker that extracted the center finding observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        :param target: The target the observables are of</span>
<span class="sd">        :param image: The image the observables were extracted from</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if this wasn&#39;t processed for this target</span>
        <span class="k">if</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># get the identified landmarks list this way to catch if it isn&#39;t defined or wasn&#39;t filled out</span>
        <span class="n">visible_features</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="s1">&#39;visible_features&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">))[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">visible_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to package landmark observations.  The worker must provide a &#39;</span>
                             <span class="s1">&#39;visible_features attribute and must set it to contain a list of &#39;</span>
                             <span class="s1">&#39;identified landmark indices for each processed target&#39;</span><span class="p">)</span>

        <span class="c1"># store the landmark observations for each landmark used in the estimation</span>
        <span class="n">landmark_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">FeatureCatalog</span><span class="p">),</span> <span class="s2">&quot;Target must contain a feature catalog&quot;</span>
        <span class="k">for</span> <span class="n">pred</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">landmark</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="c1"># type: ignore</span>
                                       <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="c1"># type: ignore</span>
                                       <span class="n">visible_features</span><span class="p">):</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">landmark</span><span class="p">]</span>
            <span class="n">landmark_res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pred</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">obs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="s1">&#39;lmk&#39;</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span>
                                 <span class="n">landmark</span><span class="p">,</span> <span class="n">feature</span><span class="o">.</span><span class="n">body_fixed_center</span><span class="p">,</span> <span class="n">feature</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">landmark_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">landmark_res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_package_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span>
                             <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores constraint results in the constraint_matching_results attribute from the provided worker</span>

<span class="sd">        :param worker: The worker that extracted the center finding observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        :param target: The target the observables are of</span>
<span class="sd">        :param image: The image the observables were extracted from</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if this wasn&#39;t processed for this target</span>
        <span class="k">if</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># get the identified constraints list this way to catch if it isn&#39;t defined or wasn&#39;t filled out</span>
        <span class="n">constraint_ids</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="s1">&#39;constraint_ids&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">))[</span><span class="n">target_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">constraint_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to package constraint observations.  The worker must provide a &#39;</span>
                             <span class="s1">&#39;constraint_ids attribute and must set it to contain a list of &#39;</span>
                             <span class="s1">&#39;identified constraint keys for each processed target.&#39;</span><span class="p">)</span>

        <span class="c1"># get the identified constraints list this way to catch if it isn&#39;t defined or wasn&#39;t filled out</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="s1">&#39;constraints&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">))[</span><span class="n">target_ind</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">worker</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">computed_bearings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">constraint_ids</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">computed_bearings</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">computed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="c1"># type: ignore</span>

        <span class="n">constraint_positions</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="s1">&#39;constraint_positions&#39;</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">constraint_ids</span><span class="p">),</span> <span class="mi">3</span><span class="p">))]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">))[</span><span class="n">target_ind</span><span class="p">]</span>

        <span class="c1"># store the constraint observations for each constraint used in the estimation</span>
        <span class="n">constraint_res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">observed_bearings</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">][</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="c1"># type: ignore</span>
                <span class="n">image_dates</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">constraint_id</span> <span class="ow">in</span> <span class="n">constraint_ids</span><span class="p">:</span>
                    <span class="n">image_dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraints</span><span class="p">[</span><span class="n">constraint_id</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">observed_bearings</span> <span class="o">=</span> <span class="n">worker</span><span class="o">.</span><span class="n">observed_bearings</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="c1"># type: ignore</span>
                <span class="n">image_dates</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">constraint_id</span> <span class="ow">in</span> <span class="n">constraint_ids</span><span class="p">:</span>
                    <span class="n">image_dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pred</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">image_date</span><span class="p">,</span> <span class="n">constraint_id</span><span class="p">,</span> <span class="n">constraint_position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">computed_bearings</span><span class="p">,</span>
                                                                                 <span class="n">observed_bearings</span><span class="p">,</span>
                                                                                 <span class="n">image_dates</span><span class="p">,</span>
                                                                                 <span class="n">constraint_ids</span><span class="p">,</span>
                                                                                 <span class="n">constraint_positions</span><span class="p">):</span>
                <span class="n">constraint_res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pred</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">obs</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="s1">&#39;con&#39;</span><span class="p">,</span> <span class="n">image_date</span><span class="p">,</span>
                                       <span class="n">constraint_id</span><span class="p">,</span> <span class="n">constraint_position</span><span class="p">,</span>
                                       <span class="s1">&#39;CONST</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">constraint_id</span><span class="p">),</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_matching_results</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constraint_res</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">RESULTS_DTYPE</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_package_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores center finding results in the center finding results attribute from the provider worker.</span>

<span class="sd">        :param worker: The worker that extracted the observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">worker</span><span class="o">.</span><span class="n">generates_templates</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The worker doesn&#39;t generate templates which are required to package templates&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">saved_templates</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span> <span class="c1"># pyright: ignore[reportCallIssue, reportArgumentType]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_package_details</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This stores the details of the fit retrieved from the :attr:`.RelNavEstimator.details` property of the worker.</span>

<span class="sd">        The details are stored in ``{worker_name}_details`` where ``{worker_name}`` is replaced with the technique name</span>
<span class="sd">        of the worker class.  The details are specific to each technique so see the corresponding documentation.</span>

<span class="sd">        :param worker: The worker that extracted the observables</span>
<span class="sd">        :param image_ind: The index of the image the observables were extracted from</span>
<span class="sd">        :param target_ind: The index of the target the observables are of</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">worker_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_technique_name</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>

        <span class="n">details_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s1">_details&#39;</span><span class="p">)</span> 

        <span class="k">if</span> <span class="n">details_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Somehow we ended up without a list of details for </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">details_list</span><span class="p">[</span><span class="n">image_ind</span><span class="p">][</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">details</span><span class="p">[</span><span class="n">target_ind</span><span class="p">])</span>

<div class="viewcode-block" id="RelativeOpNav.process_image">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.process_image.html#giant.relative_opnav.relnav_class.RelativeOpNav.process_image">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">:</span> <span class="n">RelNavEstimator</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span>
                      <span class="n">observable_type</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RelNavObservablesType</span><span class="p">],</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the default setup for processing an image through a RelNav technique and storing the results for a</span>
<span class="sd">        single image.</span>

<span class="sd">        First, the RelNav technique instance is applied to the image using the :meth:`.RelNavEstimator.estimate` method.</span>
<span class="sd">        Finally, the results from processing the image are stored depending on what types of results were generated by</span>
<span class="sd">        the technique.  This is controlled by the ``observable_type`` input.</span>

<span class="sd">        :param worker: The RelNav technique instance that is to be applied to the image.</span>
<span class="sd">        :param image_ind: The index of the image in the :attr:`.Camera.images` list being processed</span>
<span class="sd">        :param image: The :class:`.OpNavImage` being processed</span>
<span class="sd">        :param observable_type: The type of measurements that are generated by this technique as a list of</span>
<span class="sd">                                :class:`.RelNavObservablesType` values</span>
<span class="sd">        :param include_targets: The targets to process for this image as a list of bools the same length as</span>
<span class="sd">                                :attr:`.Scene.target_objs`.  If ``None`` then all targets are processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract the observables</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">include_targets</span><span class="o">=</span><span class="n">include_targets</span><span class="p">)</span>

        <span class="c1"># store the observables based on what is generated</span>
        <span class="k">for</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">include_targets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">include_targets</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="c1"># the following are independent if statements so multiple can execute</span>
            <span class="k">if</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span> <span class="ow">in</span> <span class="n">observable_type</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_package_center_finding</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">RELATIVE_POSITION</span> <span class="ow">in</span> <span class="n">observable_type</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_package_relative_position</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LIMB</span> <span class="ow">in</span> <span class="n">observable_type</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_package_limbs</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LANDMARK</span> <span class="ow">in</span> <span class="n">observable_type</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_package_landmarks</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CONSTRAINT</span> <span class="ow">in</span> <span class="n">observable_type</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_package_constraints</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_templates</span> <span class="ow">and</span> <span class="n">worker</span><span class="o">.</span><span class="n">generates_templates</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_package_templates</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">)</span>

            <span class="c1"># package the details</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_package_details</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">)</span></div>


<div class="viewcode-block" id="RelativeOpNav.default_estimator">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.default_estimator.html#giant.relative_opnav.relnav_class.RelativeOpNav.default_estimator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">default_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">observable_type</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RelNavObservablesType</span><span class="p">],</span>
                          <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method extracts observables from image(s) using the requested worker and stores them according to the types</span>
<span class="sd">        of observables generated by the technique.</span>

<span class="sd">        This method typically is not called directly by the user but is made public for documentation purposes for</span>
<span class="sd">        registering a new RelNav technique.  Typically, a :func:`.partialmethod`  is created from this method where the</span>
<span class="sd">        2 positional arguments have been filled by the :meth:`register` method.  This partial method is then stored</span>
<span class="sd">        as a method ``{technique}_estimate`` where ``{technique}`` is the name of the technique that is being applied.</span>
<span class="sd">        It is through that method that a user will generally do things.  This resulting partial method will still take 2</span>
<span class="sd">        key word arguments, ``image_ind`` and ``include_targets`` which can be used to apply the technique to a</span>
<span class="sd">        particular image (instead of all of the turned on images) and to control which targets in the scene are</span>
<span class="sd">        processed using this technique.</span>

<span class="sd">        For more details about what is happening internally in this method see the :meth:`process_image` documentation,</span>
<span class="sd">        which is called for each image processed by this method.  For more details about registering a new RelNav</span>
<span class="sd">        technique and using this method to apply it to images, refer to the :mod:`~.relative_opnav.estimators`</span>
<span class="sd">        documentation.</span>

<span class="sd">        :param worker_name: The name of the technique to be applied to the images</span>
<span class="sd">        :param observable_type: The type of observables generated by this technique as a list of</span>
<span class="sd">                                :class:`.RelNavObservablesType` objects.</span>
<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the actual worker</span>
        <span class="n">worker_inst</span><span class="p">:</span> <span class="n">RelNavEstimator</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 

        <span class="c1"># something was wrong with the name</span>
        <span class="k">if</span> <span class="n">worker_inst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No technique </span><span class="si">{}</span><span class="s1"> found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">worker_name</span><span class="p">))</span>

        <span class="n">generator</span><span class="p">,</span> <span class="n">num_images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_generator</span><span class="p">(</span><span class="n">image_ind</span><span class="p">)</span>

        <span class="c1"># process every image we have to</span>
        <span class="n">processed_image</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">-----------------------------------&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processing Image </span><span class="si">{</span><span class="n">processed_image</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">num_images</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_update_scene</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="n">worker_inst</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">observable_type</span><span class="p">,</span> <span class="n">include_targets</span><span class="o">=</span><span class="n">include_targets</span><span class="p">)</span>

            <span class="c1"># call reset to make sure we don&#39;t cross the streams</span>
            <span class="n">worker_inst</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processed image </span><span class="si">{</span><span class="n">processed_image</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">num_images</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">processed_image</span> <span class="o">+=</span> <span class="mi">1</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_scene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This helper method updates the scene if possible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># update the scene if possible</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_update</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="s1">&#39;update&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Somehow we ended up with a scene without an update method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This isn&#39;t an auto scene so we can&#39;t update things, hope you know what you&#39;re doing&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">OpNavImage</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This helper method simply prepares a generator/the number of images in the generator for processing images.</span>

<span class="sd">        If ``image_ind`` is None then this returns the camera object itself, which works as a generator, along with the</span>
<span class="sd">        sum of the :attr:`.Camera.image_mask` attribute as the number of images to process.  If ``image_ind`` is an</span>
<span class="sd">        integer, then this will return a generator that yields on the image requested (plus its index) and 1 as the</span>
<span class="sd">        number of images to process.</span>

<span class="sd">        :param image_ind: The image that is to be processed or ``None`` to process all turned on images in the camera</span>
<span class="sd">        :return: The iterator that yields (image_index, image) pairs and then number of images in that iterable</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">image_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># make a generator expression the returns the image to be processed and its index.</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">single_image_generator</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">image_ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">image_ind</span><span class="p">]</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="n">single_image_generator</span><span class="p">()</span>
            <span class="c1"># set the number of images to be 1</span>
            <span class="n">num_images</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just use the camera itself as the generator</span>
            <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span>
            <span class="c1"># the number of images is the sum of the image mask</span>
            <span class="n">num_images</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">image_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generator</span><span class="p">,</span> <span class="n">num_images</span>

<div class="viewcode-block" id="RelativeOpNav.auto_estimate">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.auto_estimate.html#giant.relative_opnav.relnav_class.RelativeOpNav.auto_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">auto_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method attempts to automatically determine the best RelNav technique to use for each image/target pair</span>
<span class="sd">        considered out of the most common RelNav techniques, :mod:`.unresolved`, :mod:`.ellipse_matching`,</span>
<span class="sd">        :mod:`.cross_correlation`, and :mod:`.sfn`.</span>

<span class="sd">        The decision of which technique to use is made as follows:</span>

<span class="sd">        #. The apparent diameter of the target in pixels in the image under consideration is predicted either using the</span>
<span class="sd">           bounding box for the target or the circumscribing sphere, if available.</span>
<span class="sd">        #. If the predicted apparent diameter of the target is less than the :attr:`extended_body_cutoff` value then the</span>
<span class="sd">           target/image pair is processed using the :mod:`.unresolved` RelNav technique</span>
<span class="sd">        #. If the predicted apparent diameter of the target is greater than the :attr:`extended_body_cutoff` value then</span>
<span class="sd">           the target/image pair is processed based on the type of object it is</span>

<span class="sd">           - If the target is a :class:`.Ellipsoid` then the target is processed using :mod:`.ellipse_matching`</span>
<span class="sd">           - If the target is a :class:`.FeatureCatalog` then the target is processed using :mod:`.sfn`</span>
<span class="sd">           - Otherwise the target is processed using :mod:`.cross_correlation`</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">generator</span><span class="p">,</span> <span class="n">num_images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_generator</span><span class="p">(</span><span class="n">image_ind</span><span class="p">)</span>

        <span class="c1"># initialize a counter for telling the user status</span>
        <span class="n">image_number</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># loop through each image in the camera that is active and process it</span>
        <span class="k">for</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">-----------------------------------&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processing Image </span><span class="si">{</span><span class="n">image_number</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">num_images</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1"># if we can do an auto update, update the scene to the current image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_scene</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

            <span class="c1"># loop through each object in the scene and determine what type of solution to use</span>
            <span class="k">for</span> <span class="n">target_ind</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">):</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">include_targets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_targets</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]:</span>
                    <span class="c1"># don&#39;t process this one if the user told us not to</span>
                    <span class="k">continue</span>

                <span class="n">target_mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">)</span>
                <span class="n">target_mask</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">apparent_diameter</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_apparent_diameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_index</span><span class="p">,</span>
                                                                 <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>

                <span class="c1"># check if this size is less than the extended body cutoff</span>
                <span class="k">if</span> <span class="n">apparent_diameter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_body_cutoff</span><span class="p">:</span>  <span class="c1"># if this is unresolved use unresolved</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unresolved</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">],</span>
                                       <span class="n">include_targets</span><span class="o">=</span><span class="n">target_mask</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_unresolved</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># reset so we don&#39;t pollute other images/targets</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Ellipsoid</span><span class="p">):</span>  <span class="c1"># if this is an ellipsoid use ellipse matching</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ellipse_matching</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
                                       <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">RELATIVE_POSITION</span><span class="p">,</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LIMB</span><span class="p">],</span>
                                       <span class="n">include_targets</span><span class="o">=</span><span class="n">target_mask</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ellipse_matching</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># reset so we don&#39;t pollute other images/targets</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">FeatureCatalog</span><span class="p">):</span>  <span class="c1"># if this is a feature catalog try SFN</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sfn</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">RELATIVE_POSITION</span><span class="p">,</span>
                                                                       <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LANDMARK</span><span class="p">],</span>
                                       <span class="n">include_targets</span><span class="o">=</span><span class="n">target_mask</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sfn</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># reset so we don&#39;t pollute other images/targets</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise, default to cross-correlation for resolved tessellated objects</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cross_correlation</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
                                       <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">],</span>
                                       <span class="n">include_targets</span><span class="o">=</span><span class="n">target_mask</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cross_correlation</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># reset so we don&#39;t pollute other images/targets</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Image </span><span class="si">{</span><span class="n">image_number</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">num_images</span><span class="si">}</span><span class="s1"> done in </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">image_number</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="RelativeOpNav.unresolved_estimate">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.unresolved_estimate.html#giant.relative_opnav.relnav_class.RelativeOpNav.unresolved_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unresolved_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loops applies the :mod:`.unresolved` technique to image/target pairs.</span>

<span class="sd">        This method does nothing to check if it makes sense to apply the unresolved technique to each pair, it just</span>
<span class="sd">        attempts to and if something fails then the results are recorded appropriately.  If you are looking for</span>
<span class="sd">        something that will attempt to automatically choose the right technique to use for each image/target pair, see</span>
<span class="sd">        the :meth:`auto_estimate` method instead.</span>

<span class="sd">        The results from applying the :mod:`.unresolved` technique to each image/target pair are stored in the</span>
<span class="sd">        :attr:`.center_finding_results` attribute.</span>

<span class="sd">        This method dispatches to the :meth:`default_estimator` method which provides more details on what is happening.</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">(</span><span class="s1">&#39;_unresolved&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">],</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">)</span></div>


<div class="viewcode-block" id="RelativeOpNav.cross_correlation_estimate">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.cross_correlation_estimate.html#giant.relative_opnav.relnav_class.RelativeOpNav.cross_correlation_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cross_correlation_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loops applies the :mod:`.cross_correlation` technique to image/target pairs.</span>

<span class="sd">        This method does nothing to check if it makes sense to apply the cross correlation technique to each pair, it</span>
<span class="sd">        just attempts to and if something fails then the results are recorded appropriately.  If you are looking for</span>
<span class="sd">        something that will attempt to automatically choose the right technique to use for each image/target pair, see</span>
<span class="sd">        the :meth:`auto_estimate` method instead.</span>

<span class="sd">        The results from applying the :mod:`.cross_correlation` technique to each image/target pair are stored in the</span>
<span class="sd">        :attr:`center_finding_results` attribute.  If the :attr:`save_templates` is set to true then this will also</span>
<span class="sd">        save the rendered templates the :attr:`saved_templates` attribute.  Finally, this will save fit information for</span>
<span class="sd">        each image/target pair to the :attr:`cross_correlation_details` attribute.</span>

<span class="sd">        This method dispatches to the :meth:`default_estimator` method which provides more details on what is happening.</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">(</span><span class="s1">&#39;_cross_correlation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">],</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">)</span></div>


<div class="viewcode-block" id="RelativeOpNav.ellipse_matching_estimate">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.ellipse_matching_estimate.html#giant.relative_opnav.relnav_class.RelativeOpNav.ellipse_matching_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ellipse_matching_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loops applies the :mod:`.ellipse_matching` technique to image/target pairs.</span>

<span class="sd">        This method does nothing to check if it makes sense to apply the ellipse matching technique to each pair, it</span>
<span class="sd">        just attempts to and if something fails then the results are recorded appropriately.  If you are looking for</span>
<span class="sd">        something that will attempt to automatically choose the right technique to use for each image/target pair, see</span>
<span class="sd">        the :meth:`auto_estimate` method instead.</span>

<span class="sd">        The results from applying the :mod:`.ellipse_matching` technique to each image/target pair are stored in the</span>
<span class="sd">        :attr:`relative_position_results` and :attr:`limb_results` attributes. Finally, this will save fit information</span>
<span class="sd">        for each image/target pair to the :attr:`ellipse_matching_details` attribute.</span>

<span class="sd">        This method dispatches to the :meth:`default_estimator` method which provides more details on what is happening.</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">(</span><span class="s1">&#39;_ellipse_matching&#39;</span><span class="p">,</span>
                               <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">RELATIVE_POSITION</span><span class="p">,</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LIMB</span><span class="p">],</span>
                               <span class="n">image_ind</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">)</span></div>


<div class="viewcode-block" id="RelativeOpNav.limb_matching_estimate">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.limb_matching_estimate.html#giant.relative_opnav.relnav_class.RelativeOpNav.limb_matching_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">limb_matching_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loops applies the :mod:`.limb_matching` technique to image/target pairs.</span>

<span class="sd">        This method does nothing to check if it makes sense to apply the limb matching technique to each pair, it</span>
<span class="sd">        just attempts to and if something fails then the results are recorded appropriately.  If you are looking for</span>
<span class="sd">        something that will attempt to automatically choose the right technique to use for each image/target pair, see</span>
<span class="sd">        the :meth:`auto_estimate` method instead.</span>

<span class="sd">        The results from applying the :mod:`.limb_matching` technique to each image/target pair are stored in the</span>
<span class="sd">        :attr:`relative_position_results` and :attr:`limb_results` attributes. Finally, this will save fit information</span>
<span class="sd">        for each image/target pair to the :attr:`limb_matching_details` attribute.</span>

<span class="sd">        This method dispatches to the :meth:`default_estimator` method which provides more details on what is happening.</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">(</span><span class="s1">&#39;_limb_matching&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">RELATIVE_POSITION</span><span class="p">,</span> <span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">LIMB</span><span class="p">],</span>
                               <span class="n">image_ind</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">)</span></div>


<div class="viewcode-block" id="RelativeOpNav.moment_algorithm_estimate">
<a class="viewcode-back" href="../../../relative_opnav/relnav_class/giant.relative_opnav.relnav_class.RelativeOpNav.moment_algorithm_estimate.html#giant.relative_opnav.relnav_class.RelativeOpNav.moment_algorithm_estimate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">moment_algorithm_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loops applies the :mod:`.moment_algorithm` technique to image/target pairs.</span>

<span class="sd">        This method does nothing to check if it makes sense to apply the moment algorithm technique to each pair, it</span>
<span class="sd">        just attempts to and if something fails then the results are recorded appropriately.  If you are looking for</span>
<span class="sd">        something that will attempt to automatically choose the right technique to use for each image/target pair, see</span>
<span class="sd">        the :meth:`auto_estimate` method instead.</span>

<span class="sd">        The results from applying the :mod:`.moment_algorithm` technique to each image/target pair are stored in the</span>
<span class="sd">        :attr:`relative_position_results` and :attr:`moment_algorithm attributes. Finally, this will save fit</span>
<span class="sd">        information for each image/target pair to the :attr:`moment_algorithm_details` attribute.</span>

<span class="sd">        This method dispatches to the :meth:`default_estimator` method which provides more details on what is happening.</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">(</span><span class="s1">&#39;_moment_algorithm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CENTER_FINDING</span><span class="p">],</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">constraint_matching_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method loops applies the :mod:`.constraint_matching` technique to image/target pairs.</span>

<span class="sd">        This method does nothing to check if it makes sense to apply the constraint matching technique to each pair, it</span>
<span class="sd">        just attempts to and if something fails then the results are recorded appropriately.  If you are looking for</span>
<span class="sd">        something that will attempt to automatically choose the right technique to use for each image/target pair, see</span>
<span class="sd">        the :meth:`auto_estimate` method instead.</span>

<span class="sd">        The results from applying the :mod:`.constraint_matching` technique to each image/target pair are stored in the</span>
<span class="sd">        :attr:`constraint_matching_results` attribute.  If the :attr:`save_templates` is set to true, then this will also</span>
<span class="sd">        save the rendered templates the :attr:`saved_templates` attribute.  Finally, this will save fit information for</span>
<span class="sd">        each image/target pair to the :attr:`constraint_matching` attribute.</span>

<span class="sd">        This method dispatches to the :meth:`default_estimator` method which provides more details on what is happening.</span>

<span class="sd">        :param image_ind: An index specifying which image to process or ``None`` to indicate that all turned on images</span>
<span class="sd">                          should be processed.</span>
<span class="sd">        :param include_targets: A list of booleans specifying which targets in the scene should be processed or ``None``</span>
<span class="sd">                                to indicate that all targets in the scene should be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">default_estimator</span><span class="p">(</span><span class="s1">&#39;_constraint_matching&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">RelNavObservablesType</span><span class="o">.</span><span class="n">CONSTRAINT</span><span class="p">],</span> <span class="n">image_ind</span><span class="p">,</span> <span class="n">include_targets</span><span class="p">)</span></div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>