<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.point_spread_functions.gaussians &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.point_spread_functions.gaussians</h1><div class="highlight"><pre>
<span></span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines PSF subclasses for representing/fitting various forms of 2D Gaussian functions.</span>

<span class="sd">Note that in this module we assume that the resulting illumination profile for a point source as captured by a detector</span>
<span class="sd">is Gaussian, which is not strictly true.  In actuality, if the PSF is well modelled by a Gaussian function then the</span>
<span class="sd">captured profile will be integrals of the portions of the Gaussian contained within each pixel.  These integrals are not</span>
<span class="sd">easily defined which makes fitting much more cumbersome and cost intensive (requiring numeric approximations for the</span>
<span class="sd">Jacobians).  In general, however, particularly for a well sampled PSF (where the FWHM is larger than the</span>
<span class="sd">pixel pitch of the detector), this distinction is negligible, particularly when it comes to estimating the centroid of</span>
<span class="sd">the PSF, which is typically our primary goal.  Providing integrated Gaussian PSFs for extra precise estimation is</span>
<span class="sd">something that is currently under development.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Self</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.psf_meta</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">KernelBasedApply1DPSF</span><span class="p">,</span> <span class="n">KernelBasedCallPSF</span><span class="p">,</span>
                       <span class="n">InitialGuessIterativeNonlinearLSTSQPSF</span><span class="p">,</span> <span class="n">SizedPSF</span><span class="p">,</span>
                       <span class="n">InitialGuessIterativeNonlinearLSTSQPSFwBackground</span><span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_GaussianSkeleton</span><span class="p">(</span><span class="n">KernelBasedApply1DPSF</span><span class="p">,</span> <span class="n">SizedPSF</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This internal class defines common attributes, properties, and methods for Gaussian based PSFs.</span>

<span class="sd">    This should not be used by the user as it is not functional as is.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">centroid_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">sigma_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Gaussian RMS width in the x direction in pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">sigma_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma_x</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="n">sigma_x</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Gaussian RMS width in the y direction in pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">sigma_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma_y</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The amplitude of the Gaussian.</span>

<span class="sd">        This specifies how much energy the Gaussian function increases or decreases the signal by.  </span>

<span class="sd">        Typically this is set so that the kernel does not increase or decrease the signal, which can be achieved by </span>
<span class="sd">        using the :meth:`normalize_amplitude` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">amplitude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">amplitude</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_amplitude</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The x location of the peak of the Gaussian kernel</span>

<span class="sd">        When applying the gaussian kernel, the centroid doesn&#39;t matter as it will always be applied as if it was </span>
<span class="sd">        centered on a pixel.  In general this is just used when estimating a kernel to locate the peak of the PSF in </span>
<span class="sd">        the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">centroid_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">centroid_x</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The y location of the peak of the Gaussian kernel</span>

<span class="sd">        When applying the gaussian kernel, the centroid doesn&#39;t matter as it will always be applied as if it was </span>
<span class="sd">        centered on a pixel.  In general this is just used when estimating a kernel to locate the peak of the PSF in </span>
<span class="sd">        the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">centroid_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">centroid_y</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_residuals</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out the PSF parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">important_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">important_values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;residual&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;covariance&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;centroid&#39;</span> <span class="o">!=</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;size&#39;</span> <span class="o">!=</span> <span class="n">attr</span><span class="p">)):</span>
                <span class="n">important_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                <span class="n">important_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="n">format_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;=</span><span class="si">{}</span><span class="s1">, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">important_vars</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; = </span><span class="si">{}</span><span class="s1">)&#39;</span>

        <span class="k">return</span> <span class="n">format_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">important_values</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 1D array containing residuals of the fit of this Gaussian Model to data.</span>

<span class="sd">        These are only populated when initialized by :meth:`fit` and when the class attribute :attr:`save_residuals`</span>
<span class="sd">        is set to true.</span>
<span class="sd">        </span>
<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then accessing</span>
<span class="sd">        will raise an assertion error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;you have not done a fit so the residuals have not been computed yet.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residuals</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The location of the peak of the Gaussian PSF as a length 2 numpy array (x, y).</span>

<span class="sd">        This is equivalent to ``np.array([psf.centroid_x, psf.centroid_y])`` where ``psf`` is an initialized instance of</span>
<span class="sd">        this class</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span><span class="p">])</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">shift_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the centroid.</span>
<span class="sd">        </span>
<span class="sd">        :param shift: the shift to apply as a len array like x, y </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">shift</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s2">&quot;the applied shift must be a length 2 array&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The mean of the post-fit residuals after fitting this PSF model to data.</span>

<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then this</span>
<span class="sd">        will raise an assertion error</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual_std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The standard deviation of the post-fit residuals after fitting this PSF model to data.</span>
<span class="sd">        </span>
<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then this</span>
<span class="sd">        will raise an assertion error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The sum of squares of the post-fit residuals after fitting this PSF model to data.</span>

<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then this</span>
<span class="sd">        will raise an assertion error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The formal covariance of the PSF parameters after fitting this PSF model to data.</span>

<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then this</span>
<span class="sd">        will raise an assertion error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;you have not performed a fit with this instance&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">apply_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_1d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the defined PSF using the stored parameters to the 1D image scans provided.</span>

<span class="sd">        ``image_1d`` can be a 2D array but in that case each row will be treated as an independent 1D scan.</span>

<span class="sd">        For non-symmetric PSFs, a ``direction`` argument can be supplied which should be the direction in the image of</span>
<span class="sd">        each scan line.  This can be used to determine the appropriate cross-section of the PSF to use for applying to</span>
<span class="sd">        the 1D scans (if applicable).  If no direction is provided then the x direction [1, 0] is assumed.</span>

<span class="sd">        :param image_1d: The scan line(s) to be blurred using the PSF</span>
<span class="sd">        :param direction: The direction for the 1D cross section of the PSF.  This should be either None, a length 2</span>
<span class="sd">                          array, or a shape nx2 array where n is the number of scan lines</span>
<span class="sd">        :param step: The step size of the lines being blurred.</span>
<span class="sd">        :return: an array containing the input after blurring with the defined PSF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># resize so that half the size is evenly divisible by step</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">step</span> <span class="o">*</span> <span class="p">(((</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_1d_sized</span><span class="p">(</span><span class="n">image_1d</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">normalize_amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and store the amplitude that makes the volume under the gaussian surface equal to 1</span>

<span class="sd">        This is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            A = \frac{1}{2\pi\sigma_x\sigma_y}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;sigma_x and sigma_y must be specified to normalize the amplitude&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the volume under the gaussian function</span>

<span class="sd">        This is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            V = 2\pi A\sigma_x\sigma_y}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;sigma_x and sigma_y must be specified to compute the volume&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">determine_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the size for the kernel based on the width of the PSF.</span>

<span class="sd">        This is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            s=\text{floor}(4*\text{max}(\sigma_x, \sigma_y)+0.5))</span>

<span class="sd">        which corresponds roughly to the size required to capture at least 2 sigma of the PSF along its widest axis, or</span>
<span class="sd">        95.45%  of the curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;sigma_x and sigma_y must be specified to determine the 2 sigma size&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># make sure its odd</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">3</span>


<div class="viewcode-block" id="Gaussian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.html#giant.point_spread_functions.Gaussian">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Gaussian</span><span class="p">(</span><span class="n">_GaussianSkeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for representing and fitting a standard (non-rotated) 2D gaussian point spread function.</span>

<span class="sd">    This class represents a 2D Gaussian function of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}</span>

<span class="sd">    where :math:`A` is the :attr:`amplitude` of the PSF, :math:`\sigma_x` is the Gaussian RMS width in the x direction,</span>
<span class="sd">    :math:`\sigma_y` is the Gaussian RMS width in the y direction, and :math:`(x_0,y_0)` is the centroid of the Gaussian</span>
<span class="sd">    (location of the peak response).</span>

<span class="sd">    This class can be used for both estimating a Gaussian fit to an observed PSF (using the :meth:`fit` class method to</span>
<span class="sd">    create an instance) as well as for applying the represented PSF to 1D scan lines (using :meth:`apply_1d`) and 2D</span>
<span class="sd">    images (using the *call* capabilities of an instance of this class).  In addition, if generated from a fit to data,</span>
<span class="sd">    this class will store the residuals and statistics about the residuals of the fit if the class attribute</span>
<span class="sd">    :attr:`save_residuals` is set to True before calling :meth:`fit`.</span>

<span class="sd">    This class can be used anywhere GIANT expects a point spread function.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">amplitude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">centroid_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sigma_x: The Gaussian RMS width in the x direction in pixels</span>
<span class="sd">        :param sigma_y: The Gaussian RMS Width in the y direction in pixels.  If set to 0 or ``None`` this is set to be</span>
<span class="sd">                        the same as ``sigma_x``</span>
<span class="sd">        :param size: The size of the kernel to use when applying this PSF in pixels.  If set to 0 or ``None`` will be</span>
<span class="sd">                     computed based on the Gaussian RSM widths.</span>
<span class="sd">        :param amplitude: The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or ``None``</span>
<span class="sd">                          this will be computed so that the kernel does not increase/decrease the total signal.</span>
<span class="sd">        :param centroid_x: The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        :param centroid_y: The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call the super class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">centroid_x</span><span class="p">,</span> <span class="n">centroid_y</span><span class="o">=</span><span class="n">centroid_y</span><span class="p">,</span>
                         <span class="n">sigma_x</span><span class="o">=</span><span class="n">sigma_x</span><span class="p">,</span> <span class="n">sigma_y</span><span class="o">=</span><span class="n">sigma_y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Gaussian.__call__">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.__call__.html#giant.point_spread_functions.Gaussian.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the represented Gaussian PSF to a 2D array.</span>
<span class="sd">        :param image: The array to apply the PSF to</span>
<span class="sd">        :return: The resulting array after applying the PSF as a numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">,</span> <span class="n">sigmaY</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">)</span></div>


<div class="viewcode-block" id="Gaussian.fit">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.fit.html#giant.point_spread_functions.Gaussian.fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Gaussian&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This fits a 2d gaussian function to a surface using least squares estimation.</span>

<span class="sd">        The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the &quot;height&quot; of the gaussian</span>
<span class="sd">        function).</span>

<span class="sd">        The fit performed is for a 2D gaussian function of the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}</span>

<span class="sd">        The estimation in this function is performed by transforming the gaussian function into the logspace, which</span>
<span class="sd">        allows us to perform a true linear least squares fit without iteration but overweights the tails of the</span>
<span class="sd">        function.  Therefore, it is best to constrain the data you are fitting to be near the peak of the PSF to ensure</span>
<span class="sd">        that too much noise is not being given extra weight in the fit.</span>

<span class="sd">        If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data</span>
<span class="sd">        will be set to np.nan.</span>

<span class="sd">        :param x: The x values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param y: The y values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param z: The z or &quot;height&quot; values of the surface the PSF is to be fit to</span>
<span class="sd">        :return: The initialized PSF with values according to the fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the arrays are flat and numpy arrays</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># form the Jacobian matrix</span>
        <span class="c1"># we are fitting to a model of the form</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># try to generate the least squares solution unless the system is rank deficient</span>

            <span class="c1"># get the solution to the least squares problem</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">sigma_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">sigma_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">solution</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">x0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">y0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sigma_x</span><span class="o">=</span><span class="n">sigma_x</span><span class="p">,</span> <span class="n">sigma_y</span><span class="o">=</span><span class="n">sigma_y</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="o">=</span><span class="n">y0</span><span class="p">)</span>

            <span class="c1"># check for something bad</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sigma_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sigma_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">save_residuals</span><span class="p">:</span>
                <span class="n">computed</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_residuals</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">computed</span>

                <span class="n">jacobian</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">computed</span><span class="p">)</span>

                <span class="c1"># assume a single uncertainty for all measurements</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">jacobian</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">jacobian</span><span class="p">)</span> <span class="o">*</span> <span class="n">out</span><span class="o">.</span><span class="n">residual_std</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">sigma_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">centroid_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Gaussian.compute_jacobian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.compute_jacobian.html#giant.point_spread_functions.Gaussian.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">computed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian of the PSF with respect to a change in the state.</span>

<span class="sd">        It returns a mx5 matrix defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J} = \left[\begin{array}{ccccc} \frac{\partial f}{\partial x_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial y_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial \sigma_x} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial \sigma_y} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial A}\end{array}\right]=\left[\begin{array}{ccccc}</span>
<span class="sd">            \frac{x-x_0}{\sigma_x^2}f(x, y) &amp;</span>
<span class="sd">            \frac{y-y_0}{\sigma_y^2}f(x, y) &amp;</span>
<span class="sd">            \frac{(x-x_0)^2}{\sigma_x^3}f(x, y) &amp;</span>
<span class="sd">            \frac{(y-y_0)^2}{\sigma_y^3}f(x, y) &amp;</span>
<span class="sd">            \frac{f(x, y)}{A}\end{array}\right]</span>

<span class="sd">        :param x: The x values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param y: The y values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param computed: The PSF evaluated at x and y as a length m array</span>
<span class="sd">        :return: The Jacobian matrix as a mx5 numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">3</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">3</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">jacobian</span></div>


<div class="viewcode-block" id="Gaussian.update_state">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.update_state.html#giant.point_spread_functions.Gaussian.update_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">NONEARRAY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the current values based on the provided update vector.</span>

<span class="sd">        The provided update vector is in the order of :math:`[x_0, y_0, \sigma_x, \sigma_y, A]`.</span>

<span class="sd">        If the update vector is set to ``None`` then sets everything to NaN to indicate a bad fit.</span>

<span class="sd">        :param update: The vector of additive updates to apply</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The formal covariance of the PSF parameters after fitting this PSF model to data.</span>

<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then this</span>
<span class="sd">        will raise an assertion error</span>

<span class="sd">        The order of the state vector (and thus the covariance matrix) is :math:`[x_0, y_0, \sigma_x, \sigma_y, A]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;you have not performed a fit with this instance&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span>

<div class="viewcode-block" id="Gaussian.evaluate">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.Gaussian.evaluate.html#giant.point_spread_functions.Gaussian.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method evaluates the PSF at the given x and y.</span>

<span class="sd">        This method is not intended to be used to apply the PSF for an image (use the callable capability of the class</span>
<span class="sd">        instead for this).  Instead it simply computes the height of the PSF above the xy-plane at the requested</span>
<span class="sd">        locations.</span>

<span class="sd">        Specifically, this method computes</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}</span>

<span class="sd">        :param x: The x locations the height of the PSF is to be calculated at.</span>
<span class="sd">        :param y: The y locations the height of the PSF is to be calculated at.</span>
<span class="sd">        :return: A numpy array containing the height of the PSF at the requested locations the same shape as x and y.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ensure things are arrays</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">extras</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extras</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extras</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span>
                                       <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">extras</span></div>
</div>



<div class="viewcode-block" id="IterativeGaussian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussian.html#giant.point_spread_functions.IterativeGaussian">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IterativeGaussian</span><span class="p">(</span><span class="n">Gaussian</span><span class="p">,</span> <span class="n">InitialGuessIterativeNonlinearLSTSQPSF</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for representing and fitting a standard (non-rotated) 2D Gaussian point spread function using iterative</span>
<span class="sd">    non-linear least squares.</span>

<span class="sd">    This class only differs from the :class:`Gaussian` class in the way the :meth:`fit` class method works.  In this</span>
<span class="sd">    version, the fit is performed using iterative non-linear least squares, which is typically more accurate than using</span>
<span class="sd">    the logarithmic transformation to do linear least squares at the expense of more computation time.</span>

<span class="sd">    For more details about the model this works with, see the :class:`Gaussian` documentation.</span>

<span class="sd">    This class can be used anywhere GIANT expects a point spread function</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="IterativeGaussian.fit">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussian.fit.html#giant.point_spread_functions.IterativeGaussian.fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IterativeGaussian&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</span>

<span class="sd">        The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the &quot;height&quot; of the gaussian</span>
<span class="sd">        function).</span>

<span class="sd">        The fit performed is for a 2D gaussian function of the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}</span>

<span class="sd">        The estimation in this function is performed iteratively.  First, a transformed fit is performed using the</span>
<span class="sd">        :meth:`.Gaussian.fit` method.  This initial fit is then refined using iterative non-linear least squares to</span>
<span class="sd">        remove biases that can be introduced in the transformed fit.</span>

<span class="sd">        If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data</span>
<span class="sd">        will be set to np.nan.</span>

<span class="sd">        :param x: The x values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param y: The y values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param z: The z or &quot;height&quot; values of the surface the PSF is to be fit to</span>
<span class="sd">        :return: The initialized PSF with values according to the fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fit_lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="c1"># check if something isn&#39;t right</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="IterativeGaussianWBackground">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussianWBackground.html#giant.point_spread_functions.IterativeGaussianWBackground">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IterativeGaussianWBackground</span><span class="p">(</span><span class="n">Gaussian</span><span class="p">,</span> <span class="n">InitialGuessIterativeNonlinearLSTSQPSFwBackground</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for representing and fitting the superposition of a standard (non-rotated) 2D Gaussian point spread function</span>
<span class="sd">    and a linear background gradiant using iterative non-linear least squares.</span>

<span class="sd">    This class differs from the :class:`Gaussian` class in the way the :meth:`fit` class method works and in the fact</span>
<span class="sd">    that it adds a background gradient to the model.  In this version, the fit is performed using iterative non-linear</span>
<span class="sd">    least squares, which is typically more accurate than using the logarithmic transformation to do linear least squares</span>
<span class="sd">    at the expense of more computation time.</span>

<span class="sd">    The specific model that is fit is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)} + Bx+Cy+D</span>

<span class="sd">    This class can be used anywhere GIANT expects a point spread function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">amplitude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">centroid_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">bg_b_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bg_c_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bg_d_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sigma_x: The Gaussian RMS width in the x direction in pixels</span>
<span class="sd">        :param sigma_y: The Gaussian RMS Width in the y direction in pixels.  If set to 0 or ``None`` this is set to be</span>
<span class="sd">                        the same as ``sigma_x``</span>
<span class="sd">        :param size: The size of the kernel to use when applying this PSF in pixels.  If set to 0 or ``None`` will be</span>
<span class="sd">                     computed based on the Gaussian RSM widths.</span>
<span class="sd">        :param amplitude: The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or ``None``</span>
<span class="sd">                          this will be computed so that the kernel does not increase/decrease the total signal.</span>
<span class="sd">        :param centroid_x: The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        :param centroid_y: The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        :param bg_b_coef: The x slope of the background gradient</span>
<span class="sd">        :param bg_c_coef: They y slope of the background gradient</span>
<span class="sd">        :param bg_d_coef: The constant offset of the background gradient</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sigma_x</span><span class="o">=</span><span class="n">sigma_x</span><span class="p">,</span> <span class="n">sigma_y</span><span class="o">=</span><span class="n">sigma_y</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">centroid_x</span><span class="p">,</span>
                         <span class="n">centroid_y</span><span class="o">=</span><span class="n">centroid_y</span><span class="p">,</span> <span class="n">bg_b_coef</span><span class="o">=</span><span class="n">bg_b_coef</span><span class="p">,</span> <span class="n">bg_c_coef</span><span class="o">=</span><span class="n">bg_c_coef</span><span class="p">,</span> <span class="n">bg_d_coef</span><span class="o">=</span><span class="n">bg_d_coef</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="IterativeGaussianWBackground.fit">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussianWBackground.fit.html#giant.point_spread_functions.IterativeGaussianWBackground.fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IterativeGaussianWBackground&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</span>

<span class="sd">        The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the &quot;height&quot; of the gaussian</span>
<span class="sd">        function).</span>

<span class="sd">        The fit performed is for a 2D gaussian function of the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[\frac{(x-x_0)^2}{2\sigma_x^2}+\frac{(y-y_0)^2}{2\sigma_y^2}\right]\right)}</span>
<span class="sd">            +Bx+Cy+D</span>

<span class="sd">        The estimation in this function is performed iteratively.  First, the rough background is estimated and removed.</span>
<span class="sd">        Then, a transformed fit is performed using the super class&#39;s fit method on the data with the rough background</span>
<span class="sd">        removed.  This initial fit is then refined using iterative non-linear least squares on the original data to</span>
<span class="sd">        remove biases that might have been introduced in the non-iterative fit.</span>

<span class="sd">        If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data</span>
<span class="sd">        will be set to np.nan.</span>

<span class="sd">        :param x: The x values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param y: The y values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param z: The z or &quot;height&quot; values of the surface the PSF is to be fit to</span>
<span class="sd">        :return: The initialized PSF with values according to the fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fit_lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="c1"># check if something isn&#39;t right</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="IterativeGaussianWBackground.update_state">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussianWBackground.update_state.html#giant.point_spread_functions.IterativeGaussianWBackground.update_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">NONEARRAY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the current values based on the provided update vector.</span>

<span class="sd">        The provided update vector is in the order of :math:`[x_0, y_0, \sigma_x, \sigma_y, A, B, C, D]`.</span>

<span class="sd">        If the update vector is set to ``None`` then sets everything to NaN to indicate a bad fit.</span>

<span class="sd">        :param update: The vector of additive updates to apply</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_update_bg</span><span class="p">(</span><span class="n">update</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_update_bg</span><span class="p">(</span><span class="n">update</span><span class="p">)</span></div>


<div class="viewcode-block" id="IterativeGaussianWBackground.compute_jacobian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGaussianWBackground.compute_jacobian.html#giant.point_spread_functions.IterativeGaussianWBackground.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">computed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian of the PSF with respect to a change in the state.</span>

<span class="sd">        It returns a mx8 matrix defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J} = \left[\begin{array}{cccccccc} \frac{\partial f}{\partial x_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial y_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial \sigma_x} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial \sigma_y} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial A} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial B} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial C} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial D}\end{array}\right]=\left[\begin{array}{cccccccc}</span>
<span class="sd">            \frac{x-x_0}{\sigma_x^2}f(x, y) &amp;</span>
<span class="sd">            \frac{y-y_0}{\sigma_y^2}f(x, y) &amp;</span>
<span class="sd">            \frac{(x-x_0)^2}{\sigma_x^3}f(x, y) &amp;</span>
<span class="sd">            \frac{(y-y_0)^2}{\sigma_y^3}f(x, y) &amp;</span>
<span class="sd">            \frac{f(x, y)}{A} &amp;</span>
<span class="sd">            x &amp; y &amp; 1\end{array}\right]</span>

<span class="sd">        :param x: The x values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param y: The y values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param computed: The PSF evaluated at x and y as a length m array</span>
<span class="sd">        :return: The Jacobian matrix as a mx8 numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_jacobian_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">computed</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="GeneralizedGaussian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.html#giant.point_spread_functions.GeneralizedGaussian">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GeneralizedGaussian</span><span class="p">(</span><span class="n">KernelBasedCallPSF</span><span class="p">,</span> <span class="n">_GaussianSkeleton</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for representing and fitting a generalized (rotated) 2D gaussian point spread function.</span>

<span class="sd">    This class represents a 2D Gaussian function of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}</span>

<span class="sd">    where :math:`A` is the :attr:`amplitude` of the PSF, :math:`a` is the coefficient for :math:`(x-x_0)^2`,</span>
<span class="sd">    :math:`c` is the coefficient for :math:`(y-y_0)^2`,  :math:`b` is the coefficient for :math:`(x-x_0)(y-y_0)`, and</span>
<span class="sd">    :math:`(x_0,y_0)` is the centroid of the Gaussian (location of the peak response).</span>

<span class="sd">    This is equivalent to a function of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(x, y) = A e^{-\left[\begin{array}{cc} (x-x_0) &amp; (y-y_0)\end{array}\right]\mathbf{B}\mathbf{S}\mathbf{B}^T</span>
<span class="sd">        \left[\begin{array}{c}(x-x_0) \\ (y-y_0)\end{array}\right]}</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{B} = \left[\begin{array}{cc} \text{cos}(\theta) &amp; -\text{sin}(\theta) \\</span>
<span class="sd">        \text{sin}(\theta) &amp; \text{cos}(\theta)\end{array}\right] \\</span>
<span class="sd">        \mathbf{S} = \left[\begin{array}{cc} \frac{1}{\sigma_x^2} &amp; 0 \\ 0 &amp; \frac{1}{\sigma_y^2}\end{array}\right]</span>

<span class="sd">    :math:`\theta` is the angle between the x-axis and the principal axis of the Gaussian, :math:`sigma_x` is the</span>
<span class="sd">    Gaussian RMS width in the semi-major axis direction, and :math:`\sigma_x` is the  RMS width in the semi-minor axis</span>
<span class="sd">    direction.</span>

<span class="sd">    When creating an instance of this class you can specify either ``a, b, c`` or ``sigma_x, sigma_y, theta`` and the</span>
<span class="sd">    class will convert and store appropriately.  This class also allows you to retrieve either ``a, b, c`` or</span>
<span class="sd">    ``sigma_x, sigma_y, theta``.</span>

<span class="sd">    This class can be used for both estimating a Gaussian fit to an observed PSF (using the :meth:`fit` class method to</span>
<span class="sd">    create an instance) as well as for applying the represented PSF to 1D scan lines (using :meth:`apply_1d) and 2D</span>
<span class="sd">    images (using the *call* capabilities of an instance of this class).  In addition, if generated from a fit to data,</span>
<span class="sd">    this class will store the residuals and statistics about the residuals of the fit if the class attribute</span>
<span class="sd">    :attr:`save_residuals` is set to True before calling :meth:`fit`.</span>

<span class="sd">    This class can be used anywhere GIANT expects a point spread function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">c_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">sigma_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">amplitude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">centroid_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param a_coef: The a coefficient of the Gaussian polynomial</span>
<span class="sd">        :param b_coef: The b coefficient of the Gaussian polynomial</span>
<span class="sd">        :param c_coef: The c coefficient of the Gaussian polynomial</span>
<span class="sd">        :param sigma_x: The Gaussian RMS width in the x direction in pixels</span>
<span class="sd">        :param sigma_y: The Gaussian RMS Width in the y direction in pixels.  If set to 0 or ``None`` this is set to be</span>
<span class="sd">                        the same as ``sigma_x``</span>
<span class="sd">        :param sigma_x: The angle between the x-axis and the principal axis of the Gaussian in radians.</span>
<span class="sd">        :param size: The size of the kernel to use when applying this PSF in pixels.  If set to 0 or ``None`` will be</span>
<span class="sd">                     computed based on the Gaussian RSM widths.</span>
<span class="sd">        :param amplitude: The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or ``None``</span>
<span class="sd">                          this will be computed so that the kernel does not increase/decrease the total signal.</span>
<span class="sd">        :param centroid_x: The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        :param centroid_y: The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">general_check</span> <span class="o">=</span> <span class="n">a_coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b_coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">c_coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">rotated_check</span> <span class="o">=</span> <span class="n">sigma_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sigma_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">general_check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rotated_check</span><span class="p">:</span>
            <span class="c1"># raise ValueError(&#39;One of (a_coef, b_coef, c_coef) or (sigma_x, sigma_y, theta) must be not None&#39;)</span>
            <span class="c1"># we&#39;re probably just trying to blank initialize</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">general_any_check</span> <span class="o">=</span> <span class="n">a_coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b_coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">c_coef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">rotated_any_check</span> <span class="o">=</span> <span class="n">sigma_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sigma_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">general_any_check</span> <span class="ow">and</span> <span class="n">rotated_any_check</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;One of (a_coef, b_coef, c_coef) or (sigma_x, sigma_y, theta) must be not None&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :math:`(x-x_0)^2` coefficient from the exponential component of the generalized 2D Gaussian.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :math:`(x-x_0)(y-y_0)` coefficient from the exponential component of the generalized 2D Gaussian.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :math:`(y-y_0)^2` coefficient from the exponential component of the generalized 2D Gaussian.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The RMS width in the semi-major axis direction.  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The RMS width in the semi-minor axis direction.  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The angle between the semi-major axis and the x axis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">general_check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">=</span> <span class="n">a_coef</span> <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">=</span> <span class="n">b_coef</span> <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">=</span> <span class="n">c_coef</span> <span class="c1"># type: ignore</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_pa</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">rotated_check</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma_x</span><span class="p">)</span> <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma_y</span><span class="p">)</span> <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_general</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sigma_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span><span class="p">,</span> <span class="n">sigma_y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">centroid_x</span><span class="p">,</span>
                         <span class="n">centroid_y</span><span class="o">=</span><span class="n">centroid_y</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_general</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the general coefficients from the principal axis definition.</span>

<span class="sd">        .. math::</span>
<span class="sd">            a = \frac{\text{cos}^2(\theta)}{2\sigma_x^2} + \frac{\text{sin}^2(\theta)}{2\sigma_y^2} \\</span>
<span class="sd">            b = \text{cos}(\theta)\text{sin}(\theta)}\left(\frac{1}{2\sigma_y^2} - \frac{1}{2\sigma_x^2}\right) \\</span>
<span class="sd">            c = \frac{\text{sin}^2(\theta)}{2\sigma_x^2} + \frac{\text{cos}^2(\theta)}{2\sigma_y^2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: not certain why we need to divide by 2 here, but its what the internet says...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_pa</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the principal axis coefficients from the general definition.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \sigma_x = \sqrt{a+c+\sqrt{(a+c)^2-4(ac-b^2)}} \\</span>
<span class="sd">            \sigma_y = \sqrt{a+c-\sqrt{(a+c)^2-4(ac-b^2)}} \\</span>
<span class="sd">            \theta = \text{arctan2}(2*b, \sigma_x^2-2*c)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sig</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">([[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># self.theta = np.arccos(r[0, 0])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># make sure theta is between 0 and 180</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<div class="viewcode-block" id="GeneralizedGaussian.fit">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.fit.html#giant.point_spread_functions.GeneralizedGaussian.fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;GeneralizedGaussian&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This fits a generalized (rotated) 2d gaussian function to a surface using least squares estimation.</span>

<span class="sd">        The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the &quot;height&quot; of the gaussian</span>
<span class="sd">        function).</span>

<span class="sd">        The fit performed is for a generalized 2D gaussian function of the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}</span>

<span class="sd">        The estimation in this function is performed by transforming the gaussian function into the logspace, which</span>
<span class="sd">        allows us to perform a true linear least squares fit without iteration but overweights the tails of the</span>
<span class="sd">        function.  Therefore, it is best to constrain the data you are fitting to be near the peak of the PSF to ensure</span>
<span class="sd">        that too much noise is not being given extra weight in the fit.</span>

<span class="sd">        If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data</span>
<span class="sd">        will be set to np.nan.</span>

<span class="sd">        :param x: The x values underlying the data the gaussian surface is to be fit to</span>
<span class="sd">        :param y: The y values underlying the data the gaussian surface is to be fit to</span>
<span class="sd">        :param z: The z or &quot;height&quot; values for the gaussian surface</span>
<span class="sd">        :return: The initialized PSF with values according to the fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the arrays are flat and numpy arrays</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># form the Jacobian matrix</span>
        <span class="c1"># we are fitting to a model of the form</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># try to generate the least squares solution unless the system is rank deficient</span>

            <span class="c1"># get the solution to the least squares problem</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># extract the meaningful parts from the solution vector</span>
            <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="c1"># y0 = (solution.item(3) * a - 2 * solution.item(1) * b) / (a * c - 4 * b ** 2)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
            <span class="c1"># x0 = (solution.item(1) - 2 * b * y0) / a</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">y0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
            <span class="c1"># amplitude = np.exp(solution.item(5) + a * x0 ** 2 - 2 * b * x0 * y0 + c * y0 ** 2)</span>
            <span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">x0</span><span class="o">*</span><span class="n">y0</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">y0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">a_coef</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b_coef</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c_coef</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="o">=</span><span class="n">y0</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">save_residuals</span><span class="p">:</span>
                <span class="n">computed</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_residuals</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">computed</span>

                <span class="c1"># compute the non-transformed jacobian to the get the formal covariance</span>
                <span class="n">jacobian</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">computed</span><span class="p">)</span>

                <span class="c1"># assume a single uncertainty for all measurements</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">jacobian</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">jacobian</span><span class="p">)</span> <span class="o">*</span> <span class="n">out</span><span class="o">.</span><span class="n">residual_std</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">):</span>  <span class="c1"># if the LHS was singular</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">a_coef</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">b_coef</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">c_coef</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                      <span class="n">centroid_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">centroid_y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">save_residuals</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_residuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">z</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># if we fit a hyperbolic surface then return nans</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="GeneralizedGaussian.compute_jacobian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.compute_jacobian.html#giant.point_spread_functions.GeneralizedGaussian.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">computed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian of the PSF with respect to a change in the state.</span>

<span class="sd">        This is used internally for computing the covariance.  It returns a 5xn matrix defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J} = \left[\begin{array}{cccccc} \frac{\partial f}{\partial x_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial y_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial a} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial b} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial c} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial A} \end{array}\right]=\left[\begin{array}{c}</span>
<span class="sd">            \left(2a(x-x_0)+2b(y-y_0)\right)f(x, y) \\</span>
<span class="sd">            \left(2c(y-y_0)+2b(x-x_0)\right)f(x, y) \\</span>
<span class="sd">            -(x-x_0)^2f(x, y) \\</span>
<span class="sd">            -2(x-x_0)(y-y_0)f(x, y) \\</span>
<span class="sd">            -(y-y_0)^2f(x, y) \\</span>
<span class="sd">            \frac{f(x, y)}{A} \end{array}\right]^T</span>

<span class="sd">        :param x: The x values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param y: The y values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param computed: The PSF evaluated at x and y as a length m array</span>
<span class="sd">        :return: The Jacobian matrix as a 5xm numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">delta_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span>
        <span class="n">delta_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">*</span> <span class="n">delta_x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">*</span> <span class="n">delta_y</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">*</span> <span class="n">delta_y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">*</span> <span class="n">delta_x</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">delta_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delta_x</span> <span class="o">*</span> <span class="n">delta_y</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">delta_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                              <span class="n">computed</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">jacobian</span></div>


<div class="viewcode-block" id="GeneralizedGaussian.update_state">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.update_state.html#giant.point_spread_functions.GeneralizedGaussian.update_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">NONEARRAY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the current values based on the provided update vector.</span>

<span class="sd">        The provided update vector is in the order of :math:`[x_0, y_0, a, b, c, A]`.</span>

<span class="sd">        If the update vector is set to ``None`` then sets everything to NaN to indicate a bad fit.</span>

<span class="sd">        :param update: The vector of additive updates to apply</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">+=</span> <span class="n">update</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The formal covariance of the PSF parameters after fitting this PSF model to data.</span>

<span class="sd">        If this instance is not the result of a fit (:meth:`fit`) or if :attr:`save_residuals` is ``False`` then this</span>
<span class="sd">        will raise an assertion error</span>

<span class="sd">        The order of the state vector (and thus the covariance matrix) is :math:`[x_0, y_0, a, b, c, A]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;you have not performed a fit with this instance&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance</span>

<div class="viewcode-block" id="GeneralizedGaussian.evaluate">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.GeneralizedGaussian.evaluate.html#giant.point_spread_functions.GeneralizedGaussian.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method evaluates the PSF at the given x and y.</span>

<span class="sd">        This method is not intended to be used to apply the PSF for an image (use the callable capability of the class</span>
<span class="sd">        instead for this).  Instead it simply computes the height of the PSF above the xy-plane at the requested</span>
<span class="sd">        locations.</span>

<span class="sd">        Specifically, this method computes</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}</span>



<span class="sd">        :param x: The x locations the height of the PSF is to be calculated at.</span>
<span class="sd">        :param y: The y locations the height of the PSF is to be calculated at.</span>
<span class="sd">        :return: A numpy array containing the height of the PSF at the requested locations the same shape as x and y.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ensure things are arrays</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">delta_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_x</span>
        <span class="n">delta_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_y</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extras</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extras</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">*</span> <span class="n">delta_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">*</span> <span class="n">delta_x</span> <span class="o">*</span> <span class="n">delta_y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_coef</span> <span class="o">*</span> <span class="n">delta_y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">extras</span></div>
</div>



<div class="viewcode-block" id="IterativeGeneralizedGaussian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussian.html#giant.point_spread_functions.IterativeGeneralizedGaussian">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IterativeGeneralizedGaussian</span><span class="p">(</span><span class="n">GeneralizedGaussian</span><span class="p">,</span> <span class="n">InitialGuessIterativeNonlinearLSTSQPSF</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for representing and fitting a generalized (rotated) 2D Gaussian point spread function using iterative</span>
<span class="sd">    non-linear least squares.</span>

<span class="sd">    This class only differs from the :class:`GeneralizedGaussian` class in the way the :meth:`fit` class method works.</span>
<span class="sd">    In this version, the fit is performed using iterative non-linear least squares, which is typically more accurate</span>
<span class="sd">    than using the logarithmic transformation to do linear least squares at the expense of more computation time.</span>

<span class="sd">    For more details about the model this works with, see the :class:`GeneralizedGaussian` documentation.</span>

<span class="sd">    This class can be used anywhere GIANT expects a point spread function</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IterativeGeneralizedGaussian.fit">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussian.fit.html#giant.point_spread_functions.IterativeGeneralizedGaussian.fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</span>

<span class="sd">        The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the &quot;height&quot; of the gaussian</span>
<span class="sd">        function).</span>

<span class="sd">        The fit performed is for a 2D gaussian function of the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}</span>

<span class="sd">        The estimation in this function is performed iteratively.  First, a transformed fit is performed using the</span>
<span class="sd">        :meth:`.Gaussian.fit` method.  This initial fit is then refined using iterative non-linear least squares to</span>
<span class="sd">        remove biases that can be introduced in the transformed fit.</span>

<span class="sd">        If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data</span>
<span class="sd">        will be set to np.nan.</span>

<span class="sd">        :param x: The x values underlying the data the gaussian surface is to be fit to</span>
<span class="sd">        :param y: The y values underlying the data the gaussian surface is to be fit to</span>
<span class="sd">        :param z: The z or &quot;height&quot; values for the gaussian surface</span>
<span class="sd">        :return: The initialized PSF with values according to the fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># do the fit using the default setup from InitialGuessIterativeNonlinearLSTSQPSF</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fit_lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> 

        <span class="c1"># check if something isn&#39;t right</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">a_coef</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">b_coef</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="c1"># finalize things</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_convert_to_pa</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">determine_size</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="IterativeGeneralizedGaussianWBackground">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground.html#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IterativeGeneralizedGaussianWBackground</span><span class="p">(</span><span class="n">GeneralizedGaussian</span><span class="p">,</span> <span class="n">InitialGuessIterativeNonlinearLSTSQPSFwBackground</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for representing and fitting the superposition of a standard (non-rotated) 2D Gaussian point spread function</span>
<span class="sd">    and a linear background gradiant using iterative non-linear least squares.</span>

<span class="sd">    This class differs from the :class:`GeneralizedGaussian` class in the way the :meth:`fit` class method works and in</span>
<span class="sd">    the fact that it adds a background gradient to the model.  In this version, the fit is performed using iterative</span>
<span class="sd">    non-linear least squares, which is typically more accurate than using the logarithmic transformation to do linear</span>
<span class="sd">    least squares at the expense of more computation time.</span>

<span class="sd">    The specific model that is fit is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(x, y) = A e^{\left(-\left[a(x-x_0)^2+b(x-x_0)(y-y_0)+c(y-y_0)^2\right]\right)} + Bx+Cy+D</span>

<span class="sd">    This class can be used anywhere GIANT expects a point spread function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">c_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">sigma_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sigma_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">amplitude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">centroid_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">centroid_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bg_b_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bg_c_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">bg_d_coef</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param a_coef: The a coefficient of the Gaussian polynomial</span>
<span class="sd">        :param b_coef: The b coefficient of the Gaussian polynomial</span>
<span class="sd">        :param c_coef: The c coefficient of the Gaussian polynomial</span>
<span class="sd">        :param sigma_x: The Gaussian RMS width in the x direction in pixels</span>
<span class="sd">        :param sigma_y: The Gaussian RMS Width in the y direction in pixels.  If set to 0 or ``None`` this is set to be</span>
<span class="sd">                        the same as ``sigma_x``</span>
<span class="sd">        :param sigma_x: The angle between the x-axis and the principal axis of the Gaussian in radians.</span>
<span class="sd">        :param size: The size of the kernel to use when applying this PSF in pixels.  If set to 0 or ``None`` will be</span>
<span class="sd">                     computed based on the Gaussian RSM widths.</span>
<span class="sd">        :param amplitude: The amplitude of the gaussian kernel to use when applying this PSF.  If set to 0 or ``None``</span>
<span class="sd">               this will be computed so that the kernel does not increase/decrease the total signal.</span>
<span class="sd">        :param centroid_x: The x location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        :param centroid_y: The y location of the peak of the Gaussian PSF in pixels.  This is not used when applying the</span>
<span class="sd">                           PSF, but it is used when fitting the PSF.  Typically this is not specified by the user.</span>
<span class="sd">        :param bg_b_coef: The x slope of the background gradient</span>
<span class="sd">        :param bg_c_coef: They y slope of the background gradient</span>
<span class="sd">        :param bg_d_coef: The constant offset of the background gradient</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">a_coef</span><span class="o">=</span><span class="n">a_coef</span><span class="p">,</span> <span class="n">b_coef</span><span class="o">=</span><span class="n">b_coef</span><span class="p">,</span> <span class="n">c_coef</span><span class="o">=</span><span class="n">c_coef</span><span class="p">,</span> <span class="n">sigma_x</span><span class="o">=</span><span class="n">sigma_x</span><span class="p">,</span> <span class="n">sigma_y</span><span class="o">=</span><span class="n">sigma_y</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                         <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">centroid_x</span><span class="o">=</span><span class="n">centroid_x</span><span class="p">,</span> <span class="n">centroid_y</span><span class="o">=</span><span class="n">centroid_y</span><span class="p">,</span>
                         <span class="n">bg_b_coef</span><span class="o">=</span><span class="n">bg_b_coef</span><span class="p">,</span> <span class="n">bg_c_coef</span><span class="o">=</span><span class="n">bg_c_coef</span><span class="p">,</span> <span class="n">bg_d_coef</span><span class="o">=</span><span class="n">bg_d_coef</span><span class="p">)</span>

<div class="viewcode-block" id="IterativeGeneralizedGaussianWBackground.fit">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground.fit.html#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.fit">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This fits a 2d gaussian function to a surface using iterative non-linear least squares estimation.</span>

<span class="sd">        The fit assumes that z = f(x, y) where f is the gaussian function (and thus z is the &quot;height&quot; of the gaussian</span>
<span class="sd">        function).</span>

<span class="sd">        The fit performed is for a 2D gaussian function of the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            z = f(x, y) = A e^{\left(-\left[a(x-x_0)^2 + 2b (x-x_0)(y-y_0) + c (y-y_0)^2\right]\right)}</span>
<span class="sd">            +Bx+Cy+D</span>

<span class="sd">        The estimation in this function is performed iteratively.  First, the rough background is estimated and removed.</span>
<span class="sd">        Then, a transformed fit is performed using the super class&#39;s fit method on the data with the rough background</span>
<span class="sd">        removed.  This initial fit is then refined using iterative non-linear least squares on the original data to</span>
<span class="sd">        remove biases that might have been introduced in the non-iterative fit.</span>

<span class="sd">        If the fit is unsuccessful due to a rank deficient matrix or a fit of a hyperbolic surface the resulting data</span>
<span class="sd">        will be set to np.nan.</span>

<span class="sd">        :param x: The x values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param y: The y values underlying the surface the PSF is to be fit to</span>
<span class="sd">        :param z: The z or &quot;height&quot; values of the surface the PSF is to be fit to</span>
<span class="sd">        :return: The initialized PSF with values according to the fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fit_lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="c1"># check if something isn&#39;t right</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="IterativeGeneralizedGaussianWBackground.update_state">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground.update_state.html#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.update_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">NONEARRAY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the current values based on the provided update vector.</span>

<span class="sd">        The provided update vector is in the order of :math:`[x_0, y_0, \sigma_x, \sigma_y, A, B, C, D]`.</span>

<span class="sd">        If the update vector is set to ``None`` then sets everything to NaN to indicate a bad fit.</span>

<span class="sd">        :param update: The vector of additive updates to apply</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_update_bg</span><span class="p">(</span><span class="n">update</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_update_bg</span><span class="p">(</span><span class="n">update</span><span class="p">)</span></div>


<div class="viewcode-block" id="IterativeGeneralizedGaussianWBackground.compute_jacobian">
<a class="viewcode-back" href="../../../point_spread_functions/gaussians/giant.point_spread_functions.gaussians.IterativeGeneralizedGaussianWBackground.compute_jacobian.html#giant.point_spread_functions.IterativeGeneralizedGaussianWBackground.compute_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">computed</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the Jacobian of the PSF with respect to a change in the state.</span>

<span class="sd">        It returns a mx8 matrix defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J} = \left[\begin{array}{cccccccc} \frac{\partial f}{\partial x_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial y_0} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial \sigma_x} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial \sigma_y} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial A} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial B} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial C} &amp;</span>
<span class="sd">            \frac{\partial f}{\partial D}\end{array}\right]=\left[\begin{array}{cccccccc}</span>
<span class="sd">            \frac{x-x_0}{\sigma_x^2}f(x, y) &amp;</span>
<span class="sd">            \frac{y-y_0}{\sigma_y^2}f(x, y) &amp;</span>
<span class="sd">            \frac{(x-x_0)^2}{\sigma_x^3}f(x, y) &amp;</span>
<span class="sd">            \frac{(y-y_0)^2}{\sigma_y^3}f(x, y) &amp;</span>
<span class="sd">            \frac{f(x, y)}{A} &amp;</span>
<span class="sd">            x &amp; y &amp; 1\end{array}\right]</span>

<span class="sd">        :param x: The x values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param y: The y values to evaluate the Jacobian at as a length m array</span>
<span class="sd">        :param computed: The PSF evaluated at x and y as a length m array</span>
<span class="sd">        :return: The Jacobian matrix as a mx8 numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_jacobian_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">computed</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>