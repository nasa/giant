<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.stellar_opnav.star_identification &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.stellar_opnav.star_identification</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides the star identification routines for GIANT through the :class:`StarID` class.</span>

<span class="sd">Algorithm Description</span>
<span class="sd">_____________________</span>

<span class="sd">Star Identification refers to the process of matching observed stars in an image with a corresponding set of known star</span>
<span class="sd">locations from a star catalog. Making this identification is the first step in performing a number of OpNav tasks,</span>
<span class="sd">including attitude estimation, geometric camera calibration, and camera alignment, as well as a number of photometry</span>
<span class="sd">tasks like linearity checks and point spread function modelling.</span>

<span class="sd">In GIANT, star identification is handled using a random sampling and consensus (RANSAC) approach using the following</span>
<span class="sd">steps:</span>

<span class="sd">#. The *a priori* attitude information for each image is used to query the star catalog for the expected stars in the</span>
<span class="sd">   field of view of each image.</span>
<span class="sd">#. The retrieved catalog stars are transformed into the camera frame and projected onto the image using the *a priori*</span>
<span class="sd">   image attitude and camera model.</span>
<span class="sd">#. The projected catalog locations are paired with points in the image that were identified in the image by the image</span>
<span class="sd">   processing algorithm as potential stars using a nearest neighbor approach.</span>
<span class="sd">#. The initial pairs are thresholded based on the distance between the points, as well as for stars that are matched</span>
<span class="sd">   with 2 image points and image points that are close to 2 stars.</span>
<span class="sd">#. The remaining pairs are randomly sampled for 4 star pairs</span>
<span class="sd">#. The sample is used to estimate a new attitude for the image using the :class:`.ESOQ2` routines.</span>
<span class="sd">#. The new solved for attitude is used to re-rotate and project the catalog stars onto the image.</span>
<span class="sd">#. The new projections are compared with their matched image points and the number of inlier pairs (pairs whose distance</span>
<span class="sd">   is less than some ransac threshold) are counted.</span>
<span class="sd">#. The number of inliers is compared to the maximum number of inliers found by any sample to this point (set to 0 if</span>
<span class="sd">   this is the first sample) and:</span>

<span class="sd">   * if there are more inliers</span>

<span class="sd">     * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">     * the inliers for this sample are stored as correctly identified stars</span>
<span class="sd">     * the sum of the squares of the distances between the inlier pairs for this sample is stored</span>

<span class="sd">   * if there are an equivalent number of inliers to the previous maximum number of inliers then the sum of the squares</span>
<span class="sd">     of the distance between the pairs of inliers is compared to the sum of the squares of the previous inliers and if</span>
<span class="sd">     the new sum of squares is less than the old sum of squares</span>

<span class="sd">     * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">     * the inliers are stored as correctly identified stars</span>
<span class="sd">     * the sum of the squares of the distances between the inlier pairs is stored</span>

<span class="sd">#. Steps 5-9 are repeated for a number of iterations, and the final set of stars stored as correctly identified stars</span>
<span class="sd">   become the identified stars for the image.</span>

<span class="sd">It is also possible to skip the RANSAC algorithm, stopping at step 4 above and marking any pairs that remain after the</span>
<span class="sd">check as correctly identified stars.</span>

<span class="sd">.. note::</span>
<span class="sd">    For the above algorithm an *a priori* attitude is needed for each image in which stars are being identified.  While </span>
<span class="sd">    most OpNav images will have an *a priori* attitude, in some cases they may not due to anomalies on the spacecraft.  </span>
<span class="sd">    This is known as the *lost-in-space* problem.  Currently GIANT does not have the ability to handle the lost-in-space</span>
<span class="sd">    problem and the user will first need to use other software to determine an *a priori* attitude for the images (such </span>
<span class="sd">    as `astrometry.net &lt;https://astrometry.net&gt;`_ or `COTS Star Tracker &lt;https://github.com/nasa/COTS-Star-Tracker&gt;)  </span>

<span class="sd">Unfortunately, the star identification routines do require some human input to be successful.  This involves tuning</span>
<span class="sd">various parameters to get a good initial match.  Luckily, once these parameters are tuned for a few images for a</span>
<span class="sd">certain camera set under certain conditions, they largely should apply well to all similar images from that camera.</span>
<span class="sd">Below we discuss the different tuning parameters that are available in the :class:`StarID` class, and also some</span>
<span class="sd">techniques for getting successful identifications.</span>

<span class="sd">Tuning the StarID routines</span>
<span class="sd">__________________________</span>

<span class="sd">There are a few different parameters that can be tuned in the :class:`StarID` class when attempting to get a successful</span>
<span class="sd">star identification for a set of images.  Each of these parameters and what they control are described in the following</span>
<span class="sd">table.</span>

<span class="sd">.. _tuning-parameters-table:</span>

<span class="sd">===================================== ==================================================================================</span>
<span class="sd">Parameter                             Description</span>
<span class="sd">===================================== ==================================================================================</span>
<span class="sd">:attr:`~.StarID.max_magnitude`        The maximum magnitude to query the star catalog to.  This is useful for</span>
<span class="sd">                                      limiting the number of catalog stars that are being matched against.</span>
<span class="sd">                                      Remember that stellar magnitude is on an inverse logarithmic scale, therefore</span>
<span class="sd">                                      the higher you set this number the dimmer stars that will be returned.</span>
<span class="sd">:attr:`~.StarID.min_magnitude`        The minimum magnitude to query the star catalog to.  This is useful for</span>
<span class="sd">                                      limiting the number of catalog stars that are being matched against.</span>
<span class="sd">                                      Remember that stellar magnitude is on an inverse logarithmic scale, therefore</span>
<span class="sd">                                      the lower you set this number the brighter stars that will be returned.</span>
<span class="sd">                                      Typically this should be left alone.</span>
<span class="sd">:attr:`~.StarID.max_combos`           The maximum number of samples to try in the RANSAC algorithm.  The RANSAC</span>
<span class="sd">                                      algorithm will try at most :attr:`~StarID.max_combos` combinations when</span>
<span class="sd">                                      attempting to identify stars. The only way it will try less than</span>
<span class="sd">                                      :attr:`~.StarID.max_combos` is if there are less unique sample combinations</span>
<span class="sd">                                      possible, in which case the RANSAC algorithm will try every possible sample</span>
<span class="sd">                                      (and becomes just a simple Sampling and Consensus algorithm).  This parameter</span>
<span class="sd">                                      is also used to turn off the RANSAC algorithm by setting it to 0.  This stops</span>
<span class="sd">                                      the star identification process at step 4 from above.</span>
<span class="sd">:attr:`~.StarID.tolerance`            The maximum initial distance that a catalog-image poi pair can have for it to be</span>
<span class="sd">                                      considered a potential match in units of pixels. This is the tolerance that is</span>
<span class="sd">                                      applied before the RANSAC to filter out nearest neighbor pairs that are too far</span>
<span class="sd">                                      apart to be potential matches.</span>
<span class="sd">:attr:`~.StarID.ransac_tolerance`     The maximum post-fit distance that a catalog-image poi pair can have for it to</span>
<span class="sd">                                      be considered an inlier in the RANSAC algorithm in units of pixels.  This is</span>
<span class="sd">                                      the tolerance used inside of the RANSAC algorithm to determine the number of</span>
<span class="sd">                                      inliers for a given attitude solution from a sample.  This should always be</span>
<span class="sd">                                      less than the :attr:`~.StarID.tolerance` parameter.</span>
<span class="sd">:attr:`~.StarID.second_closest_check` A flag specifying whether to check if the second closest catalog star to an</span>
<span class="sd">                                      image poi is also within the :attr:`~.StarID.tolerance` distance.  This is</span>
<span class="sd">                                      useful for throwing out potential pairs that may be ambiguous.  In general you</span>
<span class="sd">                                      should set this flag to ``False`` when your initial attitude/camera model error is</span>
<span class="sd">                                      larger, and ``True`` after removing those large errors.</span>
<span class="sd">:attr:`~.StarID.unique_check`         A flag specifying whether to allow a single catalog star to be potentially</span>
<span class="sd">                                      paired with multiple image points of interest.  In general you</span>
<span class="sd">                                      should set this flag to ``False`` when your initial attitude/camera model error is</span>
<span class="sd">                                      larger, and ``True`` after removing those large errors.</span>
<span class="sd">===================================== ==================================================================================</span>

<span class="sd">By tuning these parameters, you should be able to identify stars in nearly any image with an *a priori* attitude that is</span>
<span class="sd">remotely close.  There are a few suggestions that may help you to find the proper tuning faster:</span>

<span class="sd">* Getting the initial identification is generally the most difficult; therefore, you should generally have 2 tunings</span>
<span class="sd">  for an image set.</span>
<span class="sd">* The first tuning should be fairly conservative in order to get a good refined attitude estimate for the image.  </span>
<span class="sd">  (Remember that we really only need 4 or 5 correctly identified stars to get a good attitude estimate.) </span>

<span class="sd">  * a large initial :attr:`~.StarID.tolerance`--greater than 10 pixels.  Note that this initial tolerance should include</span>
<span class="sd">    the errors in the star projections due to both the *a priori* attitude uncertainty and the camera model</span>
<span class="sd">  * a smaller but still relatively large :attr:`~.StarID.ransac_tolerance`--on the order of about 1-5 pixels. This</span>
<span class="sd">    tolerance should mostly reflect a very conservative estimate on the errors caused by the camera model as the</span>
<span class="sd">    attitude errors should largely be removed</span>
<span class="sd">  * a small :attr:`~.StarID.max_magnitude`--only allowing bright stars.  Bright stars generally have more accurate</span>
<span class="sd">    catalog positions and are more likely to be picked up by the :class:`.ImageProcessing` algorithms</span>
<span class="sd">  * the :attr:`~.StarID.max_combos` set fairly large--on the order of 500-1000</span>
<span class="sd">  </span>
<span class="sd">* After getting the initial pairing and updating</span>
<span class="sd">  the attitude for the images (note that this is done external to the :class:`StarID` class), you can then attempt a </span>
<span class="sd">  larger identification with dimmer stars</span>

<span class="sd">  * decreasing the :attr:`~.StarID.tolerance` to be about the same as your previous :attr:`~.StarID.ransac_tolerance`</span>
<span class="sd">  * turning the RANSAC algorithm off by setting the :attr:`~.StarID.max_combos` to 0</span>
<span class="sd">  * increasing the :attr:`~.StarID.max_magnitude`.</span>
<span class="sd">  </span>
<span class="sd">* If you are having problems getting the identification to work it can be useful to visually examine the results for a</span>
<span class="sd">  couple of images using the :func:`.show_id_results` function.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># import random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">cast</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">copy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">spatial</span> <span class="k">as</span> <span class="n">spat</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">comb</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataFrame</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.stellar_opnav.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">ESOQ2</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant</span><span class="w"> </span><span class="kn">import</span> <span class="n">catalogs</span> <span class="k">as</span> <span class="n">cat</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">CameraModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.catalogs.meta_catalog</span><span class="w"> </span><span class="kn">import</span> <span class="n">Catalog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NONEARRAY</span><span class="p">,</span> <span class="n">PATH</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.catalogs.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">RAD2DEG</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.spherical_coordinates</span><span class="w"> </span><span class="kn">import</span> <span class="n">unit_to_radec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.random_combination</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomCombinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNavImage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.options</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.attribute_equality_comparison</span><span class="w"> </span><span class="kn">import</span> <span class="n">AttributeEqualityComparison</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.attribute_printing</span><span class="w"> </span><span class="kn">import</span> <span class="n">AttributePrinting</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.mixin_classes.user_option_configured</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserOptionConfigured</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">DOUBLE_ARRAY</span>


<div class="viewcode-block" id="StarIDOptions">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarIDOptions.html#giant.stellar_opnav.star_identification.StarIDOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StarIDOptions</span><span class="p">(</span><span class="n">UserOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param catalog: The catalog object to use to query for potential stars in an image.</span>
<span class="sd">    :param max_magnitude:  the maximum magnitude to return when querying the star catalog</span>
<span class="sd">    :param min_magnitude:  the minimum magnitude to return when querying the star catalog</span>
<span class="sd">    :param max_combos: The maximum number of random samples to try in the RANSAC routine</span>
<span class="sd">    :param tolerance: The maximum distance between a catalog star and a image point of interest for a potential</span>
<span class="sd">                        pair to be formed before the RANSAC algorithm</span>
<span class="sd">    :param ransac_tolerance: The maximum distance between a catalog star and an image point of interest after</span>
<span class="sd">                                correcting the attitude for a pair to be considered an inlier in the RANSAC algorithm.</span>
<span class="sd">    :param second_closest_check: A flag specifying whether to reject pairs where 2 catalog stars are close to an</span>
<span class="sd">                                    image point of interest</span>
<span class="sd">    :param unique_check: A flag specifying whether to allow a single catalog star to be potentially paired with</span>
<span class="sd">                            multiple image points of interest</span>
<span class="sd">    :param use_mp: A flag specifying whether to use the multi-processing library to accelerate the RANSAC algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">catalog</span><span class="p">:</span> <span class="n">Catalog</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">cat</span><span class="o">.</span><span class="n">Gaia</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The star catalog to use when pairing image points with star locations.</span>
<span class="sd">    </span>
<span class="sd">    This typically should be a subclass of the :class:`.Catalog` class.  It defaults to the </span>
<span class="sd">    :class:`.Gaia`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_magnitude</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">7</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum star magnitude to query from the star catalog.</span>

<span class="sd">    This specifies how dim stars are expected to be in the :attr:`extracted_image_points` data set.  This is </span>
<span class="sd">    typically dependent on both the detector and the exposure length of the image under consideration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">min_magnitude</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The minimum star magnitude to query from the star catalog.</span>
<span class="sd">    </span>
<span class="sd">    This specifies how dim stars are expected to be in the :attr:`extracted_image_points` data set.  This is </span>
<span class="sd">    typically dependent on both the detector and the exposure length of the image under consideration.</span>
<span class="sd">    </span>
<span class="sd">    Generally this should be left alone unless you are worried about over exposed stars (in which case </span>
<span class="sd">    :attr:`.ImageProcessing.reject_saturation` may be more useful) or you are doing some special analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">max_combos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum number of random combinations to try in the RANSAC algorithm.  </span>
<span class="sd">    </span>
<span class="sd">    If the total possible number of combinations is less than this attribute then an exhaustive search will be </span>
<span class="sd">    performed instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
    <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum distance in units of pixels between a projected catalog location and an extracted image point</span>
<span class="sd">    for a possible pairing to be made for consideration in the RANSAC algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">ransac_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The tolerance that is required after correcting for attitude errors for a pair to be considered an inlier</span>
<span class="sd">    in the RANSAC algorithm in units of pixels.</span>
<span class="sd">    </span>
<span class="sd">    This should always be less than the :attr:`tolerance` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># store the second closest check and uniqueness flags</span>
    <span class="n">second_closest_check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A boolean specifying whether to ignore extracted image points where multiple catalog points are within the</span>
<span class="sd">    specified tolerance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">unique_check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A boolean specifying whether to ignore possible catalog to image point pairs where multiple image points are </span>
<span class="sd">    within the specified tolerance of a single catalog point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">use_mp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A boolean flag specifying whether to use multi-processing to speed up the RANSAC process.</span>
<span class="sd">    </span>
<span class="sd">    If this is set to True then all available CPU cores will be utilized to parallelize the RANSAC algorithm </span>
<span class="sd">    computations.  For small combinations, the overhead associated with this can swamp any benefit that may be </span>
<span class="sd">    realized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">compute_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A boolean specifying whether to compute the formal uncertainties for the unit vectors</span>
<span class="sd">                                and the pixel locations of the catalog stars.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="StarID">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.html#giant.stellar_opnav.star_identification.StarID">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StarID</span><span class="p">(</span><span class="n">UserOptionConfigured</span><span class="p">[</span><span class="n">StarIDOptions</span><span class="p">],</span> <span class="n">StarIDOptions</span><span class="p">,</span> <span class="n">AttributePrinting</span><span class="p">,</span> <span class="n">AttributeEqualityComparison</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The StarID class operates on the result of image processing algorithms to attempt to match image points of interest</span>
<span class="sd">    with catalog star records.</span>

<span class="sd">    This is a necessary step in all forms of stellar OpNav and is a critical component of</span>
<span class="sd">    GIANT.</span>

<span class="sd">    In general, the user will not directly interface with the :class:`StarID` class and instead will use the</span>
<span class="sd">    :class:`.StellarOpNav` class.  Below we give a brief description of how to use this class directly for users who</span>
<span class="sd">    are just curious or need more direct control over the class.</span>

<span class="sd">    There are a couple things that the :class:`StarID` class needs to operate.  The first is a camera model, which</span>
<span class="sd">    should be a subclass of :class:`.CameraModel`.  The camera model is used to both project catalog star locations</span>
<span class="sd">    onto the image, as well as generate unit vectors through the image points of interest in the camera frame.  The</span>
<span class="sd">    next thing the :class:`StarID` class needs is a star catalog to query.  This should come from the</span>
<span class="sd">    :mod:`.catalogs` package and provides all of the necessary information for retrieving and projecting the expected</span>
<span class="sd">    stars in an image. Both the star catalog and camera model are generally set at the construction of the class</span>
<span class="sd">    and apply to every image being considered, so they are rarely updated.  The camera model is stored in the</span>
<span class="sd">    :attr:`model` attribute and is also specified as the first positional argument for the class constructor.  The</span>
<span class="sd">    catalog is stored in the :attr:`catalog` attribute and can also be specified in the class constructor as a</span>
<span class="sd">    keyword argument of the same name.</span>

<span class="sd">    The :class:`StarID` class also needs some information about the current image being considered.  This information</span>
<span class="sd">    includes points of interest for the image that need to be matched to stars, the *a priori* attitude of the image,</span>
<span class="sd">    and the position/velocity of the camera at the time the image was captured.  The points of interest are generally</span>
<span class="sd">    returned from the :class:`.PointOfInterestFinder` routines, although they don&#39;t need to be.  The camera attitude,</span>
<span class="sd">    position, velocity, and a priori orientation are generally passed from the :class:`.OpNavImage` metadata.  The </span>
<span class="sd">    a priori image attitude is used for querying the catalog and rotating the catalog stars into the image frame.  </span>
<span class="sd">    The camera positions and velocity are used for correcting the star locations for parallax and stellar aberration. </span>
<span class="sd">    The camera position and velocity are not required but are generally recommended as they will give a more accurate </span>
<span class="sd">    representation.  </span>
<span class="sd">     </span>
<span class="sd">    Finally, there are a number of tuning parameters that need set.  These parameters are discussed in depth in the</span>
<span class="sd">    :ref:`Tuning Parameters Table &lt;tuning-parameters-table&gt;`.</span>

<span class="sd">    When everything is correctly set in an instance of :class:`StarID`, then generally all that needs to be called</span>
<span class="sd">    is the :meth:`id_stars` method, which accepts the observation date of the image being considered as an</span>
<span class="sd">    optional ``epoch`` keyword argument.  This method will go through the whole processed detailed above, storing the</span>
<span class="sd">    results in a number of attributes that are detailed below.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StarIDOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param model: The camera model to use to relate vectors in the camera frame with points on the image</span>
<span class="sd">        :param options: StarIDOptions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">StarIDOptions</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># initialize temporary attributes to make multiprocessing easier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalog_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span> <span class="o">=</span> <span class="n">ESOQ2</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">:</span> <span class="n">CameraModel</span> <span class="o">=</span> <span class="n">model</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The camera model which relates points in the camera frame to points in the image and vice-versa.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the attributes for storing the star identification results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn numpy array of points containing the projected image points for all catalog stars that were queried from </span>
<span class="sd">        the star catalog  with x (columns) in the first row and y (rows) in the second row.  </span>
<span class="sd">        </span>
<span class="sd">        Each column corresponds to the same row in :attr:`queried_catalog_star_records`.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`project_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas DataFrame of all the catalog star records that were queried.  </span>

<span class="sd">        See the :class:`.Catalog` class for a description of the columns of the dataframe.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`project_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 3xn numpy array of unit vectors in the inertial frame for all catalog stars that were queried from </span>
<span class="sd">        the star catalog.  </span>
<span class="sd">        </span>
<span class="sd">        Each column corresponds to the same row in :attr:`queried_catalog_star_records`.</span>

<span class="sd">        Until :meth:`project_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each unit vector from the queried catalog stars.  </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`queried_catalog_star_records`.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each projected pixel location from the queried catalog stars in</span>
<span class="sd">        units of pixels..  </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`queried_catalog_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_image_points</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn numpy array of points containing the projected image points for all catalog stars that not matched</span>
<span class="sd">        with an extracted image point, with x (columns) in the first row and y (rows) in the second row.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`unmatched_catalog_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_star_records</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas DataFrame of all the catalog star records that were not matched to an extracted image point in the </span>
<span class="sd">        star identification routine.  </span>

<span class="sd">        See the :class:`.Catalog` class for a description of the columns of the dataframe.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_unit_vectors</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 3xn numpy array of unit vectors in the inertial frame for all catalog stars that were not matched to an</span>
<span class="sd">        extracted image point in the star identification routine.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`matched_catalog_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn array of the image points of interest that were not paired with a catalog star in the star </span>
<span class="sd">        identification routine.</span>

<span class="sd">        The first row corresponds to the x locations (columns) and the second row corresponds to the y locations (rows).</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each unit vector from the queried catalog stars</span>
<span class="sd">        that were not matched with an extracted image point.  </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`unmatched_catalog_star_records`.</span>

<span class="sd">        Until method :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each projected pixel location from the queried catalog stars </span>
<span class="sd">        that were not matched with an extracted image point in units of pixels. </span>
<span class="sd">        </span>
<span class="sd">        Each element in this array corresponds to the same row in the :attr:`unmatched_catalog_star_records`.</span>

<span class="sd">        Until method :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_image_points</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn numpy array of points containing the projected image points for all catalog stars that were matched</span>
<span class="sd">        with an extracted image point, with x (columns) in the first row and y (rows) in the second row.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`matched_catalog_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_star_records</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas DataFrame of all the catalog star records that were matched to an extracted image point in the </span>
<span class="sd">        star identification routine.  </span>

<span class="sd">        See the :class:`.Catalog` class for a description of the columns of the dataframe.</span>
<span class="sd">        </span>
<span class="sd">        Each row of the dataframe corresponds to the same column index in the :attr:`matched_extracted_image_points`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_unit_vectors</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 3xn numpy array of unit vectors in the inertial frame for all catalog stars that were matched to an</span>
<span class="sd">        extracted image point in the star identification routine.  </span>

<span class="sd">        Each column corresponds to the same row in :attr:`matched_catalog_star_records`.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2xn array of the image points of interest that were not paired with a catalog star in the star </span>
<span class="sd">        identification routine.</span>

<span class="sd">        The first row contains to the x locations (columns) and the second row contains to the y locations (rows).</span>
<span class="sd">        </span>
<span class="sd">        Each column corresponds to the same row in the :attr:`matched_catalog_star_records` for its pairing.</span>

<span class="sd">        Until :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each unit vector from the queried catalog stars</span>
<span class="sd">        that were matched with an extracted image point.  </span>

<span class="sd">        Each element in this array corresponds to the same row in the :attr:`matched_catalog_star_records`.</span>

<span class="sd">        Until methods :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the formal total uncertainty for each projected pixel location from the queried catalog stars </span>
<span class="sd">        that were matched with an extracted image point in units of pixels. </span>

<span class="sd">        Each element in this array corresponds to the same row in the :attr:`matched_catalog_star_records`.</span>

<span class="sd">        Until method :meth:`id_stars` is called this will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="StarID.query_catalog">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.query_catalog.html#giant.stellar_opnav.star_identification.StarID.query_catalog">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">query_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method queries stars from the catalog within the field of view.</span>

<span class="sd">        The stars are queried such that any stars within 1.3*the :attr:`.CameraModel.field_of_view` value radial</span>
<span class="sd">        distance of the camera frame z axis converted to right ascension and declination are returned between</span>
<span class="sd">        :attr:`min_magnitude` and :attr:`max_magnitude`.  The queried stars are updated to the </span>
<span class="sd">        ``image.observation_date`` value using proper motion.  They are stored in the </span>
<span class="sd">        :attr:`queried_catalog_star_records` attribute. The stars are stored as a pandas DataFrame.  For </span>
<span class="sd">        more information about this format see the :class:`.Catalog` class documentation.</span>

<span class="sd">        In general, this method does not need to be directly called by the user as it is automatically called in the</span>
<span class="sd">        :meth:`project_stars` method.</span>

<span class="sd">        :param image: The image to querry the catalog for (specifying the time and the a priori pointing)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the ra and dec of the camera frame z axis</span>
        <span class="n">ra_dec_cat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_pointing</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>

        <span class="c1"># query the catalog and store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">query_catalog</span><span class="p">(</span>
            <span class="n">search_center</span><span class="o">=</span><span class="n">ra_dec_cat</span><span class="p">,</span>
            <span class="n">search_radius</span><span class="o">=</span><span class="mf">1.3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">field_of_view</span><span class="p">,</span>
            <span class="n">min_mag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_magnitude</span><span class="p">,</span>
            <span class="n">max_mag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_magnitude</span><span class="p">,</span>
            <span class="n">new_epoch</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="StarID.compute_pointing">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.compute_pointing.html#giant.stellar_opnav.star_identification.StarID.compute_pointing">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pointing</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the right ascension and declination of an axis of the camera frame in units of degrees.</span>

<span class="sd">        The pointing is computed by extracting the camera frame z axis expressed in the inertial frame from the</span>
<span class="sd">        :attr:`a_priori_rotation_cat2camera` and then converting that axis to a right ascension and declination.</span>
<span class="sd">        The conversion to right ascension and declination is given as</span>

<span class="sd">        .. math::</span>
<span class="sd">            ra=\text{atan2}(\mathbf{c}_{yI}, \mathbf{c}_{xI})\\</span>
<span class="sd">            dec=\text{asin}(\mathbf{c}_{zI})</span>

<span class="sd">        where atan2 is the quadrant aware arc tangent function, asin is the arc sin and :math:`\mathbf{c}_{jI}` is the</span>
<span class="sd">        :math:`j^{th}` component of the camera frame axis expressed in the Inertial frame.</span>

<span class="sd">        In general this method is not used by the user as it is automatically called in the :meth:`query_catalog`</span>
<span class="sd">        method.</span>

<span class="sd">        :return:  The right ascension and declination of the specified axis in the inertial frame as a tuple (ra, dec)</span>
<span class="sd">                  in units of degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">boresight_cat</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">unit_to_radec</span><span class="p">(</span><span class="n">boresight_cat</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">RAD2DEG</span> <span class="o">*</span> <span class="n">ra</span><span class="p">,</span> <span class="n">RAD2DEG</span> <span class="o">*</span> <span class="n">dec</span></div>


<div class="viewcode-block" id="StarID.project_stars">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.project_stars.html#giant.stellar_opnav.star_identification.StarID.project_stars">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_stars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method queries the star catalog for predicted stars within the field of view and projects those stars</span>
<span class="sd">        onto the image using the camera model.</span>

<span class="sd">        The star catalog is queried using the :meth:`query_catalog` method and the stars are updated to the epoch</span>
<span class="sd">        specified by ``image.observation_date`` using the proper motion from the catalog.  The queried Pandas </span>
<span class="sd">        Dataframe containing the star catalog records is stored in the :attr:`queried_catalog_star_records` attribute.</span>

<span class="sd">        After the stars are queried from the catalog, they are converted to inertial unit vectors and corrected for</span>
<span class="sd">        stellar aberration and parallax using the :attr:`.position` and :attr:`camera_velocity` values.  The</span>
<span class="sd">        corrected inertial vectors are stored in the :attr:`queried_catalog_unit_vectors`.</span>

<span class="sd">        Finally, the unit vectors are rotated into the camera frame using the :attr:`a_priori_rotation_cat2camera`</span>
<span class="sd">        attribute, and then projected onto the image using the :attr:`model` attribute.  The projected points are stored</span>
<span class="sd">        in the :attr:`queried_catalog_image_points` attribute.</span>

<span class="sd">        If requested, the formal uncertainties for the catalog unit vectors and pixel locations are computed and</span>
<span class="sd">        stored in the :attr:`queried_weights_inertial` and :attr:`queried_weights_picture`.  These are computed by</span>
<span class="sd">        transforming the formal uncertainty on the right ascension, declination, and proper motion specified in the</span>
<span class="sd">        star catalog into the proper frame.</span>

<span class="sd">        In general this method is not called directly by the user and instead is called in the :meth:`id_stars` method.</span>

<span class="sd">        :param epoch: The epoch to get the star locations for</span>
<span class="sd">        :param compute_weights: A boolean specifying whether to compute the formal uncertainties for the unit vectors</span>
<span class="sd">                                and the pixel locations of the catalog stars.</span>
<span class="sd">        :param temperature: The temperature of the camera at the time of the image being processed</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># # query the star catalog for predicted stars in the field of view</span>
        <span class="c1"># make a temporary OpNavImage.</span>
        <span class="c1"># TODO: probably we should rework this class to just operate on an OpNavImage</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="p">,</span> 
         <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span><span class="p">,</span> 
         <span class="n">catalog_unit_vectors_camera</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_stars_directions_and_pixels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> 
                                                                                           <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> 
                                                                                           <span class="bp">self</span><span class="o">.</span><span class="n">max_magnitude</span><span class="p">,</span> 
                                                                                           <span class="n">min_mag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_magnitude</span><span class="p">,</span> 
                                                                                           <span class="n">image_number</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_weights</span><span class="p">:</span>
            <span class="c1"># compute the covariance of the inertial catalog unit vectors</span>
            <span class="n">dec_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="p">[</span><span class="s1">&#39;dec&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
            <span class="n">ra_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
            <span class="n">cos_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec_rad</span><span class="p">)</span>
            <span class="n">cos_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ra_rad</span><span class="p">)</span>
            <span class="n">sin_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dec_rad</span><span class="p">)</span>
            <span class="n">sin_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ra_rad</span><span class="p">)</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cos_d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">dv_da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">cos_d</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">cos_d</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">zero</span><span class="p">])</span>
            <span class="n">dv_dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">sin_d</span> <span class="o">*</span> <span class="n">cos_a</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_d</span> <span class="o">*</span> <span class="n">sin_a</span><span class="p">,</span> <span class="n">cos_d</span><span class="p">])</span>

            <span class="n">cov_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;jik&#39;</span><span class="p">,</span> <span class="n">dv_da</span><span class="p">,</span> <span class="n">dv_da</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span>
                     <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="p">[</span><span class="s1">&#39;ra_sigma&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span> <span class="o">/</span> <span class="n">cos_d</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;jik&#39;</span><span class="p">,</span> <span class="n">dv_dd</span><span class="p">,</span> <span class="n">dv_dd</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="p">[</span><span class="s1">&#39;dec_sigma&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">RAD2DEG</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># compute the covariance of the projected catalog points</span>
            <span class="n">rot2camera</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span>
            <span class="n">cov_xc</span> <span class="o">=</span> <span class="n">rot2camera</span> <span class="o">@</span> <span class="n">cov_v</span> <span class="o">@</span> <span class="n">rot2camera</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compute_pixel_jacobian</span><span class="p">(</span><span class="n">catalog_unit_vectors_camera</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span>
                                                   <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>
            <span class="n">cov_xp</span> <span class="o">=</span> <span class="n">pj</span> <span class="o">@</span> <span class="n">cov_xc</span> <span class="o">@</span> <span class="n">pj</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">cov_v</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">cov_xp</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="StarID.id_stars">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.id_stars.html#giant.stellar_opnav.star_identification.StarID.id_stars">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">id_stars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">extracted_image_points</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> 
                 <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method attempts to match the image points of interest with catalog stars.</span>

<span class="sd">        The :meth:`id_stars` method is the primary interface of the :class:`StarID` class.  It performs all the tasks of</span>
<span class="sd">        querying the star catalog, performing the initial pairing using a nearest neighbor search, refining the</span>
<span class="sd">        initial pairings with the :attr:`second_closest_check` and :attr:`unique_check`, and passing the refined</span>
<span class="sd">        pairings to the RANSAC routines.  The matched and unmatched catalog stars and image points of interest are</span>
<span class="sd">        stored in the appropriate attributes.</span>

<span class="sd">        This method also returns a boolean index in the image points of interest vector, which extracts the image points</span>
<span class="sd">        that met the initial match criterion, and another boolean index into the image points of interest which</span>
<span class="sd">        extracts the image points of interest that were matched by the RANSAC algorithms.  This can be used to select</span>
<span class="sd">        the appropriate meta data about catalog stars or stars found in an image that isn&#39;t explicitly considered by</span>
<span class="sd">        this class (as is done in the :class:`.StellarOpNav` class), but if you do not have extra information you need</span>
<span class="sd">        to keep in sync, then you can ignore the output.</span>

<span class="sd">        If requested, the formal uncertainties for the catalog unit vectors and pixel locations are computed and</span>
<span class="sd">        stored in the :attr:`queried_weights_inertial` and :attr:`queried_weights_picture`.  These are computed by</span>
<span class="sd">        transforming the formal uncertainty on the right ascension, declination, and proper motion specified in the</span>
<span class="sd">        star catalog into the proper frame.</span>

<span class="sd">        :param image: The image being processed</span>
<span class="sd">        :param extracted_image_points: a 2xN array of image pixel locations (x first row, y second row) that are potential stars</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        :return: The boolean index into the image points that met the original pairing criterion, and a second boolean</span>
<span class="sd">                 index into the the result from the previous boolean index that extracts the image points that were</span>
<span class="sd">                 successfully matched in the RANSAC algorithms.  If no stars are identified then returns a tuple of None, None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first get the unit vectors and image locations for the stars in the field of view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_stars</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image_number</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

        <span class="c1"># create a kdtree of the catalog image locations for faster searching</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Need to have querried the catalog stors at this point&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Need to have querried the catalog stors at this point&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Need to have querried the catalog stors at this point&quot;</span>
        <span class="n">catalog_image_locations_kdtree</span> <span class="o">=</span> <span class="n">spat</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># query the kdtree to get the 2 closest catalog image locations to each image point of interest</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">extracted_image_points</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="n">catalog_image_locations_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="c1"># for type hinting</span>

        <span class="c1"># check to see which pairs are less than the user specified matching tolerance</span>
        <span class="n">dist_check</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c1"># throw out pairs where multiple catalog locations are &lt; the tolerance to the image points of interest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_closest_check</span><span class="p">:</span>
            <span class="n">dist_check</span> <span class="o">&amp;=</span> <span class="n">distance</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="n">keep_stars</span> <span class="o">=</span> <span class="n">dist_check</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># throw out points that are matched twice</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_check</span><span class="p">:</span>
            <span class="n">keep_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">kin</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]):</span>
                <span class="n">keep_unique</span><span class="p">[</span><span class="n">kin</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">inds</span><span class="p">[</span><span class="n">dist_check</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">keep_stars</span> <span class="o">&amp;=</span> <span class="n">keep_unique</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_stars</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span> <span class="o">=</span> <span class="n">extracted_image_points</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># either return our current matches or further filter using ransac if desired</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_unit_vectors</span><span class="p">,</span> <span class="n">keep_inliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ransac</span><span class="p">(</span>
                <span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">keep_stars</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image_number</span><span class="o">=</span><span class="n">image_number</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">keep_inliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if none of the stars met the ransac criteria then throw everything out</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no stars found for epoch </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_star_records</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_image_points</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_weights</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># update the matched catalog star records and image points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
                    <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][</span><span class="n">keep_inliers</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="p">[</span>
                                                      <span class="p">:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][:,</span> <span class="n">keep_inliers</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_weights</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][</span><span class="n">keep_inliers</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][</span><span class="n">keep_inliers</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set the matches in the proper places</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span> <span class="o">=</span> <span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">keep_stars</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_catalog_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_weights</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

            <span class="n">keep_inliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># use python set notation to determine the list of stars and image points that were never matched</span>
        <span class="k">if</span> <span class="n">keep_inliers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># get the stars that weren&#39;t matched</span>
            <span class="n">unmatched_inds</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">{</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span> <span class="o">-</span>
                                                      <span class="p">{</span><span class="o">*</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="n">keep_inliers</span><span class="p">])}))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="p">[:,</span> <span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span><span class="p">[:,</span> <span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_weights</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="p">[</span><span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="p">[</span><span class="n">unmatched_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># get the points of interest that weren&#39;t matched</span>
            <span class="n">camera_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">extracted_image_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">unmatched_centroid_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="o">*</span><span class="n">camera_inds</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="o">*</span><span class="n">camera_inds</span><span class="p">[</span><span class="n">keep_stars</span><span class="p">][</span><span class="n">keep_inliers</span><span class="p">]})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span> <span class="o">=</span> <span class="n">extracted_image_points</span><span class="p">[:,</span> <span class="n">unmatched_centroid_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># nothing was matched</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span> <span class="o">=</span> <span class="n">extracted_image_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_star_records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_star_records</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_unit_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_unit_vectors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_catalog_image_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_catalog_image_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_weights</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Weights shouldn&#39;t be None at this point&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_inertial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_inertial</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_weights_picture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queried_weights_picture</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">keep_stars</span><span class="p">,</span> <span class="n">keep_inliers</span></div>


<div class="viewcode-block" id="StarID.ransac">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.ransac.html#giant.stellar_opnav.star_identification.StarID.ransac">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ransac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_locs</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">catalog_dirs</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span>
               <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs RANSAC on the image poi-catalog location pairs.</span>

<span class="sd">        The RANSAC algorithm is described below</span>

<span class="sd">        #. The pairs are randomly sampled for 4 star pairs</span>
<span class="sd">        #. The sample is used to estimate a new attitude for the image using the :class:`.ESOQ2` routines.</span>
<span class="sd">        #. The new solved for attitude is used to re-rotate and project the catalog stars onto the image.</span>
<span class="sd">        #. The new projections are compared with their matched image points and the number of inlier pairs (pairs whose</span>
<span class="sd">           distance is less than some ransac threshold) are counted.</span>
<span class="sd">        #. The number of inliers is compared to the maximum number of inliers found by any sample to this point (set to</span>
<span class="sd">           0 if this is the first sample) and:</span>

<span class="sd">           * if there are more inliers</span>

<span class="sd">             * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">             * the inliers for this sample are stored as correctly identified stars</span>
<span class="sd">             * the sum of the squares of the distances between the inlier pairs for this sample is stored</span>

<span class="sd">           * if there are an equivalent number of inliers to the previous maximum number of inliers then the sum of the</span>
<span class="sd">             squares of the distance between the pairs of inliers is compared to the sum of the squares of the previous</span>
<span class="sd">             inliers and if the new sum of squares is less than the old sum of squares</span>

<span class="sd">             * the maximum number of inliers is set to the number of inliers generated for this sample</span>
<span class="sd">             * the inliers are stored as correctly identified stars</span>
<span class="sd">             * the sum of the squares of the distances between the inlier pairs is stored</span>

<span class="sd">        #. Steps 1-5 are repeated for a number of iterations, and the final set of stars stored as correctly identified</span>
<span class="sd">           stars become the identified stars for the image.</span>

<span class="sd">        In order to use this method, the ``image_locs`` input and the ``catalog_dirs`` input should represent the</span>
<span class="sd">        initial pairings between the image points found using image processing and the predicted catalog star unit</span>
<span class="sd">        vectors in the inertial frame. The columns in these 2 arrays should represent the matched pairs (that is column</span>
<span class="sd">        10 of ``image_locs`` should correspond to column 10 in ``catalog_dirs``).</span>

<span class="sd">        This method returns the paired image locations and catalog directions from the best RANSAC iteration</span>
<span class="sd">        and the boolean index into the input arrays that extract these values.</span>

<span class="sd">        In general this method is not used directly by the user and instead is called as part of the :meth:`id_stars`</span>
<span class="sd">        method.</span>

<span class="sd">        :param image_locs:  The image points of interest that met the initial matching criteria as a 2xn array</span>
<span class="sd">        :param catalog_dirs:  The catalog inertial unit vectors that met the initial matching criteria in the same</span>
<span class="sd">                                order as the ``image_locs`` input as a 3xn array.</span>
<span class="sd">        :param temperature: The temperature of the camera at the time of the image being processed</span>
<span class="sd">        :param image_number: The number of the image being processed</span>
<span class="sd">        :return: The matched image points of interest, the matched catalog unit vectors, and the boolean index that</span>
<span class="sd">                 represents these arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the maximum number of inliers and minimum sum of squares variables.</span>
        <span class="n">max_inliers</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_rs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ransac_tolerance</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># get the maximum number of combinations that are available to sample</span>
        <span class="n">n_comb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>

        <span class="c1"># convert the image points of interest to unit vectors in the camera frame</span>
        <span class="n">image_dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="n">image_locs</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="o">=</span> <span class="n">image_locs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="o">=</span> <span class="n">image_dirs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalog_dirs</span> <span class="o">=</span> <span class="n">catalog_dirs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span> <span class="o">=</span> <span class="n">image_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">RandomCombinations</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                          <span class="nb">min</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                                                          <span class="nb">min</span><span class="p">(</span><span class="n">n_comb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span><span class="p">)))</span>

        <span class="c1"># perform the ransac</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n_comb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_combos</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mp</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ransac_iter_test</span><span class="p">,</span> <span class="n">iters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ransac_iter_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">]</span>

        <span class="c1"># initialize the return values in case the RANSAC fails</span>
        <span class="n">keep_image_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">keep_catalog_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">keep_inliers</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># find the best iteration and keep it</span>
        <span class="k">for</span> <span class="n">num_inliers</span><span class="p">,</span> <span class="n">filtered_image_locs</span><span class="p">,</span> <span class="n">filtered_catalog_dirs</span><span class="p">,</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">rs</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>

            <span class="c1"># check to see if this is the best ransac iteration yet</span>
            <span class="k">if</span> <span class="n">num_inliers</span> <span class="o">&gt;</span> <span class="n">max_inliers</span><span class="p">:</span>

                <span class="n">max_inliers</span> <span class="o">=</span> <span class="n">num_inliers</span>

                <span class="n">keep_image_locs</span> <span class="o">=</span> <span class="n">filtered_image_locs</span>

                <span class="n">keep_catalog_dirs</span> <span class="o">=</span> <span class="n">filtered_catalog_dirs</span>

                <span class="n">keep_inliers</span> <span class="o">=</span> <span class="n">inliers</span>

                <span class="k">assert</span> <span class="n">rs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">max_rs</span> <span class="o">=</span> <span class="n">rs</span>

            <span class="k">elif</span> <span class="n">num_inliers</span> <span class="o">==</span> <span class="n">max_inliers</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">rs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> 
                <span class="k">if</span> <span class="n">rs</span> <span class="o">&lt;</span> <span class="n">max_rs</span><span class="p">:</span>
                    <span class="n">max_inliers</span> <span class="o">=</span> <span class="n">num_inliers</span>

                    <span class="n">keep_image_locs</span> <span class="o">=</span> <span class="n">filtered_image_locs</span>

                    <span class="n">keep_catalog_dirs</span> <span class="o">=</span> <span class="n">filtered_catalog_dirs</span>

                    <span class="n">keep_inliers</span> <span class="o">=</span> <span class="n">inliers</span>

                    <span class="n">max_rs</span> <span class="o">=</span> <span class="n">rs</span>

        <span class="c1"># clear out the temp data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalog_dirs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># return the matched results and the boolean index</span>
        <span class="k">return</span> <span class="n">keep_image_locs</span><span class="p">,</span> <span class="n">keep_catalog_dirs</span><span class="p">,</span> <span class="n">keep_inliers</span> <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="StarID.ransac_iter_test">
<a class="viewcode-back" href="../../../stellar_opnav/star_identification/giant.stellar_opnav.star_identification.StarID.ransac_iter_test.html#giant.stellar_opnav.star_identification.StarID.ransac_iter_test">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ransac_iter_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iter_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> 
                                                       <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> 
                                                       <span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> 
                                                       <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> 
                                                       <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This performs a single ransac iteration.</span>

<span class="sd">        See the :meth:`ransac` method for more details.</span>

<span class="sd">        :param iter_num: the iteration number for retrieving the combination to try</span>
<span class="sd">        :return: the number of inliers for this iteration, the image location inliers for this iteration, the</span>
<span class="sd">                 catalog direction inliers for this iteration, the boolean index for the inliers for this iteration,</span>
<span class="sd">                 and the sum of the squares of the residuals for this iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalog_dirs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">image_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_locs</span>
        <span class="n">image_dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_dirs</span>
        <span class="n">catalog_dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_catalog_dirs</span>

        <span class="c1"># get a random combination of indices into the image_locs and catalog_dirs arrays</span>
        <span class="c1"># inds = random_combination(image_locs.shape[1], min(image_locs.shape[1] - 1, 4))</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_combinations</span><span class="p">[</span><span class="n">iter_num</span><span class="p">]</span>

        <span class="c1"># extract the image directions to use for this ransac iteration</span>
        <span class="n">image_dirs_use</span> <span class="o">=</span> <span class="n">image_dirs</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>

        <span class="c1"># extract the catalog directions ot use for this ransac iteration</span>
        <span class="n">catalog_dirs_use</span> <span class="o">=</span> <span class="n">catalog_dirs</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span>

        <span class="c1"># estimate an updated attitude</span>
        <span class="n">new_rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_att_est</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">image_dirs_use</span><span class="p">,</span> <span class="n">catalog_dirs_use</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span>

        <span class="c1"># rotate the catalog directions into the camera frame and project them onto the image using the new</span>
        <span class="c1"># attitude</span>
        <span class="n">catalog_dirs_cam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">new_rot</span><span class="p">,</span> <span class="n">catalog_dirs</span><span class="p">)</span>

        <span class="n">catalog_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">catalog_dirs_cam</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_temperature</span><span class="p">,</span>
                                                       <span class="n">image</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_image_number</span><span class="p">)</span>

        <span class="c1"># compute the residual distance in all of the pairs</span>
        <span class="n">resids</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">catalog_locs</span> <span class="o">-</span> <span class="n">image_locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># check to see which pairs meet the ransac tolerance</span>
        <span class="n">inliers</span> <span class="o">=</span> <span class="n">resids</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ransac_tolerance</span>

        <span class="c1"># get the sum of the squares of the residuals</span>
        <span class="n">rs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resids</span><span class="p">[</span><span class="n">inliers</span><span class="p">]</span> <span class="o">*</span> <span class="n">resids</span><span class="p">[</span><span class="n">inliers</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inliers</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">inliers</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">image_locs</span><span class="p">[:,</span> <span class="n">inliers</span><span class="p">],</span> <span class="n">catalog_dirs</span><span class="p">[:,</span> <span class="n">inliers</span><span class="p">],</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">rs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>