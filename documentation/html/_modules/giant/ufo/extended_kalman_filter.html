<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.ufo.extended_kalman_filter &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.ufo.extended_kalman_filter</h1><div class="highlight"><pre>
<span></span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines an Extended Kalman Filter (EKF) to be used for tracking of non-cooperative targets as part of the</span>
<span class="sd">:mod:`.ufo` package.</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">An EKF is a filter which linearizes both measurements and the dynamics about the current best estimate of the state to</span>
<span class="sd">estimate updates to the state based on ingested measurements.  It is powerful and fast, but can occasionally be finicky</span>
<span class="sd">when you have bad a priori conditions and the measurement/state are very non-linear.  There are many great resources on</span>
<span class="sd">EKFs and how they work available therefore we don&#39;t go into details here.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">This module defines a single class, :class:`.ExtendedKalmanFilter`, which implements the EKF.  Generally you won&#39;t</span>
<span class="sd">interact with this class directly and instead will interact with the :class:`.EKFTracker` class from the</span>
<span class="sd">:mod:`.ekf_tracker` module.  If you need more details on using this class directly refer to the following class</span>
<span class="sd">documentation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">uuid</span><span class="w"> </span><span class="kn">import</span> <span class="n">uuid4</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span><span class="p">,</span> <span class="n">copy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ufo.dynamics</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dynamics</span><span class="p">,</span> <span class="n">PN_TYPE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ufo.measurements</span><span class="w"> </span><span class="kn">import</span> <span class="n">Measurement</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">F_SCALAR_OR_ARRAY</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>


<span class="c1"># TODO: provide a Monte filter interface at some point</span>


<span class="n">_LOGGER</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is the logging interface for reporting status, results, issues, and other information.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">STATE_INITIALIZER_TYPE</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Measurement</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">]],</span> <span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This defines the callable sequent for state initializer functions.</span>

<span class="sd">See :attr:`.state_initializer` for more details.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_negate_pn</span><span class="p">(</span><span class="n">process_noise</span><span class="p">:</span> <span class="n">PN_TYPE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PN_TYPE</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This simple wrapper negates the process noise (as either a numpy array or a callable) for doing backwards smoothing.</span>

<span class="sd">    Typically this is not used directly by a user.</span>

<span class="sd">    :param process_noise: The process noise function or array to be negated</span>
<span class="sd">    :return: Either the negated array or the function wrapped to return a negated array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process_noise</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># just return the negated array</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">process_noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># need to wrap the function and negate it maintaining the appropriate call sequence</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">negated_pn</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Negates a process noise function.</span>

<span class="sd">            :param state: The state vector</span>
<span class="sd">            :param time: The time</span>
<span class="sd">            :return: the negated process noise</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="o">-</span><span class="n">process_noise</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">negated_pn</span>


<div class="viewcode-block" id="ExtendedKalmanFilter">
<a class="viewcode-back" href="../../../ufo/extended_kalman_filter/giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.html#giant.ufo.extended_kalman_filter.ExtendedKalmanFilter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExtendedKalmanFilter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements a simple extended kalman filter for processing measurements and estimating a state for a</span>
<span class="sd">    target that generated those measurements.</span>

<span class="sd">    The EKF works by linearizing about the current best estimate of the state at each measurement time, computing an</span>
<span class="sd">    update using the linearized space, updating the state, and then returning to the non-linear domain to propagate to</span>
<span class="sd">    the next measurement time.  This is relatively fast and powerful, but it does require an adequate initial guess for</span>
<span class="sd">    the state vector for the linearization to be reasonable.</span>

<span class="sd">    Using this EKF is fairly straight forward.  Simply specify the :class:`.Dynamics` model that governs your system</span>
<span class="sd">    (and your state vector) and provide a function that takes in a :class:`.Measurement` instance and a</span>
<span class="sd">    :class:`.Dynamics.State` class object which initializes the state off of the first measurement of the target.</span>
<span class="sd">    Then you can simply call :meth:`initialize` to initialize the state vector and :meth:`process_measurement` to</span>
<span class="sd">    process measurements (note that you should not call :meth:`process_measurement` to process the measurement you used</span>
<span class="sd">    to initialize the state vector).  Once you have processed all of your measurements, you can optionally call method</span>
<span class="sd">    :meth:`smooth` to perform backwards smoothing and get a best fit estimate of all of the residuals.</span>

<span class="sd">    Tuning the filter is done through the :attr:`~.SpiceGravityDynamics.process_noise` attribute of the</span>
<span class="sd">    :class:`.Dynamics` class (if it has one), :attr:`.Measurement.covariance` attribute, and the</span>
<span class="sd">    :attr:`state_initializer` function which can be used to set the initial state covariance.</span>

<span class="sd">    This is certainly not the most feature rich EKF and is intended primarily for light-weight work in determining</span>
<span class="sd">    tracks of non-cooperative targets observed in images as part of the :mod:`.ufo` package.  That being said, it is</span>
<span class="sd">    general enough that you could use it for other things if you wanted to, but doing that is beyond the scope of this</span>
<span class="sd">    documentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamics</span><span class="p">:</span> <span class="n">Dynamics</span><span class="p">,</span> <span class="n">state_initializer</span><span class="p">:</span> <span class="n">STATE_INITIALIZER_TYPE</span><span class="p">,</span>
                 <span class="n">initial_measurement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Measurement</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param dynamics: The :class:`.Dynamics` instance to use to propagate the state and covariance</span>
<span class="sd">        :param state_initializer: A callable that initializes the state given an initial measurement.  This should take</span>
<span class="sd">                                  in the initial :class:`.Measurement` and the :class:`.Dynamics.State` type (class</span>
<span class="sd">                                  object) and return the initialized :class:`.Dynamics.State` instance with at minimum</span>
<span class="sd">                                  position, velocity, and covariance filled out.</span>
<span class="sd">        :param initial_measurement: Optionally provide the initial measurement.  If this is not ``None`` then the</span>
<span class="sd">                                    :meth:`initialize` method will be called.  If it is ``None`` then the</span>
<span class="sd">                                    :meth:`initialize` method will need to be called manually.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">:</span> <span class="n">Dynamics</span> <span class="o">=</span> <span class="n">dynamics</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`.Dynamics` instance to use to propagate the state and covariance </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state_initializer</span><span class="p">:</span> <span class="n">STATE_INITIALIZER_TYPE</span> <span class="o">=</span> <span class="n">state_initializer</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A callable that initializes the state given an initial measurement.  </span>
<span class="sd">        </span>
<span class="sd">        This should take in the initial :class:`.Measurement` and the :class:`.Dynamics.State` type (class </span>
<span class="sd">        object) and return the initialized :class:`.Dynamics.State` instance with at minimum </span>
<span class="sd">        position, velocity, and covariance filled out. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">,</span> <span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the history of all of the best state objects in time order.  </span>

<span class="sd">        Initially this will contain the history from forward filtering.  After a call to :meth:`smooth` though, this </span>
<span class="sd">        will instead include the history from the backwards smoothing (in time order, not processing order).</span>
<span class="sd">        </span>
<span class="sd">        Each element is a tuple with the first element of the tuple being the pre-update state and the second element of </span>
<span class="sd">        the tuple being the post-update state.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">long_state_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">,</span> <span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the history of all of the state objects as they are generated.  </span>
<span class="sd">        </span>
<span class="sd">        This includes the state history for both the forwards filtering and backwards smoothing.  For the best fit </span>
<span class="sd">        history see the :attr:`state_history` parameter.</span>
<span class="sd">        </span>
<span class="sd">        Each element is a tuple with the first element of the tuple being the pre-update state and the second element of </span>
<span class="sd">        the tuple being the post-update state.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Measurement</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the history of the measurement objects as they are processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the history of the measurement residuals as a list of tuples of floats or numpy arrays </span>
<span class="sd">        (depending on whether the ingested measurements are scalars or arrays).</span>

<span class="sd">        Each tuple contains the pre-update residual first followed by the post-update residual.</span>

<span class="sd">        These are the best residuals (after smoothing).  For a full history of residuals see :attr:`long_residuals`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">long_residuals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This contains the history of all of the measurement residuals as a list of tuples of floats or numpy arrays </span>
<span class="sd">        (depending on whether the ingested measurements are scalars or arrays).</span>
<span class="sd">        </span>
<span class="sd">        Each tuple contains the pre-update residual first followed by the post-update residual.</span>
<span class="sd">        </span>
<span class="sd">        These are all the residuals (both forwards and backwards smoothing).  For the history of just the best residuals</span>
<span class="sd">        (after smoothing) see :attr:`residuals`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">identity</span> <span class="o">=</span> <span class="n">uuid4</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A unique identifier for this EKF</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">initial_measurement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">initial_measurement</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">ExtendedKalmanFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_initializer</span><span class="p">)</span>

        <span class="n">other</span><span class="o">.</span><span class="n">measurement_history</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">long_state_history</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_state_history</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">state_history</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">residuals</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">long_residuals</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_residuals</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">other</span>

<div class="viewcode-block" id="ExtendedKalmanFilter.initialize">
<a class="viewcode-back" href="../../../ufo/extended_kalman_filter/giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.initialize.html#giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.initialize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_measurement</span><span class="p">:</span> <span class="n">Measurement</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method (re)initializes the EKF by setting the initial state using the :attr:`state_initializer` function</span>
<span class="sd">        and resetting all of the history lists.</span>

<span class="sd">        Note that this method deletes all history from the EKF, so if you want to keep the history, make sure you make a</span>
<span class="sd">        copy before calling this method (or create an entirely new EKF).</span>

<span class="sd">        :param initial_measurement: The initial measurement to use to initialize the state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># reset the state history</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_initializer</span><span class="p">(</span><span class="n">initial_measurement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_history</span> <span class="o">=</span> <span class="p">[(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">long_state_history</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># reset the measurement and residual history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_history</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_measurement</span><span class="p">]</span>

        <span class="n">residual</span> <span class="o">=</span> <span class="n">initial_measurement</span><span class="o">.</span><span class="n">observed</span> <span class="o">-</span> <span class="n">initial_measurement</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">residual</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">residual</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">long_residuals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">residual</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">residual</span><span class="p">)]</span></div>


<div class="viewcode-block" id="ExtendedKalmanFilter.propagate_and_predict">
<a class="viewcode-back" href="../../../ufo/extended_kalman_filter/giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.propagate_and_predict.html#giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.propagate_and_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">propagate_and_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measurement</span><span class="p">:</span> <span class="n">Measurement</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">],</span>
                                                                       <span class="n">Optional</span><span class="p">[</span><span class="n">F_SCALAR_OR_ARRAY</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function integrates to the new measurement time and predicts the measurement at that time based on the</span>
<span class="sd">        propagated state.</span>

<span class="sd">        :param measurement: The measurement instance which defines at minimum the new time and can predict the</span>
<span class="sd">                            measurement</span>
<span class="sd">        :return: The state at the requested time and the predicted measurement</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_state_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">measurement</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EKF </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1"> failed to propagate&#39;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">predicted_measurement</span> <span class="o">=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">predicted_measurement</span></div>


<div class="viewcode-block" id="ExtendedKalmanFilter.process_measurement">
<a class="viewcode-back" href="../../../ufo/extended_kalman_filter/giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.process_measurement.html#giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.process_measurement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measurement</span><span class="p">:</span> <span class="n">Measurement</span><span class="p">,</span>
                            <span class="n">pre_update_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">pre_update_predicted_measurement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">F_SCALAR_OR_ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">backwards</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">backwards_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This does a update step for a new measurement.</span>

<span class="sd">        The predicted state is used along with the measurement to compute the state update, which is applied.</span>
<span class="sd">        The residuals are also computed.  Everything is stored in the appropriate history attributes.</span>

<span class="sd">        :param measurement: The new measurement to ingest</span>
<span class="sd">        :param pre_update_state: The predicted state at the measurement time.  If ``None`` then the state will be</span>
<span class="sd">                                 propagated to the measurement time</span>
<span class="sd">        :param pre_update_predicted_measurement: The predicted measurement using the predicted state at the measurement</span>
<span class="sd">                                                 time.  If ``None`` then the predicted measurement will be generated for</span>
<span class="sd">                                                 you</span>
<span class="sd">        :param backwards: A boolean flag indicating if we are doing backwards smoothing.  If ``True`` then the way we</span>
<span class="sd">                          store the results changes.</span>
<span class="sd">        :param backwards_index: An integer specifying the index into the short history lists where we should insert the</span>
<span class="sd">                                results.  This is ignored if ``backwards`` is not ``True``</span>
<span class="sd">        :return: The applied state update as a numpy array the same length of the state vector (including covariance)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">backwards</span><span class="p">:</span>
            <span class="c1"># store the measurement</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">measurement</span><span class="p">)</span>

        <span class="c1"># get the state</span>
        <span class="k">if</span> <span class="n">pre_update_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pre_update_state</span><span class="p">,</span> <span class="n">pre_update_predicted_measurement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propagate_and_predict</span><span class="p">(</span><span class="n">measurement</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pre_update_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pre_update_state</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">time</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Something fishy is going on.  The state time does not match the measurement time. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Did you forget to propagate_and_predict? STATE TIME: </span><span class="si">{</span><span class="n">pre_update_state</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;MEASUREMENT TIME: </span><span class="si">{</span><span class="n">measurement</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># compute the residuals</span>
        <span class="k">if</span> <span class="n">pre_update_predicted_measurement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pre_update_residuals</span> <span class="o">=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">observed</span> <span class="o">-</span> <span class="n">measurement</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">pre_update_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pre_update_residuals</span> <span class="o">=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">observed</span> <span class="o">-</span> <span class="n">pre_update_predicted_measurement</span>

        <span class="c1"># compute the observation matrix</span>
        <span class="n">observation_matrix</span> <span class="o">=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">pre_update_state</span><span class="p">)</span>

        <span class="c1"># compute the Kalman gain</span>
        <span class="n">state_covariance</span> <span class="o">=</span> <span class="n">pre_update_state</span><span class="o">.</span><span class="n">covariance</span>
        <span class="n">measurement_covariance</span> <span class="o">=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">covariance</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kalman_gain</span> <span class="o">=</span> <span class="p">((</span><span class="n">state_covariance</span> <span class="o">@</span> <span class="n">observation_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">observation_matrix</span> <span class="o">@</span> <span class="n">state_covariance</span> <span class="o">@</span> <span class="n">observation_matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>
                                         <span class="n">measurement_covariance</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Unable to invert kalman gain. &#39;</span>
                            <span class="s1">&#39;Falling back to pseudo inverse but something is probably wrong&#39;</span><span class="p">)</span>

            <span class="n">kalman_gain</span> <span class="o">=</span> <span class="p">((</span><span class="n">state_covariance</span> <span class="o">@</span> <span class="n">observation_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">observation_matrix</span> <span class="o">@</span> <span class="n">state_covariance</span> <span class="o">@</span> <span class="n">observation_matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>
                                          <span class="n">measurement_covariance</span><span class="p">))</span>

        <span class="c1"># update the state</span>
        <span class="n">state_update</span> <span class="o">=</span> <span class="n">kalman_gain</span> <span class="o">@</span> <span class="n">pre_update_residuals</span>
        <span class="n">updated_state</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">pre_update_state</span><span class="p">)</span>
        <span class="n">updated_state</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">state_update</span><span class="p">)</span>

        <span class="n">identity_minus_ko</span><span class="p">:</span> <span class="n">DOUBLE_ARRAY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">updated_state</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="n">kalman_gain</span><span class="nd">@observation_matrix</span>

        <span class="k">if</span> <span class="n">updated_state</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">updated_state</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="p">(</span><span class="n">identity_minus_ko</span><span class="nd">@updated_state</span><span class="o">.</span><span class="n">covariance</span><span class="nd">@identity_minus_ko</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>
                                        <span class="n">kalman_gain</span> <span class="o">@</span> <span class="n">measurement_covariance</span> <span class="o">@</span> <span class="n">kalman_gain</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># get the post-fit residuals</span>
        <span class="n">post_update_residuals</span> <span class="o">=</span> <span class="n">measurement</span><span class="o">.</span><span class="n">observed</span> <span class="o">-</span> <span class="n">measurement</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">updated_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">measurement</span><span class="o">.</span><span class="n">compare_residuals</span><span class="p">(</span><span class="n">post_update_residuals</span><span class="p">,</span> <span class="n">pre_update_residuals</span><span class="p">):</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Filter might be diverging. Post-update residual is not smaller than pre-update. &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;PRE: </span><span class="si">{</span><span class="n">pre_update_residuals</span><span class="si">}</span><span class="s1"> &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;POST: </span><span class="si">{</span><span class="n">post_update_residuals</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># store the results</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">backwards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">long_residuals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pre_update_residuals</span><span class="p">,</span> <span class="n">post_update_residuals</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pre_update_residuals</span><span class="p">,</span> <span class="n">post_update_residuals</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pre_update_state</span><span class="p">,</span> <span class="n">updated_state</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">long_state_history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pre_update_state</span><span class="p">,</span> <span class="n">updated_state</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">long_residuals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pre_update_residuals</span><span class="p">,</span> <span class="n">post_update_residuals</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">long_state_history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pre_update_state</span><span class="p">,</span> <span class="n">updated_state</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">[</span><span class="n">backwards_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pre_update_residuals</span><span class="p">,</span> <span class="n">post_update_residuals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="n">backwards_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pre_update_state</span><span class="p">,</span> <span class="n">updated_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state_update</span></div>


<div class="viewcode-block" id="ExtendedKalmanFilter.smooth">
<a class="viewcode-back" href="../../../ufo/extended_kalman_filter/giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.smooth.html#giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.smooth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_sigma_update</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs backwards smoothing (kind-of) for all measurements processed by this EKF.</span>

<span class="sd">        This is done by starting at the end of the &quot;arc&quot; and processing the measurements that were already ingested in</span>
<span class="sd">        reverse order.  In order to do this we need to negate the process noise (otherwise it causes the covariance to</span>
<span class="sd">        collapse instead of grow).  We then step through each measurement in reverse order and reprocess it using</span>
<span class="sd">        :meth:`process_measurement`.</span>

<span class="sd">        After calling the method, :attr:`long_residuals` and :attr:`long_state_history` will be twice as long and</span>
<span class="sd">        :attr:`residuals` and :attr:`state_history` will have the &quot;smoothed&quot; residuals and state history.</span>

<span class="sd">        If we can&#39;t complete the smoothing (because of NaN in the covariance) then this function will return ``False``.</span>
<span class="sd">        If we did complete the smoothing it will return ``True``</span>

<span class="sd">        :param maximum_sigma_update: The maximum state update allowed expressed as a multiple of the pre-update</span>
<span class="sd">                                     covariance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">original_pn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">original_pn</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">,</span> <span class="s1">&#39;process_noise&#39;</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">,</span> <span class="s2">&quot;process_noise&quot;</span><span class="p">,</span> <span class="n">_negate_pn</span><span class="p">(</span><span class="n">original_pn</span><span class="p">))</span>

        <span class="n">skip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">backwards_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">state_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_measurement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">[</span><span class="n">backwards_index</span><span class="p">],</span> <span class="n">backwards</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">backwards_index</span><span class="o">=</span><span class="n">backwards_index</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">state_update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Failed to propagate while smoothing&#39;</span><span class="p">)</span>
                <span class="n">skip</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            
            <span class="k">if</span> <span class="p">(</span><span class="n">b1c</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="n">backwards_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b1c</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Got a NaN in the covariance while smoothing.  Stopping.&quot;</span><span class="p">)</span>
                <span class="n">skip</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">state_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="n">backwards_index</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># compute how big of an update we made</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">b0c</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="n">backwards_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">sigma_jump</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">b0c</span><span class="p">)</span> <span class="o">@</span> <span class="n">state_update</span><span class="p">[:</span><span class="n">state_size</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">sigma_jump</span> <span class="o">&gt;=</span> <span class="n">maximum_sigma_update</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Had too large of an update in the smoothing </span><span class="si">{</span><span class="n">sigma_jump</span><span class="si">}</span><span class="s2">. Stopping&quot;</span><span class="p">)</span>

                <span class="n">skip</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">,</span> <span class="s1">&#39;process_noise&#39;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">,</span> <span class="s2">&quot;process_noise&quot;</span><span class="p">,</span> <span class="n">original_pn</span><span class="p">)</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">skip</span></div>


<div class="viewcode-block" id="ExtendedKalmanFilter.compute_residual_statistics">
<a class="viewcode-back" href="../../../ufo/extended_kalman_filter/giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.compute_residual_statistics.html#giant.ufo.extended_kalman_filter.ExtendedKalmanFilter.compute_residual_statistics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_residual_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the mean and standard deviation of the residual history from the EKF</span>

<span class="sd">        :return: The residual mean and residual history of the best (post-smoothed) post-update residuals from the ekf</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">resids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residuals</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">resids</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">resids</span><span class="o">.</span><span class="n">std</span><span class="p">()</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>