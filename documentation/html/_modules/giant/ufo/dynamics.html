<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.ufo.dynamics &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.ufo.dynamics</h1><div class="highlight"><pre>
<span></span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines dynamics models to be used in an EKF for propagating the state and covariance of an estimated</span>
<span class="sd">target.</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">The dynamics specify how the target is expected to move in space given initial conditions.  They are usually specified</span>
<span class="sd">as an ODE initial value problem and integrated numerically, although for simple cases a few closed for analytic</span>
<span class="sd">solutions exist. These models are generally used by the :mod:`extended_kalman_filter` module in order to link</span>
<span class="sd">observations together and to propagate the state from one time to the next.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">This module defines 3 classes for defining Dynamics models.  The first, :class:`.Dynamics` is an abstract base class</span>
<span class="sd">that provides a template for creating a new dynamics model in GIANT.ufo.  If you want to create your own custom model,</span>
<span class="sd">you should subclass this and implement/update the :attr:`.Dynamics.State` class describing the state vector for your</span>
<span class="sd">model, and the abstract methods defined by the abstract class.  If you do this then you will be able to use your</span>
<span class="sd">dynamics model in the EKF (presuming your dynamics model works and describes what it going on).</span>

<span class="sd">Alternatively, the there are 2 basic dynamics models provided in this module which you can use directly or subclass and</span>
<span class="sd">extend with more features.  The first :class:`SpiceGravityDynamics` implements a simple n-body problem dynamics model</span>
<span class="sd">assuming point mass gravity, using NAIF spice to query the n-body positions at each integration step.  The second,</span>
<span class="sd">:class:`SolRadAndGravityDynamics` adds cannonball model solar radiation pressure to the simple n-body gravity model.</span>
<span class="sd">These 2 simple dynamics models are generally sufficient for most things you&#39;ll be tracking in UFO and thus can be used</span>
<span class="sd">directly.  They also serve as examples for implementing/extending your own dynamics models.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># we minimize the security risk here by using FTPS</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ftplib</span>  <span class="c1"># nosec</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">Self</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">spiceypy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">spice</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">OptimizeResult</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.spice_interface</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime_to_et</span>


<span class="n">_I3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Just a constant 3x3 identity matrix.  </span>

<span class="sd">This is used to avoid having to allocate matrices all the time for efficiency.  Probably doesn&#39;t really do anything but </span>
<span class="sd">its low hanging fruit.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_numeric_jacobian</span><span class="p">(</span><span class="n">dynamics</span><span class="p">:</span> <span class="s1">&#39;Dynamics&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">state_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>

    <span class="n">pert</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">state_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">state_size</span><span class="p">):</span>
        <span class="n">pert_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

        <span class="n">pert_vect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pert</span>

        <span class="n">positive_pert</span> <span class="o">=</span> <span class="n">state</span> <span class="o">+</span> <span class="n">pert_vect</span>

        <span class="n">negative_pert</span> <span class="o">=</span> <span class="n">state</span> <span class="o">-</span> <span class="n">pert_vect</span>

        <span class="n">jacobian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dynamics</span><span class="o">.</span><span class="n">compute_dynamics</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">positive_pert</span><span class="p">)[:</span><span class="n">state_size</span><span class="p">]</span> <span class="o">-</span>
                          <span class="n">dynamics</span><span class="o">.</span><span class="n">compute_dynamics</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">negative_pert</span><span class="p">)[:</span><span class="n">state_size</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pert</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">jacobian</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_download_kernels</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function downloads the standard spice kernels</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># security threat is not risky due to FTPS</span>
    <span class="n">ftp</span> <span class="o">=</span> <span class="n">ftplib</span><span class="o">.</span><span class="n">FTP_TLS</span><span class="p">(</span><span class="s1">&#39;naif.jpl.nasa.gov&#39;</span><span class="p">)</span>  <span class="c1"># nosec</span>

    <span class="n">ftp</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ftp</span><span class="o">.</span><span class="n">cwd</span><span class="p">(</span><span class="s1">&#39;pub/naif/generic_kernels/&#39;</span><span class="p">)</span>

    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spk/planets/de440.bsp&#39;</span><span class="p">,</span>
             <span class="s1">&#39;pck/pck00010.tpc&#39;</span><span class="p">,</span>
             <span class="s1">&#39;pck/gm_de431.tpc&#39;</span><span class="p">,</span>
             <span class="s1">&#39;lsk/latest_leapseconds.tls&#39;</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="n">local</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">local</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
            <span class="n">ftp</span><span class="o">.</span><span class="n">retrbinary</span><span class="p">(</span><span class="s1">&#39;RETR </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">)</span>


<div class="viewcode-block" id="zero3">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.zero3.html#giant.ufo.dynamics.zero3">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">zero3</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This simple function returns a length 3 numpy array of zeros.</span>

<span class="sd">    It is used as the default_factory for State fields sometimes.</span>

<span class="sd">    :return: np.zeros(3, dtype=np.float64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>



<div class="viewcode-block" id="Dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.Dynamics.html#giant.ufo.dynamics.Dynamics">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dynamics</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamics classes are used to propagate state and covariance through time.</span>

<span class="sd">    This is an abstract Dynamics class and it defines the interface that is expected for a Dynamics class.  Namely, a</span>
<span class="sd">    dynamics class needs to define a ``class State`` which defines the state vector used in that dynamics class as well</span>
<span class="sd">    as a :meth:`compute_dynamics` which computes the time derivative of the state vector.  You may also wish to</span>
<span class="sd">    override the :meth:`propagate` method if you would like to do your own propagation instead of the default.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">State</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each Dynamics subclass should define a State class which defines that the state is for that dynamics case.</span>

<span class="sd">        At minimum the state class should provide time, position, velocity, and covariance attributes.  You should also</span>
<span class="sd">        define the __sub__ method to compute at least the relative state for position/velocity and define a vector</span>
<span class="sd">        property which returns the state as a 1D vector representation or sets the state from a 1D vector</span>
<span class="sd">        representation, at least if you want to use the default propagate method provided by the :class:`Dynamics`</span>
<span class="sd">        class.</span>

<span class="sd">        Dataclasses can make these easy (so you don&#39;t have to right your own init method) but you don&#39;t need to use them</span>

<span class="sd">        For many cases this simple class is probably sufficient for what you need.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time</span><span class="p">:</span> <span class="n">datetime</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The time that this state is for</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The position of this state in km as a numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">velocity</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">zero3</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The velocity of this state in km/sec as a numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">orientation</span><span class="p">:</span> <span class="n">Rotation</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">Rotation</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The orientation with respect to the base frame that this state is represented in.  </span>
<span class="sd">         </span>
<span class="sd">        Typically the base frame is the inertial frame centered at the CB.  It doesn&#39;t have to be this, but it must be</span>
<span class="sd">        inertial (not rotating).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">covariance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        State covariance matrix as a n x n numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">length</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The length of the state vector for this state instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the number of elements in the state vector</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This property returns a list of arrays that can be concatenated together to form the state vector.</span>

<span class="sd">            Therefore, you can do ``np.concatenate(state_instance.vector)`` to get a 1D array of the state vector.</span>

<span class="sd">            This is done so that subclasses can override the order if they so choose.</span>

<span class="sd">            :return: a list of numpy arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">]))</span> <span class="c1"># pyright: ignore[reportArgumentType]</span>

        <span class="nd">@vector</span><span class="o">.</span><span class="n">setter</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This computes the relative state from other to self.</span>

<span class="sd">            Mathematically we have:</span>

<span class="sd">            .. math::</span>
<span class="sd">                a-b = c \\</span>
<span class="sd">                c+b = a \\</span>
<span class="sd">                a-c = b</span>

<span class="sd">            where a is self, b is other, and c is the result of this method (the relative state)</span>

<span class="sd">            The relative state that is returned will be expressed in the orientation of a (or self).  It is assumed that</span>
<span class="sd">            the states share the same origin (although the returned relative state will not share the same origin)</span>

<span class="sd">            Covariance is only rotated in this computation and is assumed to be the same as other</span>

<span class="sd">            :param other: The state that we are computing the relative state with respect to</span>
<span class="sd">            :return: the relative state from other to self</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="c1"># make a copy of self</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="n">delta_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

            <span class="n">out</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@other</span><span class="o">.</span><span class="n">position</span>
            <span class="n">out</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">-</span> <span class="n">delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@other</span><span class="o">.</span><span class="n">velocity</span>
            <span class="n">out</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@other</span><span class="o">.</span><span class="n">covariance</span><span class="nd">@delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span>

            <span class="k">return</span> <span class="n">out</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This computes adds the relative state other to self.</span>

<span class="sd">            Mathematically we have:</span>

<span class="sd">            .. math::</span>
<span class="sd">                a+b = c \\</span>
<span class="sd">                c-b = a \\</span>
<span class="sd">                a-c = b</span>

<span class="sd">            where a is self, b is other, and c is the result of this method</span>

<span class="sd">            The state that is returned will be expressed in the orientation of other.</span>

<span class="sd">            Covariance is ignored in this computation (only position and velocity are modified from self).</span>

<span class="sd">            :param other: The relative state to be added to this one</span>
<span class="sd">            :return: The new state expressed in the orientation of other</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="c1"># make a copy of self</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">delta_orientation</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">orientation</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

            <span class="n">out</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@self</span><span class="o">.</span><span class="n">position</span>
            <span class="n">out</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">velocity</span> <span class="o">+</span> <span class="n">delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@self</span><span class="o">.</span><span class="n">velocity</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@self</span><span class="o">.</span><span class="n">covariance</span><span class="nd">@delta_orientation</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span>

            <span class="k">return</span> <span class="n">out</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_update</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform an additive update to ``self``.</span>

<span class="sd">            This method updates ``self`` by adding the input update to ``self``.</span>

<span class="sd">            This is used inside of the :class:`.ExtendedKalmanFilter` to apply the update to the state vector from a</span>
<span class="sd">            processed measurement.  The ``state_update`` input will be a 1d numpy array the same length as the state</span>
<span class="sd">            vector (``len(self)``).</span>

<span class="sd">            :param state_update: The update vector to add to the state</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">+=</span> <span class="n">state_update</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">+=</span> <span class="n">state_update</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>


<div class="viewcode-block" id="Dynamics.propagate">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.Dynamics.propagate.html#giant.ufo.dynamics.Dynamics.propagate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span> <span class="n">new_time</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">State</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method propagates the input state the the requested time.</span>

<span class="sd">        By default an RK45 ODE integrator is used to integrate the state from the first time to the second, though you</span>
<span class="sd">        can override this method if you wish.</span>

<span class="sd">        :param state: The current state</span>
<span class="sd">        :param new_time: the time the state is to be propagated to</span>
<span class="sd">        :return: The updated state at the new time (a copy)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the ephemeris seconds since J2000 for the start/end times to avoid leap second non-sense</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">datetime_to_et</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">datetime_to_et</span><span class="p">(</span><span class="n">new_time</span><span class="p">)</span>

        <span class="c1"># get the state vector at the initial time</span>
        <span class="c1"># this will give use a 1D array of [position, velocity, covariance], at least for the default State case</span>
        <span class="n">state_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

        <span class="c1"># do the integration</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">solution</span><span class="p">:</span> <span class="n">OptimizeResult</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_dynamics</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">],</span> <span class="n">state_vector</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;RK45&#39;</span><span class="p">)</span>

        <span class="n">out_state</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">out_state</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">out_state</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">new_time</span>

        <span class="k">return</span> <span class="n">out_state</span></div>


<div class="viewcode-block" id="Dynamics.compute_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.Dynamics.compute_dynamics.html#giant.ufo.dynamics.Dynamics.compute_dynamics">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should compute the dynamics for the state vector (which normally is the position/velocity/other</span>
<span class="sd">        state parameters + the raveled covariance matrix)</span>

<span class="sd">        The dynamics should be a 1d array that is the same length as the state vector.  It should give the time</span>
<span class="sd">        derivative of the state vector.</span>

<span class="sd">        :param time: the time at which the dynamics are to be computed.  Normally this is as ephemeris seconds since</span>
<span class="sd">                     J2000</span>
<span class="sd">        :param state: The state vector to compute the dynamics for</span>
<span class="sd">        :return: The time derivative of the state vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>
</div>




<span class="n">PN_TYPE</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This describes the type that the process noise can be.</span>

<span class="sd">It can either be a numpy array, or it can be a callable that takes in the state vector and current time and returns a </span>
<span class="sd">numpy array</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SpiceGravityDynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SpiceGravityDynamics.html#giant.ufo.dynamics.SpiceGravityDynamics">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpiceGravityDynamics</span><span class="p">(</span><span class="n">Dynamics</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements a simple N-Body gravity dynamics model using Spice as the source of the planet locations.</span>

<span class="sd">    To use this class, specify the central (primary body) as well as any bodies/barycenters you want to include as</span>
<span class="sd">    n-body sources through the ``center_body`` and ``other_bodies`` arguments respectively.  The class will then</span>
<span class="sd">    automatically compute the gravity for you.  Note that you should not include the central body in the list of n-body</span>
<span class="sd">    perturbations.</span>

<span class="sd">    By default, this class will retrieve the GM values from spice for each body/barycenter being considered.  You can</span>
<span class="sd">    override these values by specifying the key word argument ``gravity_parameters`` which should be a dictionary</span>
<span class="sd">    mapping the name of the planet to the gravity parameter.</span>

<span class="sd">    This class can optionally furnsh the planetary ephemeris and planetary constants files for you if you so desire.</span>
<span class="sd">    This is controlled through key word argument ``load_data``.  If you provide this option, the class will attempt to</span>
<span class="sd">    locate the files in the ``data`` directory in the directory containing this file.  If it cannot find the files there</span>
<span class="sd">    then it will ask you if it can download them from the naif site.  If you have already loaded kernels that provide</span>
<span class="sd">    the required data (namely the name of the planets, the planetary GM (unless you are providing your own)), and the</span>
<span class="sd">    locations of the planets) then you should leave this option off as it could override the values you have already</span>
<span class="sd">    loaded.</span>

<span class="sd">    The covariance in this dynamics model is integrated directly instead of using the state transformation matrix</span>
<span class="sd">    (because that is how I learned EKFs...).  This means that the process noise is added to the covariance derivative</span>
<span class="sd">    directly (which may be different from what many are use to).  Therefore be sure you carefully consider how to set</span>
<span class="sd">    the process noise when using this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_body</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">process_noise</span><span class="p">:</span> <span class="n">PN_TYPE</span><span class="p">,</span>
                 <span class="n">other_bodies</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">gravity_parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">load_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">minimum_time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param center_body: The center of integration (and the center of the integration frame)</span>
<span class="sd">        :param process_noise: The process noise either as a numpy array of shape 7x7 (constant process noise) or as a</span>
<span class="sd">                              callable object which takes in the current state and time (np.ndarray, float) and outputs</span>
<span class="sd">                              a 7x7 numpy array containing the process noise matrix</span>
<span class="sd">        :param other_bodies: Other bodies whose gravity should be included as a list of body/barycenter names.  If</span>
<span class="sd">                             ``None`` no other bodies will be considered.</span>
<span class="sd">        :param gravity_parameters: A dictionary mapping names to GM values.  If this is ``None`` or it does not provide</span>
<span class="sd">                                   the data for one of the bodies being considered we will try to query this from spice.</span>
<span class="sd">                                   The values should be in km**3/sec**2</span>
<span class="sd">        :param load_data: A boolean flag specifying whether this class should furnsh the required datafiles.  If you</span>
<span class="sd">                          have already loaded files then you should leave this as ``False``.</span>
<span class="sd">        :param minimum_time_step: The minimum time step to allow the integrator to take in seconds.  If ``None`` (or 0)</span>
<span class="sd">                                  then no minimum time step is enforced.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">center_body</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">center_body</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the center of integration and center of the integration frame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span><span class="p">:</span> <span class="n">PN_TYPE</span> <span class="o">=</span> <span class="n">process_noise</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The process noise either as a numpy array of shape 6x6 (constant process noise) or as a </span>
<span class="sd">        callable object which takes in the current state and time (np.ndarray, float) and outputs</span>
<span class="sd">        a 6x6 numpy array containing the process noise matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">other_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_bodies</span> <span class="k">if</span> <span class="n">other_bodies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of other bodies to consider the gravity effects for.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gravity_parameters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">gravity_parameters</span> <span class="k">if</span> <span class="n">gravity_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary mapping planet/barycenter name to GM in km**3/sec**2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">load_data</span><span class="p">:</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s1">&#39;data&#39;</span>

            <span class="n">files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">joinpath</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;spk/planets/de440.bsp&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;pck/pck00010.tpc&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;pck/gm_de431.tpc&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;lsk/latest_leapseconds.tls&#39;</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">file</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="n">download</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Missing spice data.  Would you like to download it (y/n)?&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">download</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                        <span class="n">_download_kernels</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Requested to load data but data is missing&#39;</span><span class="p">)</span>

                <span class="n">spice</span><span class="o">.</span><span class="n">furnsh</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gm_cb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_body</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The gm of the central body</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gm_other_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gm</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_bodies</span><span class="p">]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of the GMs of other bodies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The previous time step for tracking the minimum step size</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum_time_step</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum time step to allow the integrator to take in seconds. </span>
<span class="sd">        </span>
<span class="sd">        If ``None`` or ``0`` no minimum time step is enforced.</span>
<span class="sd">        </span>
<span class="sd">        If the minimum time step is encountered then a Value error is raised</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpiceGravityDynamics.get_gm">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SpiceGravityDynamics.get_gm.html#giant.ufo.dynamics.SpiceGravityDynamics.get_gm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_gm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

        <span class="n">gm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gravity_parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gm</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">spice</span><span class="o">.</span><span class="n">bodvrd</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s1">&#39;GM&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">gm</span></div>


<div class="viewcode-block" id="SpiceGravityDynamics.compute_state_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SpiceGravityDynamics.compute_state_dynamics.html#giant.ufo.dynamics.SpiceGravityDynamics.compute_state_dynamics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_state_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">et_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                               <span class="n">return_intermediaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                                                             <span class="n">Tuple</span><span class="p">[</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This computes the dynamics for just the &quot;state&quot; part of the state vector (not the covariance)</span>

<span class="sd">        Optionally this can also return the distance from the CB to the spacecraft, the vectors from the central body to</span>
<span class="sd">        the other bodies, the vectors from the spacecraft to the other bodies, the distances from the central body to</span>
<span class="sd">        the other bodies, and the distances from the other bodies to the spacecraft if ``return_intermediaries`` is</span>
<span class="sd">        ``True``.</span>

<span class="sd">        The first component of the return is always a list of the dynamics for the state vector in order of position,</span>
<span class="sd">        velocity.</span>

<span class="sd">        :param state: The state vector at the current time</span>
<span class="sd">        :param et_time: The ephemeris time</span>
<span class="sd">        :param return_intermediaries: A flag specifying whether to return the intermediate distances/vectors for use</span>
<span class="sd">                                      elsewhere</span>
<span class="sd">        :return: A list containing [dposition/dt, dvelocity/dt].  Optionally return a second tuple containing</span>
<span class="sd">                 (radial_distance_cb, position_cp_to_bodies, position_sc_to_bodies, radial_distance_cb_to_bodies,</span>
<span class="sd">                 radial_distance_sc_to_bodies)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">state</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># position is from CB to S/C</span>
        <span class="n">velocity</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

        <span class="c1"># distance to central body</span>
        <span class="n">radial_distance_cb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>

        <span class="c1"># compute the gravitational acceleration due to the central body</span>
        <span class="n">acceleration_gravity</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gm_cb</span><span class="o">*</span><span class="n">position</span><span class="o">/</span><span class="n">radial_distance_cb</span><span class="o">**</span><span class="mi">3</span>

        <span class="c1"># gravity due to other bodies</span>
        <span class="n">position_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">position_cb_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">radial_distance_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">radial_distance_cb_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">body</span><span class="p">,</span> <span class="n">gm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_bodies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gm_other_bodies</span><span class="p">):</span>
            <span class="n">position_cb_to_bodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spice</span><span class="o">.</span><span class="n">spkpos</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">et_time</span><span class="p">,</span> <span class="s1">&#39;J2000&#39;</span><span class="p">,</span> <span class="s1">&#39;LT+S&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_body</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">position_sc_to_bodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">position_cb_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">radial_distance_sc_to_bodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">position_sc_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">radial_distance_cb_to_bodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">position_cb_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>

            <span class="n">acceleration_gravity</span> <span class="o">+=</span> <span class="n">gm</span><span class="o">*</span><span class="p">(</span><span class="n">position_sc_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">radial_distance_sc_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span>
                                        <span class="n">position_cb_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">radial_distance_cb_to_bodies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_intermediaries</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">velocity</span><span class="p">,</span> <span class="n">acceleration_gravity</span><span class="p">],</span> <span class="p">(</span><span class="n">radial_distance_cb</span><span class="p">,</span>
                                                      <span class="n">position_cb_to_bodies</span><span class="p">,</span> <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                                                      <span class="n">radial_distance_cb_to_bodies</span><span class="p">,</span> <span class="n">radial_distance_sc_to_bodies</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">velocity</span><span class="p">,</span> <span class="n">acceleration_gravity</span><span class="p">],</span> <span class="p">()</span></div>


<div class="viewcode-block" id="SpiceGravityDynamics.compute_covariance_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SpiceGravityDynamics.compute_covariance_dynamics.html#giant.ufo.dynamics.SpiceGravityDynamics.compute_covariance_dynamics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_covariance_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">et_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                    <span class="n">position_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                    <span class="n">radial_distance_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the dynamics for the covariance matrix.</span>

<span class="sd">        The dynamics for the covariance matrix is the product of the Jacobian matrix of the dynamics for the state with</span>
<span class="sd">        respect to the state and the current covariance matrix, plus the process noise matrix</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{\partial \mathbf{P}}{\partial t} = \mathbf{J}\mathbf{P} + \mathbf{P}\mathbf{J}^T + \mathbf{Q}</span>

<span class="sd">        where :math:`\mathbf{P}` is the covariance matrix, :math:`t` is time,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J}=\frac{\partial \mathbf{f}(\mathbf{x})}{\partial\mathbf{x}}</span>

<span class="sd">        with :math:`\mathbf{J}` being the Jacobian matrix, :math:`\mathbf{f}(\mathbf{x})` is the state dynamics</span>
<span class="sd">        function, and :math:`\mathbf{x}` is the state vector.</span>

<span class="sd">        :param state: The state vector at the current time</span>
<span class="sd">        :param et_time: The ephemeris time</span>
<span class="sd">        :param radial_distance_cb: The distance from the central body to the body we are estimating</span>
<span class="sd">        :param position_sc_to_bodies: The position from the spacecraft to the other bodies considered for gravity</span>
<span class="sd">        :param radial_distance_sc_to_bodies: The distance from the spacecraft to the other bodies</span>
<span class="sd">        :return: The covariance time derivative.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">jacobian</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">_I3</span>
        <span class="n">jacobian</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_d_acceleration_d_position</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">,</span>
                                                                   <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                                                                   <span class="n">radial_distance_sc_to_bodies</span><span class="p">)</span>

        <span class="n">covariance</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">pn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">et_time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">jacobian</span><span class="nd">@covariance</span> <span class="o">+</span> <span class="n">covariance</span><span class="nd">@jacobian</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">pn</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_d_acceleration_d_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                           <span class="n">position_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                           <span class="n">radial_distance_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returns the jacobian of the acceleration with respect to the position vector as a 3x3 numpy array.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{a}_G}{\partial\mathbf{x}_{pos}}=\mu_{cb}</span>
<span class="sd">            \left(\frac{3}{d_{cb2sc}**5}\mathbf{x}_{pos}\mathbf{x}_{pos}^T -</span>
<span class="sd">            \frac{\mathbf{I}_{3\times 3}}{d_{cb2sc}**3}\right) -</span>
<span class="sd">            \sum_{bod}\left(\mu_{bod}\left(\frac{3}{d_{sc2bod}**5}\mathbf{x_{pos,sc2bod}\mathbf{x_{pos,sc2bod}^T-</span>
<span class="sd">            \frac{\mathbf{I}_{3\times 3}}{d_{sc2bod})</span>


<span class="sd">        :param state: The state vector at the current time</span>
<span class="sd">        :param radial_distance_cb: The distance from the central body to the body we are estimating</span>
<span class="sd">        :param position_sc_to_bodies: The position from the spacecraft to the other bodies considered for gravity</span>
<span class="sd">        :param radial_distance_sc_to_bodies: The distance from the spacecraft to the other bodies</span>
<span class="sd">        :return: The jacobian of the acceleration with respect to the state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gm_cb</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">state</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">state</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="n">radial_distance_cb</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span>
                          <span class="n">_I3</span><span class="o">/</span><span class="n">radial_distance_cb</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">gm</span><span class="p">,</span> <span class="n">position_sc_to_bod</span><span class="p">,</span> <span class="n">radial_distance_sc_to_bod</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gm_other_bodies</span><span class="p">,</span>
                                                                     <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                                                                     <span class="n">radial_distance_sc_to_bodies</span><span class="p">):</span>

            <span class="n">jac</span> <span class="o">+=</span> <span class="n">gm</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">position_sc_to_bod</span><span class="p">,</span> <span class="n">position_sc_to_bod</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">radial_distance_sc_to_bod</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span>
                       <span class="n">_I3</span><span class="o">/</span><span class="n">radial_distance_sc_to_bod</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">jac</span>

<div class="viewcode-block" id="SpiceGravityDynamics.compute_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SpiceGravityDynamics.compute_dynamics.html#giant.ufo.dynamics.SpiceGravityDynamics.compute_dynamics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the dynamics for the state vector</span>

<span class="sd">        The dynamics are returned as a 1d array of length 42.  It gives the time derivative of the state vector.</span>

<span class="sd">        The first 6 elements of the dynamics array are the position and velocity components of the state vector</span>
<span class="sd">        respectively.  The last 36 elements are the dynamics of the covariance matrix raveled in c-order.</span>

<span class="sd">        :param time: the time at which the dynamics are to be computed in ephemeris seconds since J2000</span>
<span class="sd">        :param state: The state vector to compute the dynamics for</span>
<span class="sd">        :return: The time derivative of the state vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_time_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_time_step</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The time step is too small&#39;</span><span class="p">)</span>

        <span class="n">dynamics</span><span class="p">,</span>  <span class="p">(</span><span class="n">radial_distance_cb</span><span class="p">,</span>
                    <span class="n">position_cb_to_bodies</span><span class="p">,</span>
                    <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                    <span class="n">radial_distance_cb_to_bodies</span><span class="p">,</span>
                    <span class="n">radial_distance_sc_to_bodies</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_state_dynamics</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">return_intermediaries</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out_dynamics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">dynamics</span> <span class="o">+</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_covariance_dynamics</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">),</span>
                                             <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">position_sc_to_bodies</span><span class="p">),</span> 
                                             <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">radial_distance_sc_to_bodies</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out_dynamics</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;NaN in Dynamics&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_dynamics</span></div>
</div>



<div class="viewcode-block" id="SolRadAndGravityDynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SolRadAndGravityDynamics.html#giant.ufo.dynamics.SolRadAndGravityDynamics">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolRadAndGravityDynamics</span><span class="p">(</span><span class="n">SpiceGravityDynamics</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class adds spherical solar radiation pressure dynamics to the :class:`.SpiceGravityDynamics` class.</span>

<span class="sd">    Everything is the same except the solar radiation pressure is added to the :attr:`State` vector and the</span>
<span class="sd">    dynamics for the solar radiation pressure are added to the appropriate methods.</span>

<span class="sd">    The solar radiation pressure is modelled as a cannonball model</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{a}_{sr}=\frac{C_rA\Phi}{cmd_{sun}**2}\hat{\mathbf{s}}</span>

<span class="sd">    where :math:`C_r` is the radiation pressure coefficient, :math:`A` is the cross sectional area in meters</span>
<span class="sd">    squared, :math:`\Phi` the the solar constant at 1 AU in kW/m**2, :math:`c` is the speed of light in m/s**2,</span>
<span class="sd">    :math:`m` is the mass of the spacecraft in kg, :math:`d_{sun}` is the distance from the sun in AU, and</span>
<span class="sd">    :math:`\hat{\mathbf{s}}` is the unit vector from the sun to the spacecraft.</span>

<span class="sd">    Because this is not intended to be a high fidelity model we combine :math:`\frac{C_rA}{m} into a single parameter</span>
<span class="sd">    ``cram`` that is estimated in the filter.  If you want to back out one of the parameters from this estimated value,</span>
<span class="sd">    you must hold 2 of them fixed and then perform the arithmetic to get your answer.</span>

<span class="sd">    For more details on using this class, see the :class:`.SpiceGravityDynamics` documentation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">State</span><span class="p">(</span><span class="n">SpiceGravityDynamics</span><span class="o">.</span><span class="n">State</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This extends the default State class to also contain the cram parameter for solar radiation pressure.</span>

<span class="sd">        See the default :class:`.Dynamics.State` class documentation for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cram</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The estimated portion of the solar radiation pressure model.</span>
<span class="sd">        </span>
<span class="sd">        This is equivalent to</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            cram=\frac{C_rA}{m}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">length</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The length of the state vector for this representation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This property returns a list of arrays that can be concatenated together to form the state vector.</span>

<span class="sd">            Therefore, you can do ``np.concatenate(state_instance.vector)`` to get a 1D array of the state vector.</span>

<span class="sd">            This is done so that subclasses can override the order if they so choose.</span>

<span class="sd">            :return: a list of numpy arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">vector</span>

            <span class="c1"># add in the cram before the covariance</span>
            <span class="n">out</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cram</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">out</span>

        <span class="nd">@vector</span><span class="o">.</span><span class="n">setter</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cram</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_update</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform an additive update to ``self``.</span>

<span class="sd">            This method updates ``self`` by adding the input update to ``self``.</span>

<span class="sd">            This is used inside of the :class:`.ExtendedKalmanFilter` to apply the update to the state vector from a</span>
<span class="sd">            processed measurement.  The ``state_update`` input will be a 1d numpy array the same length as the state</span>
<span class="sd">            vector (``len(self)``).</span>

<span class="sd">            :param state_update: The update vector to add to the state</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">+=</span> <span class="n">state_update</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">+=</span> <span class="n">state_update</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cram</span> <span class="o">+=</span> <span class="n">state_update</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_body</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">process_noise</span><span class="p">:</span> <span class="n">PN_TYPE</span><span class="p">,</span>
                 <span class="n">other_bodies</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">gravity_parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">load_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">minimum_time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param center_body: The center of integration (and the center of the integration frame)</span>
<span class="sd">        :param process_noise: The process noise either as a numpy array of shape 6x6 (constant process noise) or as a</span>
<span class="sd">                              callable object which takes in the current state and time (np.ndarray, float) and outputs</span>
<span class="sd">                              a 6x6 numpy array containing the process noise matrix</span>
<span class="sd">        :param other_bodies: Other bodies whose gravity should be included as a list of body/barycenter names.  If</span>
<span class="sd">                             ``None`` no other bodies will be considered.</span>
<span class="sd">        :param gravity_parameters: A dictionary mapping names to GM values.  If this is ``None`` or it does not provide</span>
<span class="sd">                                   the data for one of the bodies being considered we will try to query this from spice.</span>
<span class="sd">                                   The values should be in km**3/sec**2</span>
<span class="sd">        :param load_data: A boolean flag specifying whether this class should furnsh the required datafiles.  If you</span>
<span class="sd">                          have already loaded files then you should leave this as ``False``.</span>
<span class="sd">        :param minimum_time_step: The minimum time step to allow the integrator to take in seconds.  If ``None`` (or 0)</span>
<span class="sd">                                  then no minimum time step is enforced.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">center_body</span><span class="p">,</span> <span class="n">process_noise</span><span class="p">,</span> <span class="n">other_bodies</span><span class="o">=</span><span class="n">other_bodies</span><span class="p">,</span> <span class="n">gravity_parameters</span><span class="o">=</span><span class="n">gravity_parameters</span><span class="p">,</span>
                         <span class="n">load_data</span><span class="o">=</span><span class="n">load_data</span><span class="p">,</span> <span class="n">minimum_time_step</span><span class="o">=</span><span class="n">minimum_time_step</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">speed_of_light</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.99792458e8</span>  <span class="c1"># m/s</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The speed of light in meters per second</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solar_constant</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1360.8</span>  <span class="c1"># kW/m**2</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The solar constant in kW/m**2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">km_to_au</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mf">149597870.7</span>  <span class="c1"># 1AU/km</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The conversion from kilometers to AU</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SolRadAndGravityDynamics.compute_state_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SolRadAndGravityDynamics.compute_state_dynamics.html#giant.ufo.dynamics.SolRadAndGravityDynamics.compute_state_dynamics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_state_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">et_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="c1"># pyright: ignore[reportIncompatibleMethodOverride]</span>
                               <span class="n">return_intermediaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                                                             <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This computes the dynamics for just the &quot;state&quot; part of the state vector (not the covariance)</span>

<span class="sd">        Optionally this can also return the distance from the CB to the spacecraft, the vectors from the central body to</span>
<span class="sd">        the other bodies, the vectors from the spacecraft to the other bodies, the distances from the central body to</span>
<span class="sd">        the other bodies, and the distances from the other bodies to the spacecraft if ``return_intermediaries`` is</span>
<span class="sd">        ``True``.</span>

<span class="sd">        The first component of the return is always a list of the dynamics for the state vector in order of position,</span>
<span class="sd">        velocity, cram.</span>

<span class="sd">        :param state: The state vector at the current time</span>
<span class="sd">        :param et_time: The ephemeris time</span>
<span class="sd">        :param return_intermediaries: A flag specifying whether to return the intermediate distances/vectors for use</span>
<span class="sd">                                      elsewhere</span>
<span class="sd">        :return: A list containing [dposition/dt, dvelocity/dt, dcram/dt].  Optionally return a second tuple containing</span>
<span class="sd">                 (radial_distance_cb, position_cp_to_bodies, position_sc_to_bodies, radial_distance_cb_to_bodies,</span>
<span class="sd">                 radial_distance_sc_to_bodies, sun_to_sc_position, sun_to_sc_distance)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dynamics</span><span class="p">,</span> <span class="n">intermediaries</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">compute_state_dynamics</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">et_time</span><span class="p">,</span>
                                                                  <span class="n">return_intermediaries</span><span class="o">=</span><span class="n">return_intermediaries</span><span class="p">)</span>

        <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_bodies</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;sun&#39;</span> <span class="ow">in</span> <span class="n">others</span> <span class="ow">and</span> <span class="n">return_intermediaries</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">others</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;sun&#39;</span><span class="p">)</span>

            <span class="n">sun_direction</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">intermediaries</span><span class="p">[</span><span class="mi">2</span><span class="p">])[</span><span class="n">location</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sun_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">intermediaries</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="n">location</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sun_direction</span> <span class="o">=</span> <span class="n">state</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">spice</span><span class="o">.</span><span class="n">spkpos</span><span class="p">(</span><span class="s1">&#39;sun&#39;</span><span class="p">,</span> <span class="n">et_time</span><span class="p">,</span> <span class="s1">&#39;J2000&#39;</span><span class="p">,</span> <span class="s1">&#39;LT+S&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_body</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sun_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sun_direction</span><span class="p">))</span>

        <span class="n">sun_direction</span> <span class="o">/=</span> <span class="n">sun_distance</span>
        <span class="n">sun_distance</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">km_to_au</span>

        <span class="n">dynamics</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_solar_radiation_acceleration</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">sun_direction</span><span class="p">,</span> <span class="n">sun_distance</span><span class="p">)</span>

        <span class="n">dynamics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="n">return_intermediaries</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">dynamics</span><span class="p">,</span> <span class="n">intermediaries</span> <span class="o">+</span> <span class="p">(</span><span class="n">sun_direction</span><span class="p">,</span> <span class="n">sun_distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dynamics</span><span class="p">,</span> <span class="p">()</span></div>


<div class="viewcode-block" id="SolRadAndGravityDynamics.compute_solar_radiation_acceleration">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SolRadAndGravityDynamics.compute_solar_radiation_acceleration.html#giant.ufo.dynamics.SolRadAndGravityDynamics.compute_solar_radiation_acceleration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_solar_radiation_acceleration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                             <span class="n">direction_sun_to_sc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                             <span class="n">distance_sun_to_sc</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This computes the acceleration due to the solar radiation pressure on the spacecraft assuming a cannonball model</span>
<span class="sd">        in km/s**2.</span>

<span class="sd">        :param state:  The state vector</span>
<span class="sd">        :param direction_sun_to_sc: The position vector from the sun to the spacecraft</span>
<span class="sd">        :param distance_sun_to_sc: The distance from the sun to the spacecraft in AU</span>
<span class="sd">        :return: The solar radiation acceleration in km/s**2 as a numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">solar_constant</span><span class="o">/</span><span class="p">(</span><span class="n">distance_sun_to_sc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">direction_sun_to_sc</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">speed_of_light</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span></div>


    <span class="c1"># noinspection PyMethodOverriding</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_d_acceleration_d_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="c1"># pyright: ignore[reportIncompatibleMethodOverride]</span>
                                           <span class="n">position_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                           <span class="n">radial_distance_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                           <span class="n">direction_sun_to_sc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                           <span class="n">distance_sun_to_sc</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returns the Jacobian of the acceleration with respect to the position vector as a 3x3 numpy array.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \frac{\partial\mathbf{a}_G}{\partial\mathbf{x}_{pos}}=\mu_{cb}</span>
<span class="sd">            \left(\frac{3}{d_{cb2sc}**5}\mathbf{x}_{pos}\mathbf{x}_{pos}^T -</span>
<span class="sd">            \frac{\mathbf{I}_{3\times 3}}{d_{cb2sc}**3}\right) -</span>
<span class="sd">            \sum_{bod}\left(\mu_{bod}\left(\frac{3}{d_{sc2bod}**5}\mathbf{x_{pos,sc2bod}\mathbf{x_{pos,sc2bod}^T-</span>
<span class="sd">            \frac{\mathbf{I}_{3\times 3}}{d_{sc2bod})</span>


<span class="sd">        :param state: The state vector at the current time</span>
<span class="sd">        :param radial_distance_cb: The distance from the central body to the body we are estimating</span>
<span class="sd">        :param position_sc_to_bodies: The position from the spacecraft to the other bodies considered for gravity</span>
<span class="sd">        :param radial_distance_sc_to_bodies: The distance from the spacecraft to the other bodies</span>
<span class="sd">        :param direction_sun_to_sc: The unit direction vector from the sun to the spacecraft</span>
<span class="sd">        :param distance_sun_to_sc: The distance between the sun and the sc at the current time in units of AU</span>
<span class="sd">        :return: The jacobian of the acceleration with respect to the state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d_distance_sun_to_sc_2_d_r_cb_to_sc</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">km_to_au</span><span class="o">*</span><span class="n">direction_sun_to_sc</span><span class="o">*</span><span class="n">distance_sun_to_sc</span>

        <span class="n">d_direction_sun_to_sc_d_r_cp_to_sc</span> <span class="o">=</span> <span class="p">(</span><span class="n">_I3</span><span class="o">/</span><span class="n">distance_sun_to_sc</span> <span class="o">-</span>
                                              <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction_sun_to_sc</span><span class="p">,</span> <span class="n">direction_sun_to_sc</span><span class="o">*</span><span class="n">distance_sun_to_sc</span><span class="p">)</span> <span class="o">/</span>
                                              <span class="n">distance_sun_to_sc</span><span class="p">)</span>

        <span class="n">dasr_dpos</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">solar_constant</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed_of_light</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
                <span class="n">d_direction_sun_to_sc_d_r_cp_to_sc</span><span class="o">/</span><span class="n">distance_sun_to_sc</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction_sun_to_sc</span><span class="p">,</span> <span class="n">d_distance_sun_to_sc_2_d_r_cb_to_sc</span><span class="p">)</span><span class="o">/</span><span class="n">distance_sun_to_sc</span><span class="o">**</span><span class="mi">4</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_compute_d_acceleration_d_position</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">,</span> <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                                                          <span class="n">radial_distance_sc_to_bodies</span><span class="p">)</span> <span class="o">+</span> <span class="n">dasr_dpos</span>

<div class="viewcode-block" id="SolRadAndGravityDynamics.compute_covariance_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SolRadAndGravityDynamics.compute_covariance_dynamics.html#giant.ufo.dynamics.SolRadAndGravityDynamics.compute_covariance_dynamics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_covariance_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">et_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="c1"># pyright: ignore[reportIncompatibleMethodOverride]</span>
                                    <span class="n">position_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                    <span class="n">radial_distance_sc_to_bodies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                                    <span class="n">direction_sun_to_sc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                    <span class="n">distance_sun_to_sc</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the dynamics for the covariance matrix.</span>

<span class="sd">        The dynamics for the covariance matrix is the product of the Jacobian matrix of the dynamics for the state with</span>
<span class="sd">        respect to the state and the current covariance matrix, plus the process noise matrix</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{\partial \mathbf{P}}{\partial t} = \mathbf{J}\mathbf{P} + \mathbf{P}\mathbf{J}^T + \mathbf{Q}</span>

<span class="sd">        where :math:`\mathbf{P}` is the covariance matrix, :math:`t` is time,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J}=\frac{\partial \mathbf{f}(\mathbf{x})}{\partial\mathbf{x}}</span>

<span class="sd">        with :math:`\mathbf{J}` being the Jacobian matrix, :math:`\mathbf{f}(\mathbf{x})` is the state dynamics</span>
<span class="sd">        function, and :math:`\mathbf{x}` is the state vector.</span>

<span class="sd">        :param state: The state vector at the current time</span>
<span class="sd">        :param et_time: The ephemeris time</span>
<span class="sd">        :param radial_distance_cb: The distance from the central body to the body we are estimating</span>
<span class="sd">        :param position_sc_to_bodies: The position from the spacecraft to the other bodies considered for gravity</span>
<span class="sd">        :param radial_distance_sc_to_bodies: The distance from the spacecraft to the other bodies</span>
<span class="sd">        :param direction_sun_to_sc: The unit direction vector from the sun to the spacecraft</span>
<span class="sd">        :param distance_sun_to_sc: The distance between the sun and the sc at the current time in units of AU</span>
<span class="sd">        :return: The covariance time derivative.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">jacobian</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">_I3</span>
        <span class="n">jacobian</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_d_acceleration_d_position</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">,</span>
                                                                    <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                                                                    <span class="n">radial_distance_sc_to_bodies</span><span class="p">,</span>
                                                                    <span class="n">direction_sun_to_sc</span><span class="p">,</span> <span class="n">distance_sun_to_sc</span><span class="p">)</span>

        <span class="n">jacobian</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_constant</span><span class="o">*</span><span class="n">direction_sun_to_sc</span><span class="o">/</span><span class="n">distance_sun_to_sc</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">speed_of_light</span><span class="o">/</span><span class="mi">10000</span>

        <span class="n">covariance</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">pn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_noise</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">et_time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">jacobian</span> <span class="o">@</span> <span class="n">covariance</span> <span class="o">+</span> <span class="n">covariance</span> <span class="o">@</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">pn</span></div>


<div class="viewcode-block" id="SolRadAndGravityDynamics.compute_dynamics">
<a class="viewcode-back" href="../../../ufo/dynamics/giant.ufo.dynamics.SolRadAndGravityDynamics.compute_dynamics.html#giant.ufo.dynamics.SolRadAndGravityDynamics.compute_dynamics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the dynamics for the state vector</span>

<span class="sd">        The dynamics are returned as a 1d array of length 56.  It gives the time derivative of the state vector.</span>

<span class="sd">        The first 6 elements of the dynamics array are the position and velocity components of the state vector</span>
<span class="sd">        respectively.  The next element is cram. The last 49 elements are the dynamics of the covariance matrix</span>
<span class="sd">        raveled in c-order.</span>

<span class="sd">        :param time: the time at which the dynamics are to be computed in ephemeris seconds since J2000</span>
<span class="sd">        :param state: The state vector to compute the dynamics for</span>
<span class="sd">        :return: The time derivative of the state vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_time_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_time_step</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The time step is too small&#39;</span><span class="p">)</span>

        <span class="n">dynamics</span><span class="p">,</span>  <span class="p">(</span><span class="n">radial_distance_cb</span><span class="p">,</span>
                    <span class="n">position_cb_to_bodies</span><span class="p">,</span>
                    <span class="n">position_sc_to_bodies</span><span class="p">,</span>
                    <span class="n">radial_distance_cb_to_bodies</span><span class="p">,</span>
                    <span class="n">radial_distance_sc_to_bodies</span><span class="p">,</span>
                    <span class="n">sun_direction</span><span class="p">,</span> <span class="n">sun_distance</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_state_dynamics</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">return_intermediaries</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out_dynamics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">dynamics</span> <span class="o">+</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_covariance_dynamics</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">radial_distance_cb</span><span class="p">),</span>
                                             <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">position_sc_to_bodies</span><span class="p">),</span> 
                                             <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">radial_distance_sc_to_bodies</span><span class="p">),</span>
                                             <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sun_direction</span><span class="p">),</span> 
                                             <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">sun_distance</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out_dynamics</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;NaN in Dynamics&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_dynamics</span></div>
</div>



<span class="c1"># TODO: Provide a monte dynamics interface at some point...</span>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>