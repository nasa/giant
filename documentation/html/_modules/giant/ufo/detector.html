
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.ufo.detector &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.ufo.detector</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 United States Government as represented by the Administrator of the National Aeronautics and Space</span>
<span class="c1"># Administration.  No copyright is claimed in the United States under Title 17, U.S. Code. All Other Rights Reserved.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a class for identifying possible unresolved UFOs in a monocular image.</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">UFO identification is done through the usual :mod:`.stellar_opnav` process, but instead of being concerned with the</span>
<span class="sd">identified stars, we are concerned with the points that were not matched to stars in the image.  As such, the</span>
<span class="sd">:class:`.Detector` class provided in this module simply serves as a wrapper around the :class:`.StellarOpNav` class</span>
<span class="sd">to combine some steps together and to collect all of the unidentified results and package them into a manageable format.</span>
<span class="sd">For a more detailed description of what happens you can refer to the paper at</span>
<span class="sd">https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019EA000843</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">To identify potential UFOs, simply initialize the :class:`.Detector` class with the required inputs, then call</span>
<span class="sd">:meth:`.update_attitude` to estimate the updated attitude of the images (which can be important when trying to identify</span>
<span class="sd">dim detections), :meth:`.find_ufos` to identify possible ufos in the images, :meth:`.package_results` to package all of</span>
<span class="sd">the detections into a dataframe and to compute some extra information about each detection, and</span>
<span class="sd">:meth:`remove_duplicates` which attempts to identify points were we accidentally identified the same point twice (which</span>
<span class="sd">can happen when 2 detection are very close together).  Once you have called these methods, you can call</span>
<span class="sd">:meth:`.Detector.save_results` to dump the results to (a) csv file(s).</span>

<span class="sd">For discussion on Tuning for successful UFO identification, refer to the :mod:`.ufo` package documentation.</span>

<span class="sd">You may also be interested in using the :class:`.UFO` class which combines both detection and tracking into a single</span>
<span class="sd">interface rather than using this class directly.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">cv2</span>

<span class="kn">from</span> <span class="nn">giant.stellar_opnav.stellar_class</span> <span class="kn">import</span> <span class="n">StellarOpNav</span>
<span class="kn">from</span> <span class="nn">giant.point_spread_functions.gaussians</span> <span class="kn">import</span> <span class="n">IterativeGeneralizedGaussianWBackground</span>

<span class="kn">from</span> <span class="nn">giant.catalogues.utilities</span> <span class="kn">import</span> <span class="n">unit_to_radec</span><span class="p">,</span> <span class="n">RAD2DEG</span><span class="p">,</span> <span class="n">radec_to_unit</span><span class="p">,</span> <span class="n">radec_distance</span><span class="p">,</span> <span class="n">DEG2RAD</span>
<span class="kn">from</span> <span class="nn">giant.utilities.spice_interface</span> <span class="kn">import</span> <span class="n">datetime_to_et</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.rays</span> <span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.scene</span> <span class="kn">import</span> <span class="n">Scene</span>

<span class="kn">from</span> <span class="nn">giant.image</span> <span class="kn">import</span> <span class="n">OpNavImage</span>

<span class="kn">from</span> <span class="nn">giant._typing</span> <span class="kn">import</span> <span class="n">Real</span><span class="p">,</span> <span class="n">SCALAR_OR_ARRAY</span><span class="p">,</span> <span class="n">PATH</span><span class="p">,</span> <span class="n">ARRAY_LIKE_2D</span>


<span class="n">_LOGGER</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is the logging interface for reporting status, results, issues, and other information.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="unit_to_radec_jacobian"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.unit_to_radec_jacobian.html#giant.ufo.detector.unit_to_radec_jacobian">[docs]</a><span class="k">def</span> <span class="nf">unit_to_radec_jacobian</span><span class="p">(</span><span class="n">unit</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the Jacobian matrix for going from a unit vector to a right ascension/declination in degrees.</span>

<span class="sd">    Mathematically this is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{\partial (\alpha, \delta)}{\partial \hat{\mathbf{x}}} = \frac{180}{\pi}\left[\begin{array}{ccc}</span>
<span class="sd">        -\frac{y}{x**2+y**2} &amp; \frac{x}{x**2+y**2} &amp; 0 \\</span>
<span class="sd">        0 &amp; \frac{1}{\sqrt{1-z**2) &amp; 0 \end{array}\right]</span>

<span class="sd">    This function is vectorized so that multiple jacobians can be computed at once.  In this case the unit vectors in</span>
<span class="sd">    the input should be a shape of 3xn where n is the number of unit vectors and the output will be nx2x3.</span>

<span class="sd">    :param unit: The unit vectors to compute the jacobian for as a numpy array</span>
<span class="sd">    :return: the nx2x3 jacobian matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure we have the right shape</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># initialize the jacobian matrix</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">unit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c1"># compute the jacobian elements</span>
    <span class="n">out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">unit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">unit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>


<span class="n">_IMAGE_INFORMATION_SIGNATURE</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">OpNavImage</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">SCALAR_OR_ARRAY</span><span class="p">]]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This specifies the call signature that the image information function is expected to have.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">_MAGNITUDE_FUNCTION_SIGNATURE</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">OpNavImage</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This specifies the call signature that the magnitude function is expected to have..</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Detector"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.html#giant.ufo.detector.Detector">[docs]</a><span class="k">class</span> <span class="nc">Detector</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to identify possible non-cooperative unresolved targets in optical images.</span>

<span class="sd">    This is done by first extracting bright points from the image, then fitting point spread functions to the bright</span>
<span class="sd">    spots in an image, and finally removing bright points that correspond to stars.  All of this is primarily handled by</span>
<span class="sd">    the :class:.StellarOpNav` class, and this class serves as a wrapper for collecting data from the</span>
<span class="sd">    :class:`.StellarOpNav` class and for packaging each possible detection (with additional information) into a pandas</span>
<span class="sd">    Dataframe for easy export/processing.</span>

<span class="sd">    To use this class simply provide the required initialization inputs, call :meth:`update_attitude`, call</span>
<span class="sd">    :meth:`find_ufos`, call :meth:`package_results`, call :meth:`remove_duplicates`, and then optionally call</span>
<span class="sd">    :meth:`save_results` to save the results to a csv file.</span>

<span class="sd">    For more details on tuning for detection and the full UFO process, including tacking, see the :mod:`.ufo`</span>
<span class="sd">    package documentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sopnav</span><span class="p">:</span> <span class="n">StellarOpNav</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Scene</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dn_offset</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">image_information_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_IMAGE_INFORMATION_SIGNATURE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">magnitude_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_MAGNITUDE_FUNCTION_SIGNATURE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">update_attitude_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">find_ufos_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">unmatched_star_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">hot_pixel_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                 <span class="n">create_hashed_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sopnav: The stellar opnav instance that will be used for star and UFO identification/attitude estimation</span>
<span class="sd">        :param scene: The optional scene instance defining the location of the light source and any extended bodies</span>
<span class="sd">        :param dn_offset: The dn offset of the detector, used for computing magnitude/statistics about the observed UFO</span>
<span class="sd">        :param image_information_function: A function that gives the quantization noise, read noise, and electron to DN</span>
<span class="sd">                                           conversion factor for the detector and predicts the dark current for a</span>
<span class="sd">                                           input :class:`.OpNavImage` object (or None).  If None then the SNR values</span>
<span class="sd">                                           will be less meaningful.</span>
<span class="sd">        :param magnitude_function: A function that computes the apparent magnitude for detections based off of the input</span>
<span class="sd">                                   5x5 summed DN for the detections and the image the detection came from.  If ``None``</span>
<span class="sd">                                   then the magnitude will not be computed and will be stored as 0 for all detections.</span>
<span class="sd">        :param update_attitude_kwargs: A dictionary of str -&gt; dictionary where the keys are &quot;star_id_kwargs&quot;,</span>
<span class="sd">                                       &quot;image_processing_kwargs&quot;, or &quot;attitude_estimator_kwargs&quot; and the values are</span>
<span class="sd">                                       dictionaries specifying the key word argument -&gt; value pairs for the appropriate</span>
<span class="sd">                                       class.  This is used to update the settings before attempting to solve for the</span>
<span class="sd">                                       attitude in each image. (:meth:`update_attitude`)</span>
<span class="sd">        :param find_ufos_kwargs: A dictionary of str -&gt; dictionary where the keys are &quot;star_id_kwargs&quot;,</span>
<span class="sd">                                 &quot;image_processing_kwargs&quot;, or &quot;attitude_estimator_kwargs&quot; and the values are</span>
<span class="sd">                                 dictionaries specifying the key word argument -&gt; value pairs for the</span>
<span class="sd">                                 appropriate class.  This is used to update the settings before attempting to</span>
<span class="sd">                                 identify ufos in the image (:meth:`find_ufos`)</span>
<span class="sd">        :param hot_pixel_threshold: The minimum number of images a (x_raw, y_raw) pair must appear in for the detections</span>
<span class="sd">                                    to be labeled a possible hot pixel</span>
<span class="sd">        :param unmatched_star_threshold: The minimum number of images a (ra, dec) pair must appear in for the detections</span>
<span class="sd">                                         to be labeled a possible unmatched star</span>
<span class="sd">        :param create_hashed_index: This boolean flag indicates that when packaging the results</span>
<span class="sd">                                    (:meth:`.package_results`) the index of the resulting dataframe should be build from</span>
<span class="sd">                                    a hash of ``&#39;image_file_{x_raw}_{y_raw}&#39;`` instead of just using an index.  This</span>
<span class="sd">                                    makes it easier to identify the detections uniquely and is recommended to be left</span>
<span class="sd">                                    ``True``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="p">:</span> <span class="n">StellarOpNav</span> <span class="o">=</span> <span class="n">sopnav</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The StellarOpNav instance that will be used for star and UFO identification/attitude estimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Scene</span><span class="p">]</span> <span class="o">=</span> <span class="n">scene</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Scene instance that defines the location of any known extended bodies in the images to use for determining</span>
<span class="sd">        whether the UFOs are part of the target or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dn_offset</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="n">dn_offset</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dn offset of the detector (typically a fixed value that pixels are always guaranteed to be above).</span>
<span class="sd">        </span>
<span class="sd">        This is used to determine the noise level for assigning signal to noise values for each detection </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">image_information_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_IMAGE_INFORMATION_SIGNATURE</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_information_function</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that gives the quantization noise, read noise, and electron to DN conversion factor for the detector </span>
<span class="sd">        and predicts the dark current for an input :class:`.OpNavImage` object.  </span>
<span class="sd">        </span>
<span class="sd">        If None then the SNR values computed herein will be less meaningful.</span>
<span class="sd">        </span>
<span class="sd">        The order of the output should be electrons_to_dn, quantization noise (in elections), read noise (in electrons), </span>
<span class="sd">        dark current (in electrons)</span>
<span class="sd">        </span>
<span class="sd">        The dark current can either be returned as a scalar or as an array the same size as the image (if it is location</span>
<span class="sd">        dependent).</span>
<span class="sd">        </span>
<span class="sd">        The only input to this function will be the :class:`.OpNavImage` that the detector information is to be returned </span>
<span class="sd">        for, which should give the temperature and exposure length (plus possibly the file the image was retrieved from)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_MAGNITUDE_FUNCTION_SIGNATURE</span><span class="p">]</span> <span class="o">=</span> <span class="n">magnitude_function</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that computes the apparent magnitude of a detection given the 5x5 summed DN around the detection and</span>
<span class="sd">        the image the detection came from.</span>
<span class="sd">        </span>
<span class="sd">        If this is ``None`` then the magnitude is not calculated for the detections.  If it is not None, then the </span>
<span class="sd">        results of this function are directly stored in the :attr:`magnitude` and :attr:`Star_observed_magnitude`</span>
<span class="sd">        attributes.  Note that this function should expect to process all of the observations at once.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_attitude_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">update_attitude_kwargs</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary of str -&gt; dictionary where the keys are &quot;star_id_kwargs&quot;, &quot;image_processing_kwargs&quot;, or </span>
<span class="sd">        &quot;attitude_estimator_kwargs&quot; and the values are dictionaries specifying the key word argument -&gt; value pairs for </span>
<span class="sd">        the appropriate class.  </span>
<span class="sd">        </span>
<span class="sd">        This is used to update the settings before attempting to solve for the attitude in each image. </span>
<span class="sd">        (:meth:`update_attitude`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">find_ufos_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">find_ufos_kwargs</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary of str -&gt; dictionary where the keys are &quot;star_id_kwargs&quot;, &quot;image_processing_kwargs&quot;, or </span>
<span class="sd">        &quot;attitude_estimator_kwargs&quot; and the values are dictionaries specifying the key word argument -&gt; value pairs for </span>
<span class="sd">        the appropriate class.  </span>

<span class="sd">        This is used to update the settings before attempting to identify the UFOs in each image. </span>
<span class="sd">        (:meth:`find_ufos`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hot_pixel_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">hot_pixel_threshold</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum number of images the same (x_raw, y_raw) pairs must be identified in before detections are labeled </span>
<span class="sd">        as possible hot pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_star_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">unmatched_star_threshold</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum number of images the same (ra, dec) pairs must be identified in before detections are labeled </span>
<span class="sd">        as possible unmatched stars.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_hashed_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">create_hashed_index</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This boolean flag indicates that when packaging the results (:meth:`.package_results`) the index of the </span>
<span class="sd">        resulting dataframe should be build from a hash of ``&#39;image_file_{x_raw}_{y_raw}&#39;`` instead of just using an </span>
<span class="sd">        index. </span>
<span class="sd">        </span>
<span class="sd">        This makes it easier to identify the detections uniquely and is recommended to be left ``True`` </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is where the big dataframe of the detections will be stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_images</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a list of images that are identified as invalid because they have no bright spots identified in them</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the sum of the 5x5 grid of pixel DN values minus the background around each </span>
<span class="sd">        UFO.</span>
<span class="sd">        </span>
<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the computed magnitude of each UFO .</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2_value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the Chi2 value from the post-fit residuals for each ufo.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf_uncertainty</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty of the integrated PSF value for each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_uncertainty</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty of the integrated PSF value for each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">saturated</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store a flag specifying whether each UFO has saturated pixels or not.</span>
<span class="sd">        </span>
<span class="sd">        If a flag is ``True`` then the UFO did contain at least 1 pixel that was saturated.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_count</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the number of pixels summed for computing the summed dn for each UFO.</span>

<span class="sd">        This is nearly always 25 (for a 5x5 grid) but occasionally for points near the edge it may be less.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_dn</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the maximum DN value for each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bearing</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store inertial bearing of each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the integrated PSF values for each UFO</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ra_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the right-ascension component of the bearing in degrees for </span>
<span class="sd">        each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">declination_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the declination component of the bearing in degrees for </span>
<span class="sd">        each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_raw_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the x pixel location for each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">y_raw_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the y pixel location for each UFO.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">occulting</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the locations where UFOs are in front of any dark portions of any extended bodies.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">saturation_distance</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the minimum distance between the centroid of each UFO and the nearest saturated pixel</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trail_length</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the approximate length of the trail of each UFO  in pixels (if the detection is </span>
<span class="sd">        trailed)</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trail_principal_angle</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the approximate principal angle for each UFO that is trailed in degrees.</span>
<span class="sd">        </span>
<span class="sd">        The principal angle is the angle between the +x axis and the principal axis of the skewed PSF.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the sum of the 5x5 grid of pixel DN values minus the background around each </span>
<span class="sd">        matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_observed_magnitude</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the computed magnitude of each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_count</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the number of pixels summed for computing the summed dn for each matched star.</span>

<span class="sd">        This is nearly always 25 (for a 5x5 grid) but occasionally for points near the edge it may be less.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_max_dn</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Real</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the maximum DN value for each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_bearing</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store inertial bearing of each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the integrated PSF values for each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_ra_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the right-ascension component of the bearing in degrees for </span>
<span class="sd">        each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_declination_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the declination component of the bearing in degrees for </span>
<span class="sd">        each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_x_raw_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the x pixel location for each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_y_raw_sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty on the y pixel location for each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_occulting</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the locations where matched stars are in front of any dark portions of any extended </span>
<span class="sd">        bodies.</span>
<span class="sd">        </span>
<span class="sd">        This obviously shouldn&#39;t be true so if any are then they may be actual detections</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_saturation_distance</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the minimum distance between the centroid of each matched star and the nearest </span>
<span class="sd">        saturated pixel</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf_uncertainty</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty of the integrated PSF value for each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_uncertainty</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the formal uncertainty of the integrated PSF value for each matched star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_saturated</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store a flag specifying whether each matched star has saturated pixels or not.</span>

<span class="sd">        If a flag is ``True`` then the UFO did contain at least 1 pixel that was saturated.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_fit_chi2_value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list is used to store the Chi2 value from the post-fit residuals for each star.</span>

<span class="sd">        Until :meth:`package_results` is called this will be filled with ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_delta_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These specify the pixels around the center of each detection that we consider in summing by default</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of flags specifying whether the images need processed or not</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Detector.update_attitude"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.update_attitude.html#giant.ufo.detector.Detector.update_attitude">[docs]</a>    <span class="k">def</span> <span class="nf">update_attitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates the attitude for each turned on image in the camera.</span>

<span class="sd">        This is done through the usual process.  First the settings for the :attr:`.StellarOpNav.star_id``, `</span>
<span class="sd">        :attr:`.StellarOpNav.attitude_estimator`, and :attr:`.StellarOpNav.image_processing` attributes are updated</span>
<span class="sd">        according to the settings saved in :attr:`update_attitude_kwargs`. Then the stars are identified using</span>
<span class="sd">        :meth:`.StellarOpNav.id_stars`.  Finally, the attitude is estimated using</span>
<span class="sd">        :meth:`.StellarOpNav.estimate_attitude`.  All of the results are stored into the :attr:`sopnav` attribute as</span>
<span class="sd">        usual.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Updating settings for star identification&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">update_star_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_attitude_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;star_id_kwargs&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">update_image_processing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_attitude_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;image_processing_kwargs&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">update_attitude_estimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_attitude_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attitude_estimator_kwargs&#39;</span><span class="p">))</span>

        <span class="c1"># Identify stars</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Identifying Stars...&#39;</span><span class="p">)</span>
        <span class="c1"># only process images that we need to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">process_stars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">id_stars</span><span class="p">()</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">)</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Updating Attitude...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">estimate_attitude</span><span class="p">()</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Detector.find_ufos"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.find_ufos.html#giant.ufo.detector.Detector.find_ufos">[docs]</a>    <span class="k">def</span> <span class="nf">find_ufos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method finds unidentified bright spots (not matching a star or an extended body) in the images turned on in</span>
<span class="sd">        the  camera.</span>

<span class="sd">        This is done by updating the :attr:`.StellarOpNav.star_id` and :attr:`.StellarOpNav.image_processing` attributes</span>
<span class="sd">        using the settings saved in :attr:`find_ufos_kwargs`.  Then :meth:`.StellarOpNav.id_stars` is called to identify</span>
<span class="sd">        the UFOs.  The results are stored in the ``unmatched_*`` attributes of the :attr:`sopnav` attribute.</span>

<span class="sd">        To get a summary of UFOs/stars with more information about them call :meth:`package_results` after calling this</span>
<span class="sd">        method.  Typically you should call :meth:`update_attitude` before calling this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Updating settings for ufo identification&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">update_star_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_ufos_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;star_id_kwargs&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">update_image_processing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_ufos_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;image_processing_kwargs&#39;</span><span class="p">))</span>

        <span class="c1"># only process images that we need to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">process_stars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Identifying UFOs...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">id_stars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span></div>

<div class="viewcode-block" id="Detector.package_results"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.package_results.html#giant.ufo.detector.Detector.package_results">[docs]</a>    <span class="k">def</span> <span class="nf">package_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method packages information about UFOs (and matched stars) into attributes in this class and as a Pandas</span>
<span class="sd">        DataFrame that can be stored to any number of table formats.</span>

<span class="sd">        You should have called :meth:`find_ufos` before calling this method.</span>

<span class="sd">        Specifically, the results for UFOs are stored into</span>

<span class="sd">        - :attr:`bearing`</span>
<span class="sd">        - :attr:`ra_sigma`</span>
<span class="sd">        - :attr:`declination_sigma`</span>
<span class="sd">        - :attr:`fit_chi2_value`</span>
<span class="sd">        - :attr:`integrated_psf`</span>
<span class="sd">        - :attr:`integrated_psf_uncertainty`</span>
<span class="sd">        - :attr:`invalid_images`</span>
<span class="sd">        - :attr:`magnitude`</span>
<span class="sd">        - :attr:`max_dn`</span>
<span class="sd">        - :attr:`occulting`</span>
<span class="sd">        - :attr:`saturated`</span>
<span class="sd">        - :attr:`saturation_distance`</span>
<span class="sd">        - :attr:`summed_dn`</span>
<span class="sd">        - :attr:`summed_dn_count`</span>
<span class="sd">        - :attr:`summed_dn_uncertainty`</span>
<span class="sd">        - :attr:`trail_length`</span>
<span class="sd">        - :attr:`trail_principal_angle`</span>
<span class="sd">        - :attr:`x_raw_sigma`</span>
<span class="sd">        - :attr:`y_raw_sigma`</span>
<span class="sd">        - :attr: `.StellarOpNav.unmatched_extracted_image_points`</span>
<span class="sd">        - :attr: `.StellarOpNav.unmatched_stats`</span>
<span class="sd">        - :attr: `.StellarOpNav.unmatched_psfs`</span>
<span class="sd">        - :attr: `.StellarOpNav.unmatched_snrs`</span>
<span class="sd">        - :attr: `.StellarOpNav.unmatched_snrs`</span>

<span class="sd">        In addition, the results for matched stars are stored into</span>
<span class="sd">        - :attr:`star_bearing`</span>
<span class="sd">        - :attr:`star_ra_sigma`</span>
<span class="sd">        - :attr:`star_declination_sigma`</span>
<span class="sd">        - :attr:`star_fit_chi2_value`</span>
<span class="sd">        - :attr:`star_integrated_psf`</span>
<span class="sd">        - :attr:`star_integrated_psf_uncertainty`</span>
<span class="sd">        - :attr:`invalid_images`</span>
<span class="sd">        - :attr:`star_observed_magnitude`</span>
<span class="sd">        - :attr:`star_max_dn`</span>
<span class="sd">        - :attr:`star_occulting`</span>
<span class="sd">        - :attr:`star_saturated`</span>
<span class="sd">        - :attr:`star_saturation_distance`</span>
<span class="sd">        - :attr:`star_summed_dn`</span>
<span class="sd">        - :attr:`star_summed_dn_count`</span>
<span class="sd">        - :attr:`star_summed_dn_uncertainty`</span>
<span class="sd">        - :attr:`star_x_raw_sigma`</span>
<span class="sd">        - :attr:`star_y_raw_sigma`</span>
<span class="sd">        - :attr: `.StellarOpNav.matched_extracted_image_points`</span>
<span class="sd">        - :attr: `.StellarOpNav.matched_stats`</span>
<span class="sd">        - :attr: `.StellarOpNav.matched_psfs`</span>
<span class="sd">        - :attr: `.StellarOpNav.matched_snrs`</span>
<span class="sd">        - :attr: `.StellarOpNav.matched_snrs`</span>

<span class="sd">        Both star and UFO results are stored into a dataframe at :attr:`detection_data_frame` with Columns of</span>

<span class="sd">        ===================== ==========================================================================================</span>
<span class="sd">        Column                Description</span>
<span class="sd">        ===================== ==========================================================================================</span>
<span class="sd">        image_file            The file name of the image the detection came from as a string</span>
<span class="sd">        mid_exposure_utc      The mid exposure time in UTC as a datetime</span>
<span class="sd">        mid_exposure_et       The mid exposure time in ET seconds since J2000 as a float</span>
<span class="sd">        x_raw                 The x-sub-pixel (column) location of the centroid of the detection as a float</span>
<span class="sd">        y_raw                 The y-sub-pixel (column) location of the centroid of the detection as a float</span>
<span class="sd">        x_raw_sigma           The x-sub-pixel location of the centroid of the detection formal uncertainty in pixels as</span>
<span class="sd">                              a float</span>
<span class="sd">        y_raw_sigma           The y-sub-pixel location of the centroid of the detection formal uncertainty in pixels as</span>
<span class="sd">                              a float</span>
<span class="sd">        ra                    The right ascension of the detection in the inertial frame in degrees as a float.  Note</span>
<span class="sd">                              that this is the direction from the camera to the detection in inertial space, **not** the</span>
<span class="sd">                              location of the detection in the celestial sphere.</span>
<span class="sd">        dec                   The declination of the detection in the inertial frame in degrees as a float.  Note</span>
<span class="sd">                              that this is the direction from the camera to the detection in inertial space, **not** the</span>
<span class="sd">                              location of the detection in the celestial sphere.</span>
<span class="sd">        ra_sigma              The formal uncertainty on the RA of the detection in units of degrees as a float</span>
<span class="sd">        dec_sigma             The formal uncertainty on the declination of the detection in units of degrees as a float</span>
<span class="sd">        area                  The area of the detection (number of pixels above the specified threshold) as an integer</span>
<span class="sd">        peak_dn               The maxim DN value of the detection (minus the background term) as a float</span>
<span class="sd">        summed_dn             The sum of the (normally) 5x5 grid of pixels surrounding the centroid of the detection in</span>
<span class="sd">                              DN as a float</span>
<span class="sd">        summed_dn_sigma       The formal uncertainty of the summed dn value in DN as a float.  This is based off of the</span>
<span class="sd">                              expected noise of the pixels where the detection was found at.</span>
<span class="sd">        n_pix_summed          The number of pixels summed as an integer. This will nearly always be 25, unless the</span>
<span class="sd">                              detection was very close to the edge of the image</span>
<span class="sd">        integrated_psf        The value of the integrated fit PSF for the detection in DN as a float.</span>
<span class="sd">        integrated_psf_sigma  The formal uncertainty of the integrated fit PSF for the detection in DN as a float</span>
<span class="sd">        magnitude             The computed apparent magnitude of the detector or 0, if no :attr:`magnitude_function` was</span>
<span class="sd">                              given</span>
<span class="sd">        snr                   The signal to noise ratio of the detection</span>
<span class="sd">        psf                   The fit point spread function for the detection as a string</span>
<span class="sd">        psf_fit_quality       The quality of the PSF fit as a chi**2 parameter as a float</span>
<span class="sd">        occulting             A boolean flag specifying whether this detection is between the camera and the dark region</span>
<span class="sd">                              of an extended body</span>
<span class="sd">        saturation_distance   The distance between the centroid of this detection and the nearest blob of pixels with at</span>
<span class="sd">                              least 3 pixels saturated</span>
<span class="sd">        is_saturated          A boolean flag specifying if any of the pixels in the detection are saturated</span>
<span class="sd">        trail_length          The length of the trail of the detection if it is a trailed detection (or 0) in units of</span>
<span class="sd">                              pixels as a float</span>
<span class="sd">        trail_principal_angle The angle between the trail semi-major axis and the direction of increasing right</span>
<span class="sd">                              ascension in the image in units of degrees as a float</span>
<span class="sd">        quality_code          The quality code of the detection.  Attempts to give the detection a quality label of 1-5</span>
<span class="sd">                              with 5 being a detection in which there is strong confidence it is not just a noise spike.</span>
<span class="sd">                              quality codes of 0 indicate detections paired to known stars.  Quality codes of -1</span>
<span class="sd">                              indicate detections that may be hot pixels or un-matched stars.  Quality codes of -1 will</span>
<span class="sd">                              only be present after a call to :meth:`identify_hot_pixels_and_unmatched_stars`.</span>
<span class="sd">        x_inert2cam           The x component of the quaternion that rotates from the inertial frame to the camera frame</span>
<span class="sd">                              at the time of the detection as a float</span>
<span class="sd">        y_inert2cam           The y component of the quaternion that rotates from the inertial frame to the camera frame</span>
<span class="sd">                              at the time of the detection as a float</span>
<span class="sd">        z_inert2cam           The z component of the quaternion that rotates from the inertial frame to the camera frame</span>
<span class="sd">                              at the time of the detection as a float</span>
<span class="sd">        s_inert2cam           The scalar component of the quaternion that rotates from the inertial frame to the camera</span>
<span class="sd">                              frame at the time of the detection as a float</span>
<span class="sd">        star_id               A string given the catalogue ID of the star this detection was matched to (if it was</span>
<span class="sd">                              matched to a star).</span>
<span class="sd">        ===================== ==========================================================================================</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create a counter of how many images we&#39;ve processed</span>
        <span class="n">processed_images</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># loop through each image</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>

            <span class="c1"># get a timer</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Analyzing results for image </span><span class="si">{</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">image_mask</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span><span class="p">[</span><span class="n">ind</span><span class="p">]:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Image </span><span class="si">{</span><span class="n">ind</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="si">}</span><span class="s1"> needs to be processed still&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># update the scene to this time if it is available</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

            <span class="c1"># get the information we need about the detector (if it is available)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_information_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">electrons_to_dn</span><span class="p">,</span> <span class="n">quantization_noise</span><span class="p">,</span> <span class="n">read_noise</span><span class="p">,</span> <span class="n">dark_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_information_function</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">electrons_to_dn</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">quantization_noise</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">read_noise</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">dark_current</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># determine the bright spots in the image as points &gt; 98% saturated</span>
            <span class="n">bright</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">saturation</span> <span class="o">*</span> <span class="mf">0.98</span><span class="p">)</span>

            <span class="c1"># clump bright spots into individual blobs with connected components</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">___</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">connectedComponentsWithStats</span><span class="p">(</span><span class="n">bright</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
                <span class="c1"># filter out areas where the number of saturated pixels is less than 3</span>
                <span class="k">if</span> <span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">bright</span><span class="p">[</span><span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_TOP</span><span class="p">]:(</span><span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_HEIGHT</span><span class="p">]</span> <span class="o">+</span> <span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_TOP</span><span class="p">]),</span>
                           <span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_LEFT</span><span class="p">]:(</span><span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_LEFT</span><span class="p">]</span> <span class="o">+</span> <span class="n">stat</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_WIDTH</span><span class="p">])]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># if there aren&#39;t any bright spots in the image then this image is invalid and likely corrupted, skip it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bright</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;invalid image, skipping&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invalid_images</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>

            <span class="c1"># get the coordinates of the bright spots in the image (where bright is true)</span>
            <span class="n">bright_coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">bright</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># build the catalogue of bright spots</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">bright_tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">bright_coords</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># determine which detections are actually due to the surface of any extended targets in the scene</span>
                <span class="c1"># compute the rays to trace through the scene, one for each unmatched point</span>
                <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="n">directions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
                <span class="p">)</span>

                <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">directions</span><span class="p">)</span>

                <span class="c1"># do a single bounce ray trace from the camera to the body and then to the sun</span>
                <span class="n">illums_inp</span><span class="p">,</span> <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">get_illumination_inputs</span><span class="p">(</span><span class="n">rays</span><span class="p">,</span> <span class="n">return_intersects</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># identify things that are in line with the illuminated portion of the extended targets and throw them</span>
                <span class="c1"># out</span>
                <span class="c1"># anything that has visible set to true means that the object is on the illuminated portion of the</span>
                <span class="c1"># target (at least, where we think the illuminated portion of the targets are)</span>
                <span class="n">test</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">illums_inp</span><span class="p">[</span><span class="s1">&#39;visible&#39;</span><span class="p">]</span>

                <span class="c1"># Now check to see where we intersected the body, but didn&#39;t make it to the sun.  These are points on</span>
                <span class="c1"># the dark side of the targets (occulting).  We are going to throw away the points on the bright side so</span>
                <span class="c1"># we can use ~test here to store only the ones we&#39;ll keep</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">occulting</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">inter</span><span class="p">[</span><span class="o">~</span><span class="n">test</span><span class="p">][</span><span class="s1">&#39;check&#39;</span><span class="p">]</span>

                <span class="c1"># throw out the points that are due to the illuminated targets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_stats</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_stats</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">occulting</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># determine the distance from each remaining point to the nearest saturated pixel in the image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saturation_distance</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bright_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># get the inertial unit vector from the camera through the detection</span>
            <span class="n">inertial_vecs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
            <span class="p">)</span>

            <span class="c1"># compute the right ascension and declination of the unit vectors in degrees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bearing</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unit_to_radec</span><span class="p">(</span><span class="n">inertial_vecs</span><span class="p">))</span> <span class="o">*</span> <span class="n">RAD2DEG</span>

            <span class="c1"># prepare some storage lists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_count</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2_value</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saturated</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">declination_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trail_length</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trail_principal_angle</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># compute the integrated psf DN for each detection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">psf</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">psf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>

            <span class="c1"># compute the jacobian matrix of the unit vector in the camera frame with respect to a change in the</span>
            <span class="c1"># pixel location</span>
            <span class="n">jacobian_pixels_to_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compute_unit_vector_jacobian</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
            <span class="p">)</span>

            <span class="c1"># compute the jacobian matrix of the right ascension and declination with respect to a change in the</span>
            <span class="c1"># unit vector</span>
            <span class="n">jacobian_unit_to_bearing</span> <span class="o">=</span> <span class="n">unit_to_radec_jacobian</span><span class="p">(</span><span class="n">inertial_vecs</span><span class="p">)</span>

            <span class="c1"># compute photometry for each detection</span>
            <span class="c1"># loop through the unmatched points and their psfs</span>
            <span class="n">iterator</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">IterativeGeneralizedGaussianWBackground</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">lind</span><span class="p">,</span> <span class="p">(</span><span class="n">poi</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>

                <span class="c1"># get the indices into the image around the detection, checking that we&#39;re not too close to an edge</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">poi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_row</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">poi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_col</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

                <span class="n">check</span> <span class="o">=</span> <span class="p">((</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cols</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                         <span class="p">(</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cols</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_cols</span><span class="p">))</span>

                <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">check</span><span class="p">]</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">check</span><span class="p">]</span>

                <span class="c1"># check to see if the pixels are saturated so we can set the flag</span>
                <span class="n">dns</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">saturated</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dns</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.98</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">saturation</span><span class="p">)</span>

                <span class="c1"># subtract off the estimated background from the DN values</span>
                <span class="n">bg</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">evaluate_bg</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span>
                <span class="n">dns</span> <span class="o">-=</span> <span class="n">bg</span>

                <span class="c1"># sum the dn, determine the number of pixels included in the sum, and get the max dn in the sub-image</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dns</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_count</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">check</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dns</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

                <span class="c1"># compute the average stray light to be the background minus the detector dn_offset at the center</span>
                <span class="c1"># of the detection</span>
                <span class="n">avg_stray_light</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">evaluate_bg</span><span class="p">(</span><span class="o">*</span><span class="n">psf</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_offset</span>

                <span class="c1"># compute the noise level for the summed DN</span>
                <span class="c1"># compute the square of the shot noise in electrons</span>
                <span class="n">sigma_shot2</span> <span class="o">=</span> <span class="n">dns</span> <span class="o">/</span> <span class="n">electrons_to_dn</span>

                <span class="c1"># compute the sum of the squares of the quantization noise, the read noise,</span>
                <span class="c1"># the noise due to the stray light, and the dark current in electrons</span>
                <span class="n">extra_noise2</span> <span class="o">=</span> <span class="p">(</span><span class="n">quantization_noise</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">read_noise</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">avg_stray_light</span> <span class="o">/</span> <span class="n">electrons_to_dn</span> <span class="o">+</span>
                                <span class="n">dark_current</span><span class="p">)</span>

                <span class="c1"># compute the sum of the squares of the noise terms in electrons</span>
                <span class="n">noise2</span> <span class="o">=</span> <span class="n">sigma_shot2</span> <span class="o">+</span> <span class="n">extra_noise2</span>

                <span class="c1"># get the total noise in the sub-image in units of DN</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise2</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">*</span> <span class="n">electrons_to_dn</span>

                <span class="c1"># compute and store the signal to noise ratio for the detection</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">lind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">lind</span><span class="p">]</span> <span class="o">/</span> <span class="n">noise</span>

                <span class="c1"># compute and store the noise level for the summed DN term in units of DN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

                <span class="c1"># compute the average noise per each pixel squared in units of DN</span>
                <span class="n">pix_noise_avg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise2</span><span class="p">)</span> <span class="o">*</span> <span class="n">electrons_to_dn</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># make the weighted covariance matrix for the estimated point spread function by multiplying by the</span>
                <span class="c1"># average noise per pixel squared</span>
                <span class="n">psf_cov</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">covariance</span> <span class="o">/</span> <span class="n">psf</span><span class="o">.</span><span class="n">residual_std</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pix_noise_avg2</span>

                <span class="c1"># store the 1 sigma uncertainty in the estimated subpixel center</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psf_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psf_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># compute the jacobian of the integrated point spread function with respect to a change in the</span>
                <span class="c1"># estimated point spread function.  Do this with finite differencing</span>
                <span class="n">jacobian_integ_wrt_psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">perturbation_axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">pert_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">psf_pert</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span>
                    <span class="n">pert_vec</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span>
                    <span class="n">psf_pert</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">pert_vec</span><span class="p">)</span>
                    <span class="n">positive_integ</span> <span class="o">=</span> <span class="n">psf_pert</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
                    <span class="n">pert_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">psf_pert</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span>
                    <span class="n">pert_vec</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-6</span>
                    <span class="n">psf_pert</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">pert_vec</span><span class="p">)</span>
                    <span class="n">negative_integ</span> <span class="o">=</span> <span class="n">psf_pert</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>

                    <span class="n">jacobian_integ_wrt_psf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">positive_integ</span> <span class="o">-</span> <span class="n">negative_integ</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>

                <span class="c1"># compute the variance on the integrated point spread function value in dn</span>
                <span class="n">integ_cov</span> <span class="o">=</span> <span class="n">jacobian_integ_wrt_psf</span> <span class="o">@</span> <span class="n">psf_cov</span> <span class="o">@</span> <span class="n">jacobian_integ_wrt_psf</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># compute and store the uncertainty on the integrated point spread function in units of DN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">integ_cov</span><span class="p">))</span>

                <span class="c1"># finalize the chi^2 value for the point spread function fit quality by dividing by the DN uncertainty</span>
                <span class="c1"># in each pixel ignoring shot noise</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2_value</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">residual_rss</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">extra_noise2</span><span class="p">))</span>

                <span class="c1"># compute the trail length and pa if extended psf</span>
                <span class="c1"># check if the semi-major axis is 3 times bigger than the semi-minor axis.</span>
                <span class="c1"># If so this is probably a streaked detection</span>
                <span class="k">if</span> <span class="n">psf</span><span class="o">.</span><span class="n">sigma_x</span> <span class="o">/</span> <span class="n">psf</span><span class="o">.</span><span class="n">sigma_y</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># the trail length is two times the semi-major axis (roughly)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trail_length</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">lind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">psf</span><span class="o">.</span><span class="n">sigma_x</span>

                    <span class="c1"># determine the direction of the trail in ra/dec space</span>
                    <span class="c1"># determine the direction of increasing right ascension in the image</span>
                    <span class="n">ra_dir</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span>
                        <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span>
                        <span class="n">radec_to_unit</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">bearing</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">RAD2DEG</span><span class="p">)),</span>
                        <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
                    <span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="n">lind</span><span class="p">]</span>

                    <span class="n">ra_dir</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ra_dir</span><span class="p">)</span>
                    <span class="c1"># determine the direction of increasing declination in the image</span>
                    <span class="n">dec_dir</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span>
                        <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span>
                        <span class="n">radec_to_unit</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">bearing</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">])</span> <span class="o">/</span> <span class="n">RAD2DEG</span><span class="p">)),</span>
                        <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
                    <span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="n">lind</span><span class="p">]</span>

                    <span class="n">dec_dir</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dec_dir</span><span class="p">)</span>

                    <span class="c1"># determine the principal axis line for the psf</span>
                    <span class="n">pa_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">theta</span><span class="p">)])</span>

                    <span class="c1"># angle between pa_line and dec_dir is the trail orientation</span>
                    <span class="n">pa_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">dec_dir</span> <span class="o">@</span> <span class="n">pa_line</span><span class="p">)</span> <span class="o">*</span> <span class="n">RAD2DEG</span>

                    <span class="k">if</span> <span class="n">pa_line</span> <span class="o">@</span> <span class="n">ra_dir</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pa_theta</span> <span class="o">+=</span> <span class="mi">180</span>

                    <span class="c1"># store the trail orientation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trail_principal_angle</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">lind</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa_theta</span>

                <span class="c1"># transform the covariance of the estimated subpixel center into the unit vector covariance</span>
                <span class="n">cov_unit</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span>
                            <span class="n">jacobian_pixels_to_unit</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span> <span class="o">@</span>
                            <span class="n">psf_cov</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span>
                            <span class="n">jacobian_pixels_to_unit</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span>
                            <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

                <span class="c1"># transform the covariance into the bearing covariance</span>
                <span class="n">cov_rad</span> <span class="o">=</span> <span class="n">jacobian_unit_to_bearing</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span> <span class="o">@</span> <span class="n">cov_unit</span> <span class="o">@</span> <span class="n">jacobian_unit_to_bearing</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># extract the sigma values for the right ascension and declination from the covariance matrix</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ra_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov_rad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">declination_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov_rad</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># compute the rough magnitude of the detection using the summed DN if we were provided a magnitude function</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">image</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># now do all this again for the stars...</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># determine which detections are actually due to the surface of any extended targets in the scene</span>
                <span class="c1"># compute the rays to trace through the scene, one for each unmatched point</span>
                <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="n">directions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
                <span class="p">)</span>

                <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">directions</span><span class="p">)</span>

                <span class="c1"># do a single bounce ray trace from the camera to the body and then to the sun</span>
                <span class="n">illums_inp</span><span class="p">,</span> <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">get_illumination_inputs</span><span class="p">(</span><span class="n">rays</span><span class="p">,</span> <span class="n">return_intersects</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># identify things that are in line with the illuminated portion of the extended targets and throw them</span>
                <span class="c1"># out</span>
                <span class="c1"># anything that has visible set to true means that the object is on the illuminated portion of the</span>
                <span class="c1"># target (at least, where we think the illuminated portion of the targets are)</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">illums_inp</span><span class="p">[</span><span class="s1">&#39;visible&#39;</span><span class="p">]</span>

                <span class="c1"># Now check to see where we intersected the body, but didn&#39;t make it to the sun.  These are points on</span>
                <span class="c1"># the dark side of the targets (occulting).  We are going to throw away the points on the bright side so</span>
                <span class="c1"># we can use ~test here to store only the ones we&#39;ll keep</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_occulting</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">inter</span><span class="p">[</span><span class="o">~</span><span class="n">test</span><span class="p">][</span><span class="s1">&#39;check&#39;</span><span class="p">]</span>

                <span class="c1"># throw out the points that are due to teh illuminated targets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_stats</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_stats</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">test</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_occulting</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># determine the distance from each remaining point to the nearest saturated pixel in the image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_saturation_distance</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bright_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># self.sopnav.matched_rss[ind][:, 0] /= noise</span>

            <span class="c1"># get the inertial unit vector from the self.sopnav.camera through the detection</span>
            <span class="n">inertial_vecs</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
            <span class="p">)</span>

            <span class="c1"># compute the right ascension and declination of the unit vectors in degrees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_bearing</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unit_to_radec</span><span class="p">(</span><span class="n">inertial_vecs</span><span class="p">))</span> <span class="o">*</span> <span class="n">RAD2DEG</span>

            <span class="c1"># prepare some storage lists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_count</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_max_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_fit_chi2_value</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_saturated</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_x_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">star_y_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_ra_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">star_declination_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="c1"># compute the integrated psf DN for each detection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">psf</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">psf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>

            <span class="c1"># compute the jacobian matrix of the unit vector in the camera frame with respect to a change in the</span>
            <span class="c1"># pixel location</span>
            <span class="n">jacobian_pixels_to_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compute_unit_vector_jacobian</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span>
            <span class="p">)</span>

            <span class="c1"># compute the jacobian matrix of the right ascension and declination with respect to a change in the</span>
            <span class="c1"># unit vector</span>
            <span class="n">jacobian_unit_to_bearing</span> <span class="o">=</span> <span class="n">unit_to_radec_jacobian</span><span class="p">(</span><span class="n">inertial_vecs</span><span class="p">)</span>

            <span class="c1"># compute photometry for each detection</span>
            <span class="c1"># loop through the matched points and their psfs</span>
            <span class="n">iterator</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">IterativeGeneralizedGaussianWBackground</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">lind</span><span class="p">,</span> <span class="p">(</span><span class="n">poi</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>

                <span class="c1"># get the indices into the image around the detection, checking that we&#39;re not too close to an edge</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">poi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_row</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">poi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_col</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

                <span class="n">check</span> <span class="o">=</span> <span class="p">((</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cols</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                         <span class="p">(</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cols</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_cols</span><span class="p">))</span>

                <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">check</span><span class="p">]</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">check</span><span class="p">]</span>

                <span class="c1"># check to see if the pixels are saturated so we can set the flag</span>
                <span class="n">dns</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_saturated</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dns</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.98</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">saturation</span><span class="p">)</span>

                <span class="c1"># subtract off the estimated background from the DN values</span>
                <span class="n">bg</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">evaluate_bg</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span>
                <span class="n">dns</span> <span class="o">-=</span> <span class="n">bg</span>

                <span class="c1"># sum the dn, determine the number of pixels included in the sum, and get the max dn in the sub-window</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dns</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_count</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">check</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_max_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dns</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

                <span class="c1"># compute the average stray light to be the background minus the detector dn_offset at the center</span>
                <span class="c1"># of the detection</span>
                <span class="n">avg_stray_light</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">evaluate_bg</span><span class="p">(</span><span class="o">*</span><span class="n">psf</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_offset</span>

                <span class="c1"># compute the noise level for the summed DN</span>
                <span class="c1"># compute the square of the shot noise in electrons</span>
                <span class="n">sigma_shot2</span> <span class="o">=</span> <span class="p">(</span><span class="n">dns</span> <span class="o">/</span> <span class="n">electrons_to_dn</span><span class="p">)</span>

                <span class="c1"># compute the sum of the squares of the quantization noise, the read noise,</span>
                <span class="c1"># the noise due to the stray light, and the dark current in electrons</span>
                <span class="n">extra_noise2</span> <span class="o">=</span> <span class="p">(</span><span class="n">quantization_noise</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">read_noise</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">avg_stray_light</span> <span class="o">/</span> <span class="n">electrons_to_dn</span> <span class="o">+</span>
                                <span class="n">dark_current</span><span class="p">)</span>

                <span class="c1"># compute the sum of the squares of the noise terms in electrons</span>
                <span class="n">noise2</span> <span class="o">=</span> <span class="n">sigma_shot2</span> <span class="o">+</span> <span class="n">extra_noise2</span>

                <span class="c1"># get the total noise in the sub-window in units of DN</span>
                <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise2</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">*</span> <span class="n">electrons_to_dn</span>

                <span class="c1"># compute and store the signal to noise ratio for the detection</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">lind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">lind</span><span class="p">]</span> <span class="o">/</span> <span class="n">noise</span>

                <span class="c1"># compute and store the noise level for the summed DN term in units of DN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

                <span class="c1"># compute the average noise per each pixel squared in units of DN</span>
                <span class="n">pix_noise_avg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise2</span><span class="p">)</span> <span class="o">*</span> <span class="n">electrons_to_dn</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># make the weighted covariance matrix for the estimated point spread function by multiplying by the</span>
                <span class="c1"># average noise per pixel squared</span>
                <span class="n">psf_cov</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">covariance</span> <span class="o">/</span> <span class="n">psf</span><span class="o">.</span><span class="n">residual_std</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pix_noise_avg2</span>

                <span class="c1"># store the 1 sigma uncertainty in the estimated subpixel center</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_x_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psf_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_y_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">psf_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># compute the jacobian of the integrated point spread function with respect to a change in the</span>
                <span class="c1"># estimated point spread function.  Do this with finite differencing</span>
                <span class="n">jacobian_integ_wrt_psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">perturbation_axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">pert_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">psf_pert</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span>
                    <span class="n">pert_vec</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span>
                    <span class="n">psf_pert</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">pert_vec</span><span class="p">)</span>
                    <span class="n">positive_integ</span> <span class="o">=</span> <span class="n">psf_pert</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
                    <span class="n">pert_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psf_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">psf_pert</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span>
                    <span class="n">pert_vec</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-6</span>
                    <span class="n">psf_pert</span><span class="o">.</span><span class="n">update_state</span><span class="p">(</span><span class="n">pert_vec</span><span class="p">)</span>
                    <span class="n">negative_integ</span> <span class="o">=</span> <span class="n">psf_pert</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>

                    <span class="n">jacobian_integ_wrt_psf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">positive_integ</span> <span class="o">-</span> <span class="n">negative_integ</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>

                <span class="c1"># compute the variance on the integrated point spread function value in dn</span>
                <span class="n">integ_cov</span> <span class="o">=</span> <span class="n">jacobian_integ_wrt_psf</span> <span class="o">@</span> <span class="n">psf_cov</span> <span class="o">@</span> <span class="n">jacobian_integ_wrt_psf</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># compute and store the uncertainty on the integrated point spread function in units of DN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">integ_cov</span><span class="p">))</span>

                <span class="c1"># finalize the chi^2 value for the point spread function fit quality by dividing by the DN uncertainty</span>
                <span class="c1"># in each pixel ignoring shot noise</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_fit_chi2_value</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">residual_rss</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">extra_noise2</span><span class="p">))</span>

                <span class="c1"># transform the covariance of the estimated subpixel center into the unit vector covariance</span>
                <span class="n">cov_unit</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span>
                            <span class="n">jacobian_pixels_to_unit</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span> <span class="o">@</span>
                            <span class="n">psf_cov</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span>
                            <span class="n">jacobian_pixels_to_unit</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span>
                            <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

                <span class="c1"># transform the covariance into the bearing covariance</span>
                <span class="n">cov_rad</span> <span class="o">=</span> <span class="n">jacobian_unit_to_bearing</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span> <span class="o">@</span> <span class="n">cov_unit</span> <span class="o">@</span> <span class="n">jacobian_unit_to_bearing</span><span class="p">[</span><span class="n">lind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># extract the sigma values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_ra_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov_rad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_declination_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov_rad</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># compute the rough magnitude of the detection using the summed DN if we were provided a magnitude function</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_observed_magnitude</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">image</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">star_observed_magnitude</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;image </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1"> analyzed in </span><span class="si">{:.3f}</span><span class="s1"> seconds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">processed_images</span><span class="p">,</span>
                                                                   <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">image_mask</span><span class="p">),</span>
                                                                   <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">processed_images</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># print out the filtered results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">sid_summary</span><span class="p">()</span>

        <span class="c1"># list to store all the tuples</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="c1"># if this is an invalid image skip it</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_images</span><span class="p">[</span><span class="n">ind</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># extract the filename from the image data</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">file</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># get the image utc time</span>
            <span class="n">date_utc</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

            <span class="c1"># get the image et</span>
            <span class="n">date_et</span> <span class="o">=</span> <span class="n">datetime_to_et</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">)</span>

            <span class="c1"># get the rotation quaternion from inertial to the camera</span>
            <span class="n">rotation_quat</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">q</span>

            <span class="c1"># make a list of all the different things we need to loop through to make it easier</span>
            <span class="c1"># noinspection SpellCheckingInspection</span>
            <span class="n">zlist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>  <span class="c1"># poi</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_stats</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># stats</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">max_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># mdn</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># sdn</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_count</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># nsum</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">bearing</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>  <span class="c1"># rd</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># psf</span>
                     <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">])),</span>  <span class="c1"># sigs</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2_value</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># rss</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">unmatched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># snr</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">ra_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># rsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">declination_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># dsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">occulting</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># occ</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">saturation_distance</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># dist</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># mg</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># ipsf</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">trail_length</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># tl</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">trail_principal_angle</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># tp</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># ipsfsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># sdnsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">saturated</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>  <span class="c1"># sat</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">psf</span><span class="p">,</span> <span class="n">IterativeGeneralizedGaussianWBackground</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must be IterativeGeneralizedGaussianWBackground to use package results currently&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_hashed_index</span><span class="p">:</span>
                <span class="n">max_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_cols</span><span class="p">)))</span>
                <span class="n">max_length</span> <span class="o">+=</span> <span class="mi">5</span>
                <span class="n">hash_format</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{}}</span><span class="s1">_</span><span class="se">{{</span><span class="s1">:0</span><span class="si">{</span><span class="n">max_length</span><span class="si">}</span><span class="s1">.2f</span><span class="se">}}</span><span class="s1">_</span><span class="se">{{</span><span class="s1">:0</span><span class="si">{</span><span class="n">max_length</span><span class="si">}</span><span class="s1">.2f</span><span class="se">}}</span><span class="s1">&#39;</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">hash_format</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

            <span class="c1"># zip together the stuff we need to loop through and loop through it</span>
            <span class="c1"># noinspection SpellCheckingInspection</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">poi</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">mdn</span><span class="p">,</span> <span class="n">sdn</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">sigs</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>
                 <span class="n">rsig</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ipsf</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ipsfsig</span><span class="p">,</span> <span class="n">sdnsig</span><span class="p">,</span> <span class="n">sat</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zlist</span><span class="p">):</span>

                <span class="n">qcode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">psf</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">psf</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span> <span class="o">+</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qcode</span><span class="p">):</span>
                    <span class="n">qcode</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># append a tuple with the requisite information</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_hashed_index</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">filename</span><span class="p">,</span> <span class="n">date_utc</span><span class="p">,</span> <span class="n">date_et</span><span class="p">,</span>  <span class="c1"># image_file, mid_exposure_utc, mid_exposure_et</span>
                                 <span class="n">poi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw, y_raw</span>
                                 <span class="n">sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw_sigma, y_raw_sigma</span>
                                 <span class="n">rd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># ra, dec</span>
                                 <span class="n">rsig</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span>  <span class="c1"># ra_sigma, dec_sigma</span>
                                 <span class="n">stats</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">],</span> <span class="n">mdn</span><span class="p">,</span>  <span class="c1"># area, peak_dn</span>
                                 <span class="n">sdn</span><span class="p">,</span> <span class="n">sdnsig</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span>  <span class="c1"># summed_dn, summed_dn_sigma, n_pix_summed</span>
                                 <span class="n">ipsf</span><span class="p">,</span> <span class="n">ipsfsig</span><span class="p">,</span>  <span class="c1"># integrated_psf, integrated_psf_sigma</span>
                                 <span class="n">mg</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>  <span class="c1"># magnitude, snr</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">psf</span><span class="p">),</span> <span class="n">rss</span><span class="p">,</span>  <span class="c1"># psf, psf_fit_quality</span>
                                 <span class="n">occ</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span>  <span class="c1"># occulting, saturation_distance, is_saturated</span>
                                 <span class="n">tl</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>  <span class="c1"># trail_length, trail_principal_angle</span>
                                 <span class="n">qcode</span><span class="p">,</span>  <span class="c1"># quality_code</span>
                                 <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>  <span class="c1"># rotation</span>
                                 <span class="kc">None</span><span class="p">,</span>  <span class="c1"># star_id (None because these are unmatched))</span>
                                 <span class="n">hash_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">poi</span><span class="p">)))</span>  <span class="c1"># hash id</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">filename</span><span class="p">,</span> <span class="n">date_utc</span><span class="p">,</span> <span class="n">date_et</span><span class="p">,</span>  <span class="c1"># image_file, mid_exposure_utc, mid_exposure_et</span>
                                 <span class="n">poi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw, y_raw</span>
                                 <span class="n">sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw_sigma, y_raw_sigma</span>
                                 <span class="n">rd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># ra, dec</span>
                                 <span class="n">rsig</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span>  <span class="c1"># ra_sigma, dec_sigma</span>
                                 <span class="n">stats</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">],</span> <span class="n">mdn</span><span class="p">,</span>  <span class="c1"># area, peak_dn</span>
                                 <span class="n">sdn</span><span class="p">,</span> <span class="n">sdnsig</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span>  <span class="c1"># summed_dn, summed_dn_sigma, n_pix_summed</span>
                                 <span class="n">ipsf</span><span class="p">,</span> <span class="n">ipsfsig</span><span class="p">,</span>  <span class="c1"># integrated_psf, integrated_psf_sigma</span>
                                 <span class="n">mg</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>  <span class="c1"># magnitude, snr</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">psf</span><span class="p">),</span> <span class="n">rss</span><span class="p">,</span>  <span class="c1"># psf, psf_fit_quality</span>
                                 <span class="n">occ</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span>  <span class="c1"># occulting, saturation_distance, is_saturated</span>
                                 <span class="n">tl</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>  <span class="c1"># trail_length, trail_principal_angle</span>
                                 <span class="n">qcode</span><span class="p">,</span>  <span class="c1"># quality_code</span>
                                 <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>  <span class="c1"># rotation</span>
                                 <span class="kc">None</span><span class="p">))</span>  <span class="c1"># star_id (None because these are unmatched))</span>

            <span class="c1"># make a list of all the different things we need to loop through to make it easier</span>
            <span class="n">cat_id</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">zone</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">rnz</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_catalogue_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="c1"># noinspection SpellCheckingInspection</span>
            <span class="n">zlist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>  <span class="c1"># poi</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_stats</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># stats</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_max_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># mdn</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># sdn</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_count</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># nsum</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_bearing</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>  <span class="c1"># rd</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_psfs</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># psf</span>
                     <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">star_x_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">star_y_raw_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">])),</span>  <span class="c1"># sigs</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_fit_chi2_value</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># rss</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">matched_snrs</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># snr</span>
                     <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cat_id</span><span class="p">],</span>  <span class="c1"># label, this is the star id value</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_ra_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># rsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_declination_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># dsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_occulting</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># occ</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_saturation_distance</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># dist</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_observed_magnitude</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># mg</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># ipsf</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># ipsfsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_uncertainty</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>  <span class="c1"># sdnsig</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">star_saturated</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>  <span class="c1"># sat</span>

            <span class="c1"># zip together the stuff we need to loop through and loop through it</span>
            <span class="c1"># noinspection SpellCheckingInspection</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">poi</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">mdn</span><span class="p">,</span> <span class="n">sdn</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">sigs</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">,</span> <span class="n">rsig</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">mg</span><span class="p">,</span> <span class="n">ipsf</span><span class="p">,</span> <span class="n">ipsfsig</span><span class="p">,</span> <span class="n">sdnsig</span><span class="p">,</span> <span class="n">sat</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zlist</span><span class="p">):</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_hashed_index</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">filename</span><span class="p">,</span> <span class="n">date_utc</span><span class="p">,</span> <span class="n">date_et</span><span class="p">,</span>  <span class="c1"># image_file, mid_exposure_utc, mid_exposure_et</span>
                                 <span class="n">poi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw, y_raw</span>
                                 <span class="n">sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw_sigma, y_raw_sigma</span>
                                 <span class="n">rd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># ra, dec</span>
                                 <span class="n">rsig</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span>  <span class="c1"># ra_sigma, dec_sigma</span>
                                 <span class="n">stats</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">],</span> <span class="n">mdn</span><span class="p">,</span>  <span class="c1"># area peak_dn</span>
                                 <span class="n">sdn</span><span class="p">,</span> <span class="n">sdnsig</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span>  <span class="c1"># summed_dn, summed_dn_sigma, n_pix_summed</span>
                                 <span class="n">ipsf</span><span class="p">,</span> <span class="n">ipsfsig</span><span class="p">,</span>  <span class="c1"># integrated_psf, integrated_psf_sigma</span>
                                 <span class="n">mg</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>  <span class="c1"># magnitude, snr</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">psf</span><span class="p">),</span> <span class="n">rss</span><span class="p">,</span>  <span class="c1"># psf, psf_fit_quality</span>
                                 <span class="n">occ</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span>  <span class="c1"># occulting, saturation_distance, is_saturated</span>
                                 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># trail_length, trail_principal_angle, quality_code</span>
                                 <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>  <span class="c1"># rotation</span>
                                 <span class="n">label</span><span class="p">,</span>  <span class="c1"># star_id</span>
                                 <span class="n">hash_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">poi</span><span class="p">)))</span>  <span class="c1"># hash id</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">filename</span><span class="p">,</span> <span class="n">date_utc</span><span class="p">,</span> <span class="n">date_et</span><span class="p">,</span>  <span class="c1"># image_file, mid_exposure_utc, mid_exposure_et</span>
                                 <span class="n">poi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw, y_raw</span>
                                 <span class="n">sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># x_raw_sigma, y_raw_sigma</span>
                                 <span class="n">rd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># ra, dec</span>
                                 <span class="n">rsig</span><span class="p">,</span> <span class="n">dsig</span><span class="p">,</span>  <span class="c1"># ra_sigma, dec_sigma</span>
                                 <span class="n">stats</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">CC_STAT_AREA</span><span class="p">],</span> <span class="n">mdn</span><span class="p">,</span>  <span class="c1"># area peak_dn</span>
                                 <span class="n">sdn</span><span class="p">,</span> <span class="n">sdnsig</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span>  <span class="c1"># summed_dn, summed_dn_sigma, n_pix_summed</span>
                                 <span class="n">ipsf</span><span class="p">,</span> <span class="n">ipsfsig</span><span class="p">,</span>  <span class="c1"># integrated_psf, integrated_psf_sigma</span>
                                 <span class="n">mg</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span>  <span class="c1"># magnitude, snr</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">psf</span><span class="p">),</span> <span class="n">rss</span><span class="p">,</span>  <span class="c1"># psf, psf_fit_quality</span>
                                 <span class="n">occ</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span>  <span class="c1"># occulting, saturation_distance, is_saturated</span>
                                 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># trail_length, trail_principal_angle, quality_code</span>
                                 <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rotation_quat</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>  <span class="c1"># rotation</span>
                                 <span class="n">label</span><span class="p">))</span>  <span class="c1"># star_id</span>

        <span class="c1"># combine everything into a structured array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_hashed_index</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;image_file&#39;</span><span class="p">,</span> <span class="s1">&#39;mid_exposure_utc&#39;</span><span class="p">,</span> <span class="s1">&#39;mid_exposure_et&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;x_raw&#39;</span><span class="p">,</span> <span class="s1">&#39;y_raw&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;x_raw_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;y_raw_sigma&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;ra&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;ra_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;dec_sigma&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;peak_dn&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;summed_dn&#39;</span><span class="p">,</span> <span class="s1">&#39;summed_dn_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;n_pix_summed&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;integrated_psf&#39;</span><span class="p">,</span> <span class="s1">&#39;integrated_psf_sigma&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="s1">&#39;snr&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;psf&#39;</span><span class="p">,</span> <span class="s1">&#39;psf_fit_quality&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;occulting&#39;</span><span class="p">,</span> <span class="s1">&#39;saturation_distance&#39;</span><span class="p">,</span> <span class="s1">&#39;is_saturated&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;trail_length&#39;</span><span class="p">,</span> <span class="s1">&#39;trail_principal_angle&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;quality_code&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;x_inert2cam&#39;</span><span class="p">,</span> <span class="s1">&#39;y_inert2cam&#39;</span><span class="p">,</span> <span class="s1">&#39;z_inert2cam&#39;</span><span class="p">,</span> <span class="s1">&#39;s_inert2cam&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;star_id&#39;</span><span class="p">,</span> <span class="s1">&#39;hash_id&#39;</span><span class="p">],</span>
                                                          <span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">int</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">)))))</span>

            <span class="c1"># make the dataframe and store it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;hash_id&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;image_file&#39;</span><span class="p">,</span> <span class="s1">&#39;mid_exposure_utc&#39;</span><span class="p">,</span> <span class="s1">&#39;mid_exposure_et&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;x_raw&#39;</span><span class="p">,</span> <span class="s1">&#39;y_raw&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;x_raw_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;y_raw_sigma&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;ra&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;ra_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;dec_sigma&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;peak_dn&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;summed_dn&#39;</span><span class="p">,</span> <span class="s1">&#39;summed_dn_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;n_pix_summed&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;integrated_psf&#39;</span><span class="p">,</span> <span class="s1">&#39;integrated_psf_sigma&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="s1">&#39;snr&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;psf&#39;</span><span class="p">,</span> <span class="s1">&#39;psf_fit_quality&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;occulting&#39;</span><span class="p">,</span> <span class="s1">&#39;saturation_distance&#39;</span><span class="p">,</span> <span class="s1">&#39;is_saturated&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;trail_length&#39;</span><span class="p">,</span> <span class="s1">&#39;trail_principal_angle&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;quality_code&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;x_inert2cam&#39;</span><span class="p">,</span> <span class="s1">&#39;y_inert2cam&#39;</span><span class="p">,</span> <span class="s1">&#39;z_inert2cam&#39;</span><span class="p">,</span> <span class="s1">&#39;s_inert2cam&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;star_id&#39;</span><span class="p">],</span>
                                                          <span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">int</span><span class="p">,</span>
                                                           <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                                           <span class="nb">object</span><span class="p">)))))</span>

            <span class="c1"># make the dataframe and store it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Detector.identify_hot_pixels_and_unmatched_stars"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.identify_hot_pixels_and_unmatched_stars.html#giant.ufo.detector.Detector.identify_hot_pixels_and_unmatched_stars">[docs]</a>    <span class="k">def</span> <span class="nf">identify_hot_pixels_and_unmatched_stars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to attempt to autonomously identify detections due to consistent hot-pixels (where the same</span>
<span class="sd">        pixel is very bring in many images) or do to an unmatched star (where the same inertial direction is observed in</span>
<span class="sd">        multiple images).</span>

<span class="sd">        This method should only be used after a call to :meth:`package_results` as it works on the</span>
<span class="sd">        :attr:`detection_data_frame`.  Detections labeled as possible stars or hot pixels will be given a quality_code</span>
<span class="sd">        of -1.</span>

<span class="sd">        Hot pixels are identified by searching for detections within 2 pixels of each other in the images that occur in</span>
<span class="sd">        multiple images (so the same x_raw, y_raw value in multiple images).  If a x_raw, y_raw pair occurs in at least</span>
<span class="sd">        :attr:`hot_pixel_threshold` times then it will be labeled as a possible hot pixel.</span>

<span class="sd">        Unmatched stars are labeled by searching for detections with the same right ascension/declination (within</span>
<span class="sd">        2*IFOV of the detector) in multiple images.  If a ra, dec pair appears in more than</span>
<span class="sd">        :attr:`unmatched_star_threshold` times then it will be labeled as a possible star.</span>

<span class="sd">        Because both of these require things appearing in multiple images, these techniques are best used when there are</span>
<span class="sd">        a number of images that were processed together.  If you are only processing a few images then you will likely</span>
<span class="sd">        not have much success with this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract to a shorter name</span>
        <span class="n">ufos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span>

        <span class="c1"># make sure package results has been called</span>
        <span class="k">if</span> <span class="n">ufos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must call package_results before this method&#39;</span><span class="p">)</span>

        <span class="c1"># ignore known stars</span>
        <span class="n">quality_code_check</span> <span class="o">=</span> <span class="n">ufos</span><span class="o">.</span><span class="n">quality_code</span> <span class="o">&gt;=</span> <span class="mi">1</span>

        <span class="c1"># make groups based on the image that the detections were found in</span>
        <span class="n">image_groups</span> <span class="o">=</span> <span class="n">ufos</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">quality_code_check</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;image_file&#39;</span><span class="p">)</span>

        <span class="c1"># extract to a shorter name</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># compute the IFOV of the detector in radians</span>
        <span class="n">ifov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">([[(</span><span class="n">model</span><span class="o">.</span><span class="n">n_cols</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">n_cols</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                                          <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">n_rows</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">n_rows</span><span class="o">/</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1"># make a list of kd trees to use to compare across images</span>
        <span class="n">kd_trees</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">image_groups</span><span class="p">:</span>
            <span class="n">pixel_locations</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s2">&quot;x_raw&quot;</span><span class="p">,</span> <span class="s2">&quot;y_raw&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">kd_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">pixel_locations</span><span class="p">))</span>

        <span class="c1"># loop through the group again</span>
        <span class="k">for</span> <span class="n">first_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">first_file</span><span class="p">,</span> <span class="n">first_group</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">image_groups</span><span class="p">):</span>

            <span class="c1"># initialize an array of counts for this image</span>
            <span class="n">hot_pixel_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">first_group</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">direction_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">first_group</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># loop through the other images</span>
            <span class="k">for</span> <span class="n">second_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">second_file</span><span class="p">,</span> <span class="n">second_group</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">image_groups</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">second_ind</span> <span class="o">==</span> <span class="n">first_ind</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># identify x_raw, y_raw pairs that are within 2 pixels of each other between the images</span>
                <span class="c1"># noinspection PyUnresolvedReferences</span>
                <span class="n">pairs</span> <span class="o">=</span> <span class="n">kd_trees</span><span class="p">[</span><span class="n">first_ind</span><span class="p">]</span><span class="o">.</span><span class="n">query_ball_tree</span><span class="p">(</span><span class="n">kd_trees</span><span class="p">[</span><span class="n">second_ind</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># add to the hot pixel count array where we found a pair within 2 pixels</span>
                <span class="k">for</span> <span class="n">matched_index</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                    <span class="n">hot_pixel_counts</span><span class="p">[</span><span class="n">matched_index</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>  <span class="c1"># points where no matches were found are length 0</span>

                <span class="c1"># compute the number of shared inertial directions between the images.  Need to compute the distance in</span>
                <span class="c1"># ra/dec space so we can&#39;t use trees and need to brute force it unfortunately</span>
                <span class="n">direction_counts</span> <span class="o">+=</span> <span class="p">(</span><span class="n">radec_distance</span><span class="p">(</span><span class="n">first_group</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">DEG2RAD</span><span class="p">,</span>
                                                    <span class="n">first_group</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">DEG2RAD</span><span class="p">,</span>
                                                    <span class="n">second_group</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">DEG2RAD</span><span class="p">,</span>
                                                    <span class="n">second_group</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">DEG2RAD</span><span class="p">)</span> <span class="o">&lt;</span>
                                     <span class="mi">2</span><span class="o">*</span><span class="n">ifov</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># make a boolean for this image/detections that were considered</span>
            <span class="n">image_check</span> <span class="o">=</span> <span class="p">(</span><span class="n">ufos</span><span class="o">.</span><span class="n">image_file</span> <span class="o">==</span> <span class="n">first_file</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">quality_code_check</span>

            <span class="c1"># update anywhere that is a possible hot pixel or unmatched star with a quality_code of -1</span>
            <span class="n">image_check</span><span class="p">[</span><span class="n">image_check</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">hot_pixel_counts</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hot_pixel_threshold</span><span class="p">)</span> <span class="o">|</span>
                                        <span class="p">(</span><span class="n">direction_counts</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unmatched_star_threshold</span><span class="p">))</span>
            <span class="n">ufos</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">image_check</span><span class="p">,</span> <span class="s2">&quot;quality_code&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Detector.remove_duplicates"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.remove_duplicates.html#giant.ufo.detector.Detector.remove_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes duplicates from the dataframe.</span>

<span class="sd">        Occasionally if many points are close to each other we might end up with duplicate detections.  This method</span>
<span class="sd">        gets rid of them by looking for pairs of detections that are within 2 pixels of each other and only keeping the</span>
<span class="sd">        one with the better quality_code.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># sometimes we might get duplicate detections from the same image.</span>
        <span class="c1"># This function gets rid of them</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="o">.</span><span class="n">occulting</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">remove</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">image_file</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;image_file&#39;</span><span class="p">):</span>

            <span class="c1"># make a kd tree for points in this image</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">kd</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;x_raw&quot;</span><span class="p">:</span><span class="s2">&quot;y_raw&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># find all pairs separated by less than 2 pixels</span>
            <span class="c1"># noinspection PyUnresolvedReferences</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">query_pairs</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># loop through each pair and set it to be removed</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">grp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">quality_code</span> <span class="o">&lt;=</span> <span class="n">grp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">quality_code</span><span class="p">:</span>
                    <span class="n">remove</span><span class="p">[</span><span class="n">grp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">remove</span><span class="p">[</span><span class="n">grp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">remove</span><span class="p">]</span></div>

<div class="viewcode-block" id="Detector.save_results"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.save_results.html#giant.ufo.detector.Detector.save_results">[docs]</a>    <span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">split</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method saves the results into csv files.</span>

<span class="sd">        It can optionally split the results by image file, creating a single file for each image.  In this case, the out</span>
<span class="sd">        string should be a format string expecting 1 input, the name of the image file.</span>

<span class="sd">        :param out: the name of the csv file to save the results to.  If ``split`` is ``True`` then this should be a</span>
<span class="sd">                    format string expecting the name of the image file</span>
<span class="sd">        :param split: A flag specifying whether to split the output into a file for each image processed instead of 1</span>
<span class="sd">                      big file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if we are splitting into multiple files</span>
        <span class="k">if</span> <span class="n">split</span><span class="p">:</span>
            <span class="c1"># split according to image</span>
            <span class="k">for</span> <span class="n">image_file</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;image_file&#39;</span><span class="p">):</span>
                <span class="c1"># get the name of the file to save the results to</span>
                <span class="n">out_file</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image_file</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.FITS&#39;</span><span class="p">))</span>

                <span class="c1"># save the results to the file</span>
                <span class="n">grp</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just write out everything</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detection_data_frame</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Detector.clear_results"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.clear_results.html#giant.ufo.detector.Detector.clear_results">[docs]</a>    <span class="k">def</span> <span class="nf">clear_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This clears all extracted UFOs/Stars from the instance with the exception of the :attr:`detection_data_frame`</span>
<span class="sd">        for memory purposes.</span>

<span class="sd">        Note that after calling this method, the attributes containing the results will all be blank again and you will</span>
<span class="sd">        only be able to access information from the :attr:`detection_data_frame` attribute.j</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">number_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_images</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_uncertainty</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturated</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_count</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bearing</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ra_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">declination_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_raw_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_raw_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occulting</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturation_distance</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trail_length</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trail_principal_angle</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_observed_magnitude</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_fit_chi2_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_uncertainty</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_saturated</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_count</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_max_dn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_bearing</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_ra_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_declination_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_x_raw_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_y_raw_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_occulting</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">star_saturation_distance</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_images</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">clear_results</span><span class="p">()</span></div>

<div class="viewcode-block" id="Detector.add_images"><a class="viewcode-back" href="../../../ufo/detector/giant.ufo.detector.Detector.add_images.html#giant.ufo.detector.Detector.add_images">[docs]</a>    <span class="k">def</span> <span class="nf">add_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">PATH</span><span class="p">,</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">]],</span> <span class="n">PATH</span><span class="p">,</span> <span class="n">ARRAY_LIKE_2D</span><span class="p">],</span>
                   <span class="n">parse_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">preprocessor</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is essentially an alias to the :meth:`.StellarOpNav.add_images` method, but it also expands various lists</span>
<span class="sd">        to account for the new number of images.</span>

<span class="sd">        When you have already initialized a :class:`Detector` class you should *always* use this method to add</span>
<span class="sd">        images for consideration.</span>

<span class="sd">        The lists that are extended by this method are:</span>

<span class="sd">        * :attr:`invalid_images`</span>
<span class="sd">        * :attr:`summed_dn`</span>
<span class="sd">        * :attr:`magnitude`</span>
<span class="sd">        * :attr:`fit_chi2_value`</span>
<span class="sd">        * :attr:`summed_dn_uncertainty`</span>
<span class="sd">        * :attr:`saturated`</span>
<span class="sd">        * :attr:`summed_dn_count`</span>
<span class="sd">        * :attr:`max_dn`</span>
<span class="sd">        * :attr:`bearing`</span>
<span class="sd">        * :attr:`integrated_psf`</span>
<span class="sd">        * :attr:`ra_sigma`</span>
<span class="sd">        * :attr:`declination_sigma`</span>
<span class="sd">        * :attr:`x_raw_sigma`</span>
<span class="sd">        * :attr:`y_raw_sigma`</span>
<span class="sd">        * :attr:`occulting`</span>
<span class="sd">        * :attr:`saturation_distance`</span>
<span class="sd">        * :attr:`trail_length`</span>
<span class="sd">        * :attr:`trail_principal_angle`</span>
<span class="sd">        * :attr:`star_summed_dn`</span>
<span class="sd">        * :attr:`star_observed_magnitude`</span>
<span class="sd">        * :attr:`star_fit_chi2_value`</span>
<span class="sd">        * :attr:`star_summed_dn_uncertainty`</span>
<span class="sd">        * :attr:`star_saturated`</span>
<span class="sd">        * :attr:`star_summed_dn_count`</span>
<span class="sd">        * :attr:`star_max_dn`</span>
<span class="sd">        * :attr:`star_bearing`</span>
<span class="sd">        * :attr:`star_integrated_psf`</span>
<span class="sd">        * :attr:`star_ra_sigma`</span>
<span class="sd">        * :attr:`star_declination_sigma`</span>
<span class="sd">        * :attr:`star_x_raw_sigma`</span>
<span class="sd">        * :attr:`star_y_raw_sigma`</span>
<span class="sd">        * :attr:`star_occulting`</span>
<span class="sd">        * :attr:`star_saturation_distance`</span>

<span class="sd">        See the :meth:`.StellarOpNav.add_images` for a description of the valid input for `data`</span>

<span class="sd">        :param data:  The image data to be stored in the :attr:`.images` list</span>
<span class="sd">        :param parse_data:  A flag to specify whether to attempt to parse the metadata automatically for the images</span>
<span class="sd">        :param preprocessor: A flag to specify whether to run the preprocessor after loading an image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sopnav</span><span class="o">.</span><span class="n">add_images</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">parse_data</span><span class="o">=</span><span class="n">parse_data</span><span class="p">,</span> <span class="n">preprocessor</span><span class="o">=</span><span class="n">preprocessor</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalid_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_uncertainty</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saturated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summed_dn_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_dn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bearing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrated_psf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">declination_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_raw_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_raw_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">occulting</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saturation_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trail_length</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trail_principal_angle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_observed_magnitude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_fit_chi2_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_uncertainty</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_saturated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_summed_dn_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_max_dn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_bearing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_integrated_psf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_ra_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_declination_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_x_raw_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_y_raw_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_occulting</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">star_saturation_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_needs_processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div></div>


<span class="c1"># noinspection SpellCheckingInspection</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">if __name__ == &quot;__main__&quot;:</span>
<span class="sd">    import warnings</span>

<span class="sd">    # disable annoying attitude warnings</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&#39;Non-unit length&#39;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, category=FutureWarning)</span>

<span class="sd">    logging.basicConfig(level=logging.INFO, format=&#39;%(asctime)s %(levelname)s:%(name)s:%(funcName)s:%(message)s&#39;,</span>
<span class="sd">                        filename=&#39;/missions/orex/logs/ufo/ufo.log&#39;)</span>

<span class="sd">    # set the version of UFO</span>
<span class="sd">    version = 1.1</span>

<span class="sd">    # disable annoying attitude warnings</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&#39;Non-unit length&#39;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&#39;peak too close&#39;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&quot;solution didn&#39;t converge&quot;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&quot;solution is diverging&quot;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&quot;overflow&quot;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, message=&quot;Invalid jacobian&quot;)</span>
<span class="sd">    warnings.filterwarnings(&#39;ignore&#39;, category=FutureWarning)</span>

<span class="sd">    # build the cli</span>
<span class="sd">    parser = ArgumentParser(description=&#39;Find unidentified particles in OSIRIS-REx OpNav images&#39;)</span>

<span class="sd">    parser.add_argument(&#39;-c&#39;, &#39;--camera&#39;, help=&#39;The camera file containing all of the images&#39;, default=&#39;./camera.dill&#39;,</span>
<span class="sd">                        type=str)</span>
<span class="sd">    parser.add_argument(&#39;-m&#39;, &#39;--meta_kernel&#39;, help=&#39;The meta kernel file to load into spice&#39;,</span>
<span class="sd">                        default=&#39;./meta_kernel.tm&#39;, type=str)</span>
<span class="sd">    parser.add_argument(&#39;-n&#39;, &#39;--no_split&#39;, help=&quot;Don&#39;t split the output files by day&quot;, action=&#39;store_true&#39;)</span>
<span class="sd">    parser.add_argument(&#39;--shape&#39;, help=&#39;The shape model to use for rejecting points on the body&#39;,</span>
<span class="sd">                        default=&#39;/missions/orex/opnav/common/shape_models/ola_v19_aligned/kdtree.pickle&#39;)</span>
<span class="sd">    parser.add_argument(&#39;--output&#39;, default=&#39;./csv_files/{}.csv&#39;, help=&#39;override the file to save to&#39;)</span>

<span class="sd">    # get the user specified arguments</span>
<span class="sd">    args = parser.parse_args()</span>

<span class="sd">    csv_file = args.output</span>

<span class="sd">    camera_file = args.camera</span>

<span class="sd">    # furnish the spice files</span>
<span class="sd">    spice.furnsh(&#39;/missions/orex/spice/attitude_mk.tm&#39;)</span>
<span class="sd">    spice.furnsh(args.meta_kernel)</span>
<span class="sd">    spice.furnsh(&#39;/missions/orex/spice/spk_mk.tm&#39;)</span>

<span class="sd">    # Load in camera</span>
<span class="sd">    with open(camera_file, &#39;rb&#39;) as dillfile:</span>
<span class="sd">        camera = dill.load(dillfile)</span>

<span class="sd">    # make sure we have the most up to date states for the images</span>
<span class="sd">    camera.update_states()</span>

<span class="sd">    # change the camera model to use the &quot;official&quot; camera model</span>
<span class="sd">    if camera.cam_name == &#39;NavCam 1&#39;:</span>
<span class="sd">        camera.model.fx = 3473.26</span>
<span class="sd">        camera.model.fy = -3473.321</span>
<span class="sd">        camera.model.px = 1268.083</span>
<span class="sd">        camera.model.py = 949.747</span>
<span class="sd">        camera.model.a1 = 2.2933e-5</span>
<span class="sd">        camera.model.k1 = -5.3766e-1</span>
<span class="sd">        camera.model.k2 = 3.7526e-1</span>
<span class="sd">        camera.model.k3 = -1.8368e-1</span>
<span class="sd">        camera.model.p1 = -2.3432e-4</span>
<span class="sd">        camera.model.p2 = 9.0875e-4</span>
<span class="sd">        offset = 169.64</span>
<span class="sd">        a_d = 714916</span>
<span class="sd">        delta_temp = 1.1029</span>
<span class="sd">    elif camera.cam_name == &#39;NavCam 2&#39;:</span>
<span class="sd">        camera.model.fx = 3462.530</span>
<span class="sd">        camera.model.fy = -3462.532</span>
<span class="sd">        camera.model.px = 1309.530</span>
<span class="sd">        camera.model.py = 968.487</span>
<span class="sd">        camera.model.a1 = 1.9876e-5</span>
<span class="sd">        camera.model.k1 = -5.3831e-1</span>
<span class="sd">        camera.model.k2 = 3.8214e-1</span>
<span class="sd">        camera.model.k3 = -2.0281e-1</span>
<span class="sd">        camera.model.p1 = 6.2239e-4</span>
<span class="sd">        camera.model.p2 = -1.2388e-4</span>
<span class="sd">        offset = 170.63</span>
<span class="sd">        a_d = 226648</span>
<span class="sd">        delta_temp = -0.04422</span>
<span class="sd">    else:</span>
<span class="sd">        print(&quot;warning, couldn&#39;t update to kinetx model...&quot;)</span>
<span class="sd">        offset = 155</span>
<span class="sd">        a_d = 0</span>
<span class="sd">        delta_temp = 0</span>

<span class="sd">    # only process long exposure images</span>
<span class="sd">    camera.only_long_on()</span>

<span class="sd">    # buld the opnav scene</span>
<span class="sd">    # determine the location of the shape info file</span>
<span class="sd">    path = os.path.dirname(os.path.realpath(args.shape))</span>
<span class="sd">    info_file = os.path.join(path, &#39;shape_info.txt&#39;)</span>
<span class="sd">    # load the pck for the shape file if it was found</span>
<span class="sd">    if os.path.exists(info_file):</span>
<span class="sd">        with open(info_file, &#39;r&#39;) as ifile:</span>
<span class="sd">            pck = None</span>
<span class="sd">            for line in ifile:</span>
<span class="sd">                if &#39;Pole:&#39; in line:</span>
<span class="sd">                    pck = line.split(&#39;:&#39;)[1].strip()</span>
<span class="sd">                    print(&#39;loading pck {}&#39;.format(pck))</span>
<span class="sd">                    spice.furnsh(pck)</span>
<span class="sd">                    args.pck = pck</span>
<span class="sd">                    break</span>

<span class="sd">            if pck is None:</span>
<span class="sd">                print(&#39;warning: no pole information found for shape model&#39;)</span>

<span class="sd">    # load the shape file</span>
<span class="sd">    bennukd.load(args.shape)</span>

<span class="sd">    # generate the scene</span>
<span class="sd">    opnav_scene = scene.Scene(target_objs=[bennuautoobj], light_obj=sunautoobj)</span>

<span class="sd">    # build the sopnav object</span>
<span class="sd">    ip_kwargs = {&quot;denoise_flag&quot;: True, &#39;return_stats&#39;: True, &#39;save_psf&#39;: True,</span>
<span class="sd">                 &#39;centroiding&#39;: IterativeGeneralizedGaussianWBackground,</span>
<span class="sd">                 &#39;reject_saturation&#39;: False,</span>
<span class="sd">                 &#39;image_flattening_noise_approximation&#39;: &#39;LOCAL&#39;}</span>

<span class="sd">    sid_kwargs = {&#39;use_mp&#39;: True}</span>

<span class="sd">    sopnav = StellarOpNav(camera, image_processing_kwargs=ip_kwargs, star_id_kwargs=sid_kwargs)</span>

<span class="sd">    # build the ufo object</span>
<span class="sd">    ufo = UFO(sopnav, opnav_scene, offset, a_d, delta_temp, version)</span>

<span class="sd">    # estimate the attitude</span>
<span class="sd">    ufo.update_attitude()</span>

<span class="sd">    # find the ufos</span>
<span class="sd">    ufo.find_ufos()</span>

<span class="sd">    # prepare the results for writing</span>
<span class="sd">    ufo.package_results()</span>

<span class="sd">    # write out the results</span>
<span class="sd">    ufo.save_results(args.output, split=(not args.no_split))</span>

<span class="sd">    # clear out spice and finish</span>
<span class="sd">    spice.kclear()</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>