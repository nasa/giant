<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.ufo.ekf_tracker &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.ufo.ekf_tracker</h1><div class="highlight"><pre>
<span></span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a class for tracking UFO detections across monocular images.</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">UFO tracking is done using Extended Kalman Filters to predict the locations of UFOs in subsequent images and then match</span>
<span class="sd">UFO detections in those images to the predict locations.  Multiple paths are followed for each possible particle</span>
<span class="sd">resulting in many possible tracks across all of the images.  Each of these possible tracks is then filtered to remove</span>
<span class="sd">extraneous tracks (and tracks that are subsets of other tracks) leaving only the tracks we are relatively confident in</span>
<span class="sd">the quality of.  Further description of the process can be found in the paper at</span>
<span class="sd">https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019EA000843</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">To track UFOs from image to image, initialize the :class:`.Tracker` class with the required information and then call</span>
<span class="sd">method :meth:`.Tracker.track`.  This will go through the whole process of initial tracking and then filtering for all</span>
<span class="sd">the possible particles in the loaded data, storing the results in the :attr:`.confirmed_tracks` and</span>
<span class="sd">:attr:`.confirmed_standard_deviations` lists.  You can also save the results to a csv file using method</span>
<span class="sd">:meth:`~.Tracker.save_results`.</span>

<span class="sd">You may also be interested in using the :class:`.UFO` class which combines both detection and tracking instead of using</span>
<span class="sd">this class directly.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span><span class="p">,</span> <span class="n">copy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">,</span> <span class="n">Array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing.sharedctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">SynchronizedArray</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tempfile</span><span class="w"> </span><span class="kn">import</span> <span class="n">TemporaryFile</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span><span class="p">,</span> <span class="n">sleep</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Full</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span>

<span class="c1"># no real risk hear because the pickle files are created by this script itself</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>  <span class="c1"># nosec</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">FileIO</span><span class="p">,</span> <span class="n">BufferedRandom</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">spiceypy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">spice</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.image</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpNavImage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ray_tracer.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">Scene</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ufo.extended_kalman_filter</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExtendedKalmanFilter</span><span class="p">,</span> <span class="n">STATE_INITIALIZER_TYPE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ufo.measurements</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpticalBearingMeasurement</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ufo.dynamics</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dynamics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.ufo.clearable_queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClearableQueue</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">PATH</span>


<span class="n">_LOGGER</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The logger to use to report status/errors/warning/results/etc</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">_ZERO_TIMEDELTA</span><span class="p">:</span> <span class="n">timedelta</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The 0 timedelta constant</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pickle_generator</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="n">FileIO</span> <span class="o">|</span> <span class="n">BufferedRandom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ExtendedKalmanFilter</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple generator to work through the pickled objects in a file</span>
<span class="sd">    :param file: the file object to work on</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># we are using pickle for swap essentially therefore there is no real risk</span>
            <span class="k">yield</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>  <span class="c1"># nosec</span>
        <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
            <span class="k">break</span>


<div class="viewcode-block" id="Tracker">
<a class="viewcode-back" href="../../../ufo/ekf_tracker/giant.ufo.ekf_tracker.Tracker.html#giant.ufo.ekf_tracker.Tracker">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Tracker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class provides an interface for autonomously tracking UFOs through subsequent images in time.</span>

<span class="sd">    There are 2 main components to this tracker.  The first is the use of EKFs to follow most of the possible paths</span>
<span class="sd">    forward from a single starting particle in an image.  This can result in hundreds of thousands (if not millions) of</span>
<span class="sd">    possible tracks for a set of images with fairly dense UFO detections.  The second component is then the filtering of</span>
<span class="sd">    these EKFs, which is done based on length (the number of measurements included in the EKF), post-fit residual</span>
<span class="sd">    statistics, and uniqueness (each starting particle only gets the best track assigned to it, and once a particle has</span>
<span class="sd">    been assigned to a track it can&#39;t be assigned to others).  This filtering process normally brings the number of</span>
<span class="sd">    tracks down to a much more manageable 10s to 100s.</span>

<span class="sd">    Explicit details on how this tracker works are provided in the paper at</span>
<span class="sd">    https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019EA000843 and are not repeated here.</span>

<span class="sd">    To use this class, provide the (numerous) initialization values (the defaults will be fine for many cases) and then</span>
<span class="sd">    call method :meth:`track`.  The results will then be stored in the :attr:`confirmed_filters`,</span>
<span class="sd">    :attr:`confirmed_particles`, and :attr:`confirmed_standard_deviations` attributes.  In general, you may not directly</span>
<span class="sd">    interact with this class however, and instead will use the :class:`UFO` interface class to both detect and track</span>
<span class="sd">    particles.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span> <span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span><span class="p">,</span>
                 <span class="n">dynamics</span><span class="p">:</span> <span class="n">Dynamics</span><span class="p">,</span>
                 <span class="n">state_initializer</span><span class="p">:</span> <span class="n">STATE_INITIALIZER_TYPE</span><span class="p">,</span>
                 <span class="n">search_distance_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ExtendedKalmanFilter</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">observation_trees</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">KDTree</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">observation_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_euclidean_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
                 <span class="n">measurement_covariance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">maximum_image_timedelta</span><span class="p">:</span> <span class="n">timedelta</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">maximum_paths_per_image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">maximum_paths_total</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
                 <span class="n">maximum_forward_images</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                 <span class="n">maximum_track_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
                 <span class="n">maximum_mahalanobis_distance_squared</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
                 <span class="n">expected_convergence_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
                 <span class="n">reduced_paths_forward_per_image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">minimum_number_of_measurements</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
                 <span class="n">maximum_residual_standard_deviation</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                 <span class="n">maximum_time_outs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                 <span class="n">maximum_tracking_time_per_image</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
                 <span class="n">kernels_to_load</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param camera: The :class:`.Camera` containing the images to process and the camera model</span>
<span class="sd">        :param scene: The :class:`.Scene` describing the location of the central body with respect to the camera.</span>
<span class="sd">        :param dynamics: The dynamics model to use in the EKF for propagating the state from one time to another</span>
<span class="sd">        :param state_initializer: A callable which takes in a :class:`.Measurement` instance and</span>
<span class="sd">                                  :class:`.Dynamics.State` class object and returns an initialized state.</span>
<span class="sd">        :param search_distance_function: A callable which takes in an :class:`.ExtendedKalmanFilter` and returns what</span>
<span class="sd">                                         the Euclidean search distance should be for that EKF in pixels.  This is only</span>
<span class="sd">                                         applied after the first pair has been made</span>
<span class="sd">        :param observation_trees: A list of scipy.spatial KDTree objects that are built on the pixel locations of the</span>
<span class="sd">                                  detections for each image</span>
<span class="sd">        :param observation_ids: A list of the ids for each observation contained in the trees in order.</span>
<span class="sd">        :param initial_euclidean_threshold: The threshold in pixels for points to be paired form the first image to a</span>
<span class="sd">                                            subsequent image.  This is not applied after the first pair has been made.</span>
<span class="sd">        :param measurement_covariance: The covariance matrix of the measurements as a 2x2 array.  This should have units</span>
<span class="sd">                                       of pixels squared.</span>
<span class="sd">        :param maximum_image_timedelta: The maximum time separation between images to attempt either initial or</span>
<span class="sd">                                        subsequent pairings as a ``timedelta`` object</span>
<span class="sd">        :param maximum_paths_per_image: The maximum number of forward paths for a single particle to the next image to</span>
<span class="sd">                                        consider</span>
<span class="sd">        :param maximum_paths_total: The total maximum number of forward paths for a single image across all images to</span>
<span class="sd">                                    consider</span>
<span class="sd">        :param maximum_forward_images: The maximum number of images to retrieve potential pairs from (images will be</span>
<span class="sd">                                       processed in time order)</span>
<span class="sd">        :param maximum_track_length: The maximum length of a track before it is artificially terminated.  The length of</span>
<span class="sd">                                     a track is defined as the number of measurements that it has ingested</span>
<span class="sd">        :param maximum_mahalanobis_distance_squared: The maximum squared Mahalanobis distance for subsequent (not</span>
<span class="sd">                                                     initial) observations to be paired to a track.</span>
<span class="sd">        :param expected_convergence_number: The number of ingested measurements at which point tracks are expected to be</span>
<span class="sd">                                            fairly converged.  At this point, more stringent filtering is used in</span>
<span class="sd">                                            determining forward paths.</span>
<span class="sd">        :param reduced_paths_forward_per_image: The number of paths forward per image that are considered once a track</span>
<span class="sd">                                                is considered converged.</span>
<span class="sd">        :param minimum_number_of_measurements: The minimum number of measurements in a track for it to be considered a</span>
<span class="sd">                                               potential good track.  Typically 4 should be the absolute minimum, but in</span>
<span class="sd">                                               some cases it may need to be even higher than that.</span>
<span class="sd">        :param maximum_residual_standard_deviation: The maximum standard deviation of the post-fit residuals in an EKF</span>
<span class="sd">                                                    for it to be considered a potentially good track.</span>
<span class="sd">        :param maximum_time_outs: The maximum number of time outs that can occur when attempting to retrieve tracking</span>
<span class="sd">                                  results from the children processes before we assume something has gone wrong and</span>
<span class="sd">                                  terminate all of the processes.</span>
<span class="sd">        :param maximum_tracking_time_per_image: The maximum amount of time to attempt tracking in the image before we</span>
<span class="sd">                                                assume something has gone wrong and terminate all of the processes.</span>
<span class="sd">        :param kernels_to_load: The spice kernels to load in each subprocess.  This is required if you are using spice</span>
<span class="sd">                                because the kernel pool does not subsist across processes.  It should either be</span>
<span class="sd">                                ``None`` if you&#39;re not using spice or a list of strings if you are.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span> <span class="o">=</span> <span class="n">camera</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`.Camera` containing the images to process and the camera model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">:</span> <span class="n">Scene</span> <span class="o">=</span> <span class="n">scene</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`.Scene` describing the location of the central body with respect to the camera.</span>
<span class="sd">        </span>
<span class="sd">        The central body should be the first &quot;target&quot; in the scene.  It doesn&#39;t need to have a shape associated with it</span>
<span class="sd">        (it can be a ``Point`` object) and in fact is encouraged not to (to avoid large memory overhead)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">KDTree</span><span class="p">]]</span> <span class="o">=</span> <span class="n">observation_trees</span> <span class="k">if</span> <span class="n">observation_trees</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of KDTrees built on the observed UFO locations.</span>
<span class="sd">        </span>
<span class="sd">        If any elements are ``None`` then it is assumed that no detections exist for that image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observation_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">observation_ids</span> <span class="k">if</span> <span class="n">observation_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of the ids for each observation contained in the trees.</span>
<span class="sd">        </span>
<span class="sd">        These should be unique ``Hashable`` objects like ints or strings, not mutable like lists/arrays/dictionaries.</span>
<span class="sd">        They should uniquely identify an observation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Process</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A List of Processes that are working</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_particles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A set of particles that have been assigned to a track already</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">:</span> <span class="n">Dynamics</span> <span class="o">=</span> <span class="n">dynamics</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dynamics model to use to propagate the states from one time to another.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_covariance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">measurement_covariance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The 2x2 measurement covariance matrix (or ``None`` to use the identify matrix) with units of pixels squared.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state_initializer</span><span class="p">:</span> <span class="n">STATE_INITIALIZER_TYPE</span> <span class="o">=</span> <span class="n">state_initializer</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The state initializer callable to use to initialize the state vector given the initial measurement and the type</span>
<span class="sd">        of the state vector to be initialized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_image_timedelta</span><span class="p">:</span> <span class="n">timedelta</span> <span class="o">=</span> <span class="n">maximum_image_timedelta</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum separation in time between images for them to be paired subsequently </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initial_euclidean_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">initial_euclidean_threshold</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The threshold in pixels for points to be paired from the first image to a subsequent image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">maximum_paths_per_image</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum number of pairs from one image to the next for a single possible particle</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_total</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">maximum_paths_total</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum number of pairs from one image to all images for a single particle</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_forward_images</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">maximum_forward_images</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum number of images to pair with</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_track_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">maximum_track_length</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum length of a track to consider before terminating.  </span>
<span class="sd">        </span>
<span class="sd">        the length of a track is defined as the number of measurements that it has ingested.</span>
<span class="sd">        </span>
<span class="sd">        This is necessary for memory management purposes as long tracks frequently have many variants that are being </span>
<span class="sd">        tracked and can take up a lot of memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">search_distance_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ExtendedKalmanFilter</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">search_distance_function</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function which returns what the search distance should be in pixels when trying to match the current EKF to </span>
<span class="sd">        new images.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_mahalanobis_distance_squared</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">maximum_mahalanobis_distance_squared</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the maximum Mahalanobis distance squared for a potential detection to be paired to a track</span>
<span class="sd">        </span>
<span class="sd">        The Mahalanobis distance is roughly equivalent to the sigma normalized error between the predicted and observed </span>
<span class="sd">        location.  Therefore a Mahalanobis distance squares of 25 roughly corresponds to only accepting pairings that </span>
<span class="sd">        are within 5 sigma of the predicted location.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expected_convergence_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">expected_convergence_number</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the number of measurements at which it is expected the filter will have mostly converged and we </span>
<span class="sd">        should become more selective with which paths forward we follow.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reduced_paths_forward_per_image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">reduced_paths_forward_per_image</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This specifies the reduced number of paths forward we should follow once the filter should be converged.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_number_of_measurements</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">minimum_number_of_measurements</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum number of measurements for an EKF to be considered a track.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_residual_standard_deviation</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maximum_residual_standard_deviation</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum post-fit standard deviation of the residuals in an EKF for it to be considered a valid fit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_time_outs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">maximum_time_outs</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum number of time outs in a row before we stop trying to process an image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maximum_tracking_time_per_image</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maximum_tracking_time_per_image</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum amount of time to attempt tracking in an image in seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClearableQueue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Queue used to specify what ekfs need to be processed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SynchronizedArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A shared array of boolean values specifying whether each processor is actively working</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClearableQueue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Queue used to communicate the results for the processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClearableQueue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClearableQueue</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SynchronizedArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Process</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A List of Processes that are working on smoothing</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_filters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ExtendedKalmanFilter</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list stores the confirmed EKFs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_standard_deviations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This list stores the standard deviation of the post-fit residuals of the confirmed EKFs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_respawns</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A counter for the number of times we have respawned our processes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_smoothing_respawns</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A counter for the number of times we have respawned our smoothing processes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kernels_to_load</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">kernels_to_load</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The spice kernels to load in each subprocess.  </span>
<span class="sd">        </span>
<span class="sd">        This is required if you are using spice because the kernel pool does not subsist across processes.  It should </span>
<span class="sd">        either be ``None`` if you&#39;re not using spice or a list of strings if you are.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Tracker.find_initial_pairs">
<a class="viewcode-back" href="../../../ufo/ekf_tracker/giant.ufo.ekf_tracker.Tracker.find_initial_pairs.html#giant.ufo.ekf_tracker.Tracker.find_initial_pairs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_initial_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method finds the initial pairs for the input image.</span>

<span class="sd">        This is done by identifying all observations in subsequent images within a specified number of pixels of the</span>
<span class="sd">        first identification (corrected for the movement of the observer in the time period)</span>

<span class="sd">        :param image_ind: The index of the image we are identifying the initial pairs for</span>
<span class="sd">        :param image: The image that we are identifying the initial pairs for</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The work queue is not initialized.  Initializing it&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_tracking_workers</span><span class="p">()</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processing image </span><span class="si">{</span><span class="n">image_ind</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># get the detections and ids</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">otree</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">[</span><span class="n">image_ind</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">detections</span> <span class="o">=</span> <span class="n">otree</span><span class="o">.</span><span class="n">data</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">detections</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">detection_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_ids</span><span class="p">[</span><span class="n">image_ind</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">detections</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">detection_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No detections for </span><span class="si">{</span><span class="n">image_ind</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span>

        <span class="c1"># initialize a list to store the ekfs in</span>
        <span class="n">filters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ExtendedKalmanFilter</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># update the scene to the current time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># get the camera position in the central body centered inertial frame</span>
        <span class="n">camera_position</span> <span class="o">=</span> <span class="o">-</span><span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># loop through and create the filter for each possible point in the current image</span>
        <span class="k">for</span> <span class="n">possible_id</span><span class="p">,</span> <span class="n">possible_detection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">detection_ids</span><span class="p">,</span> <span class="n">detections</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">possible_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_particles</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">camera_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span> <span class="n">camera_position</span><span class="p">)</span>
            <span class="n">initial_measurement</span> <span class="o">=</span> <span class="n">OpticalBearingMeasurement</span><span class="p">(</span><span class="n">possible_detection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
                                                            <span class="n">camera_location</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_covariance</span><span class="p">,</span>
                                                            <span class="n">identity</span><span class="o">=</span><span class="n">possible_id</span><span class="p">)</span>
            <span class="n">filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExtendedKalmanFilter</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_initializer</span><span class="p">,</span>
                                                <span class="n">initial_measurement</span><span class="o">=</span><span class="n">initial_measurement</span><span class="p">))</span>

        <span class="n">number_of_linked_images</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">next_image_index</span><span class="p">,</span> <span class="n">next_image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_image_index</span> <span class="o">&lt;=</span> <span class="n">image_ind</span><span class="p">:</span>
                <span class="c1"># don&#39;t want to go backwards</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next_image</span><span class="o">.</span><span class="n">observation_date</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_image_timedelta</span><span class="p">:</span>
                <span class="c1"># if this image too much later then break because we&#39;re done processing</span>
                <span class="k">break</span>

            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;linking image </span><span class="si">{</span><span class="n">image_ind</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="si">}</span><span class="s1"> with &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">next_image_index</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">next_image</span><span class="o">.</span><span class="n">observation_date</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># update the scene to the time for the next image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">next_image</span><span class="p">)</span>

            <span class="c1"># get the camera position for this image wrt the central body</span>
            <span class="n">next_camera_position</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">next_image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

            <span class="n">next_camera_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">(</span><span class="n">next_image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span> <span class="n">next_camera_position</span><span class="p">)</span>

            <span class="c1"># make a temporary measurement for telling the filter how to predict</span>
            <span class="n">temporary_next_measurement</span> <span class="o">=</span> <span class="n">OpticalBearingMeasurement</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                                   <span class="n">next_image</span><span class="p">,</span> <span class="n">next_camera_state</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">measurement_covariance</span><span class="p">)</span>

            <span class="c1"># get the predicted location of each point from the first image in this image</span>
            <span class="n">predicted_pixels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">predicted_states</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">removes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ekf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filters</span><span class="p">):</span>
                <span class="n">predicted_state</span><span class="p">,</span> <span class="n">predicted_observation</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">propagate_and_predict</span><span class="p">(</span><span class="n">temporary_next_measurement</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">predicted_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">removes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">predicted_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predicted_state</span><span class="p">)</span>
                <span class="n">predicted_pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predicted_observation</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">removes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">predicted_pixels</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No predicted locations for image </span><span class="si">{</span><span class="n">image_ind</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">next_image_index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># build the kdtree for the predicted locations in the next image so we can do a ball query</span>
            <span class="n">predicted_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">predicted_pixels</span><span class="p">))</span>

            <span class="c1"># do a ball query with the initial euclidean tolerance to figure out the initial pairs</span>
            <span class="n">full_pairs</span> <span class="o">=</span> <span class="n">predicted_kdtree</span><span class="o">.</span><span class="n">query_ball_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">],</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">initial_euclidean_threshold</span><span class="p">)</span>

            <span class="c1"># loop through each pair and create an EKF to follow the path</span>
            <span class="n">valid_pairs</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">predicted_index</span><span class="p">,</span> <span class="p">(</span><span class="n">ekf</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="n">full_pairs</span><span class="p">)):</span>

                <span class="n">number_of_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">number_of_pairs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">number_of_pairs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Too many forward paths </span><span class="si">{</span><span class="n">number_of_pairs</span><span class="si">}</span><span class="s1">.  &#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;Only taking </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="si">}</span><span class="s1"> closest&#39;</span><span class="p">)</span>
                    <span class="c1"># pairs = self.observation_trees[next_image_index].query_ball_point(</span>
                    <span class="c1">#     predicted_kdtree.data[predicted_index], self.initial_euclidean_threshold / 2</span>
                    <span class="c1"># )</span>

                    <span class="k">assert</span> <span class="p">(</span><span class="n">tree</span><span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">])</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="n">sorted_pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">pairs</span><span class="p">]</span> <span class="o">-</span>
                                                             <span class="n">predicted_kdtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">predicted_index</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">pairs</span><span class="p">))</span>

                    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_pairs</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="p">]]</span>

                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="si">}</span><span class="s1"> paths forward for track </span><span class="si">{</span><span class="n">ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="n">valid_pairs</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="n">next_observation_id</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_ids</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">next_observation_id</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_particles</span><span class="p">:</span>
                        <span class="c1"># skip particles we have already tracked</span>
                        <span class="k">continue</span>

                    <span class="c1"># clone the ekf to follow the path</span>
                    <span class="n">new_ekf</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ekf</span><span class="p">)</span>

                    <span class="c1"># get rid of the state initializer because it isn&#39;t needed anymore and makes problems with pickling</span>
                    <span class="n">new_ekf</span><span class="o">.</span><span class="n">state_initializer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pyright: ignore[reportAttributeAccessIssue]</span>

                    <span class="c1"># do the measurement update</span>
                    <span class="n">new_measurement</span> <span class="o">=</span> <span class="n">OpticalBearingMeasurement</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">KDTree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">])</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">],</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">next_image</span><span class="p">,</span> <span class="n">next_camera_state</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_covariance</span><span class="p">,</span>
                                                                <span class="n">identity</span><span class="o">=</span><span class="n">next_observation_id</span><span class="p">[</span><span class="n">pair</span><span class="p">])</span>

                    <span class="n">state_update</span> <span class="o">=</span> <span class="n">new_ekf</span><span class="o">.</span><span class="n">process_measurement</span><span class="p">(</span>
                        <span class="n">new_measurement</span><span class="p">,</span> <span class="n">pre_update_state</span><span class="o">=</span><span class="n">predicted_states</span><span class="p">[</span><span class="n">predicted_index</span><span class="p">],</span>
                        <span class="n">pre_update_predicted_measurement</span><span class="o">=</span><span class="n">predicted_pixels</span><span class="p">[</span><span class="n">predicted_index</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">state_update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Failed to propagate EKF </span><span class="si">{</span><span class="n">new_ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">put_retry</span><span class="p">(</span><span class="n">new_ekf</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">valid_pairs</span><span class="p">:</span>
                <span class="c1"># update the image counter</span>
                <span class="n">number_of_linked_images</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">number_of_linked_images</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_forward_images</span><span class="p">:</span>
                <span class="k">break</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_tracking_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method sets up the processes and queues for working on data in parallel for initial tracking.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">ClearableQueue</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="o">=</span> <span class="n">ClearableQueue</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_working</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pid</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;EKF Follower </span><span class="si">{</span><span class="n">pid</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">())]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_tracking_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets the Pool of workers, respawning any that have died and clears the queues/the work array</span>
<span class="sd">        for tracking workers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_respawns</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># fix any dead processes</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">process</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_follow</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ind</span><span class="p">,),</span>
                                          <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;EKF Follower </span><span class="si">{</span><span class="n">ind</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_respawns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tear_down_tracking_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method terminates the pool of workers and the queues used to communicate with them</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_smoothing_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method sets up the processes and queues for working on data in parallel for initial tracking.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span> <span class="o">=</span> <span class="n">ClearableQueue</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span> <span class="o">=</span> <span class="n">ClearableQueue</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_smooth</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pid</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Smoother </span><span class="si">{</span><span class="n">pid</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">())]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_smoothing_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets the Pool of workers, respawning any that have died and clears the queues/the work array</span>
<span class="sd">        for smoothing workers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_smoothing_respawns</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># fix any dead processes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">process</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_smooth</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ind</span><span class="p">,),</span>
                                                        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Smoother </span><span class="si">{</span><span class="n">ind</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_smoothing_respawns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tear_down_smoothing_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method terminates the pool of workers and the queues used to communicate with them</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_follow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves an EKF from the queue and follows it to completion</span>

<span class="sd">        This is used as the target for the Processes that are created.</span>

<span class="sd">        :param process_number: The number of the process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernels_to_load</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernels_to_load</span><span class="p">:</span>
                <span class="n">spice</span><span class="o">.</span><span class="n">furnsh</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The work queue hasn&#39;t been initialized&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The results queue hasn&#39;t been initialized&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The working array hasn&#39;t been initialized&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># retrieve an ekf from the queue to process</span>
                <span class="n">ekf</span><span class="p">:</span> <span class="n">ExtendedKalmanFilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">[</span><span class="n">process_number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">[</span><span class="n">process_number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;QUEUE was empty for process </span><span class="si">{</span><span class="n">process_number</span><span class="si">}</span><span class="s1"> but another process is still working.&#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;Process status: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># pyright: ignore[reportArgumentType]</span>
                    <span class="k">continue</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No more EKFs to follow&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">put_retry</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_track_length</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Too long of a track for ekf </span><span class="si">{</span><span class="n">ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1">, length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span><span class="si">}</span><span class="s1">, &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;stopping&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># create a list to store the paths forward for the current ekf</span>
            <span class="n">local_splits</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Following EKF: </span><span class="si">{</span><span class="n">ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1">.  Current length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># get the time of the last image included in the ekf</span>
            <span class="n">last_image_time</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>

            <span class="c1"># determine the accuracy this filter should have</span>
            <span class="n">search_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search_distance_function</span><span class="p">(</span><span class="n">ekf</span><span class="p">))</span>

            <span class="c1"># start a counter for the number of images we&#39;ve linked with</span>
            <span class="n">number_of_images_considered</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">next_image_index</span><span class="p">,</span> <span class="n">next_image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>

                <span class="n">time_delta</span> <span class="o">=</span> <span class="n">next_image</span><span class="o">.</span><span class="n">observation_date</span> <span class="o">-</span> <span class="n">last_image_time</span>

                <span class="k">if</span> <span class="n">time_delta</span> <span class="o">&lt;=</span> <span class="n">_ZERO_TIMEDELTA</span><span class="p">:</span>
                    <span class="c1"># skip if we are still before the current image.</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">time_delta</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_image_timedelta</span><span class="p">:</span>
                    <span class="c1"># stop if the next image is too far ahead in time</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># skip if there are no observations for this image</span>
                    <span class="k">continue</span>

                <span class="c1"># update the scene to the time of the current image</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">next_image</span><span class="p">)</span>

                <span class="c1"># get the current camera position with respect to the central body in the inertial frame</span>
                <span class="n">next_camera_position</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">next_image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">target_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

                <span class="n">next_camera_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamics</span><span class="o">.</span><span class="n">State</span><span class="p">(</span><span class="n">next_image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">,</span> <span class="n">next_camera_position</span><span class="p">)</span>

                <span class="n">temporary_next_measurement</span> <span class="o">=</span> <span class="n">OpticalBearingMeasurement</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                                       <span class="n">next_image</span><span class="p">,</span> <span class="n">next_camera_state</span><span class="p">,</span>
                                                                       <span class="bp">self</span><span class="o">.</span><span class="n">measurement_covariance</span><span class="p">)</span>

                <span class="c1"># predict the measurement at this time</span>
                <span class="n">predicted_state</span><span class="p">,</span> <span class="n">predicted_pixels</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">propagate_and_predict</span><span class="p">(</span><span class="n">temporary_next_measurement</span><span class="p">)</span>
                <span class="c1"># the state failed to propagate</span>
                <span class="k">if</span> <span class="n">predicted_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">predicted_pixels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="c1"># get the innovation matrix</span>
                <span class="n">last_measurement</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">measurement_jacobian</span> <span class="o">=</span> <span class="n">last_measurement</span><span class="o">.</span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">predicted_state</span><span class="p">)</span>
                <span class="n">innovation_covariance</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_measurement</span><span class="o">.</span><span class="n">covariance</span> <span class="o">+</span>
                                         <span class="n">measurement_jacobian</span><span class="nd">@predicted_state</span><span class="o">.</span><span class="n">covariance</span><span class="nd">@measurement_jacobian</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

                <span class="c1"># get the innovation information matrix by inverting the covariance matrix</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">information_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">innovation_covariance</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="n">information_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">innovation_covariance</span><span class="p">)</span>

                <span class="c1"># query the tree to get the potential next points using the search distance</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">next_tree</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_trees</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">pairs</span> <span class="o">=</span> <span class="n">next_tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">predicted_pixels</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">search_distance</span><span class="p">)</span>

                <span class="c1"># loop through and filter out paths that are already taken and don&#39;t meet the mahalanobis distance</span>

                <span class="c1"># create these lists to store pairs that require more consideration</span>
                <span class="n">keep_pairs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">keep_mahalanobis_distances</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="k">assert</span> <span class="p">(</span><span class="n">next_observation_ids</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_ids</span><span class="p">[</span><span class="n">next_image_index</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">next_observation_ids</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_particles</span><span class="p">:</span>
                        <span class="c1"># skip if we&#39;ve already used this particle</span>
                        <span class="k">continue</span>

                    <span class="c1"># compute the mahalanobis distance</span>
                    <span class="n">pixel_separation</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="n">predicted_pixels</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

                    <span class="n">mahalanobis_distance_squared</span> <span class="o">=</span> <span class="n">pixel_separation</span> <span class="o">@</span> <span class="n">information_matrix</span> <span class="o">@</span> <span class="n">pixel_separation</span>

                    <span class="c1"># check the squared mahalanobis distance</span>
                    <span class="k">if</span> <span class="n">mahalanobis_distance_squared</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_mahalanobis_distance_squared</span><span class="p">:</span>
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Rejected potential pair for </span><span class="si">{</span><span class="n">ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1"> due to mahalanobis distance &#39;</span>
                                      <span class="sa">f</span><span class="s1">&#39;of </span><span class="si">{</span><span class="n">mahalanobis_distance_squared</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># store this as a valid path forward</span>
                    <span class="n">keep_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                    <span class="n">keep_mahalanobis_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mahalanobis_distance_squared</span><span class="p">)</span>

                <span class="n">number_of_paths</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_pairs</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_convergence_number</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">number_of_paths</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduced_paths_forward_per_image</span><span class="p">)):</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The filter should be converged but there are still </span><span class="si">{</span><span class="n">number_of_paths</span><span class="si">}</span><span class="s2"> forward.&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Only keeping the </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">reduced_paths_forward_per_image</span><span class="si">}</span><span class="s2"> best ones&quot;</span><span class="p">)</span>

                    <span class="n">keep_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keep_mahalanobis_distances</span><span class="p">,</span>
                                                           <span class="n">keep_pairs</span><span class="p">))[:</span><span class="bp">self</span><span class="o">.</span><span class="n">reduced_paths_forward_per_image</span><span class="p">]]</span>

                <span class="k">elif</span> <span class="n">number_of_paths</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="n">number_of_paths</span><span class="si">}</span><span class="s2"> paths forward but only &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="si">}</span><span class="s2"> are allowed.&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Only keeping the </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="si">}</span><span class="s2"> best ones&quot;</span><span class="p">)</span>
                    <span class="n">keep_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keep_mahalanobis_distances</span><span class="p">,</span>
                                                           <span class="n">keep_pairs</span><span class="p">))[:</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_per_image</span><span class="p">]]</span>

                <span class="c1"># loop through all of the paths we are going to follow</span>
                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">keep_pairs</span><span class="p">:</span>
                    <span class="c1"># clone the ekf to follow this path</span>
                    <span class="n">new_ekf</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ekf</span><span class="p">)</span>

                    <span class="c1"># make a measurement for this pair</span>
                    <span class="n">new_measurement</span> <span class="o">=</span> <span class="n">OpticalBearingMeasurement</span><span class="p">(</span><span class="n">next_tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">],</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">next_image</span><span class="p">,</span> <span class="n">next_camera_state</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_covariance</span><span class="p">,</span>
                                                                <span class="n">identity</span><span class="o">=</span><span class="n">next_observation_ids</span><span class="p">[</span><span class="n">pair</span><span class="p">])</span>

                    <span class="c1"># perform a measurement update using this path</span>
                    <span class="n">new_ekf</span><span class="o">.</span><span class="n">process_measurement</span><span class="p">(</span><span class="n">new_measurement</span><span class="p">,</span> <span class="n">predicted_state</span><span class="p">,</span> <span class="n">predicted_pixels</span><span class="p">)</span>

                    <span class="c1"># add the new ekf to the queue to be processed</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adding </span><span class="si">{</span><span class="n">new_ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1"> to the queue. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ekfs_to_process</span><span class="o">.</span><span class="n">put_retry</span><span class="p">(</span><span class="n">new_ekf</span><span class="p">)</span>

                    <span class="c1"># store how many times we&#39;ve spit this ekf</span>
                    <span class="n">local_splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ekf</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_splits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_paths_total</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Too many forward splits for EKF </span><span class="si">{</span><span class="n">ekf</span><span class="o">.</span><span class="n">identity</span><span class="si">}</span><span class="s1">. </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">local_splits</span><span class="p">)</span><span class="si">}</span><span class="s1"> already. &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;Skipping more splits&#39;</span><span class="p">)</span>

                    <span class="k">break</span>

                <span class="n">number_of_images_considered</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">number_of_images_considered</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_forward_images</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># put the split ekfs as potential ending ekfs that need to be smoothed and analyzed further</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">put_retry</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">local_splits</span>
                                     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_number_of_measurements</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_working</span><span class="p">[</span><span class="n">process_number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">spice</span><span class="o">.</span><span class="n">kclear</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves an EKF from the queue and smooths it.</span>

<span class="sd">        The smoothed EKF is then placed into the output queue</span>

<span class="sd">        This is used as the target for the Processes that are created for smoothing.</span>

<span class="sd">        :param process_number: The number of the process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernels_to_load</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernels_to_load</span><span class="p">:</span>
                <span class="n">spice</span><span class="o">.</span><span class="n">furnsh</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The work queue hasn&#39;t been initialized&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The results queue hasn&#39;t been initialized&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The working array hasn&#39;t been initialized&quot;</span><span class="p">)</span>

        <span class="n">num_time_out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">incoming</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ExtendedKalmanFilter</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">incoming</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">[</span><span class="n">process_number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span><span class="o">.</span><span class="n">put_retry</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received </span><span class="si">{</span><span class="n">incoming</span><span class="si">}</span><span class="s2"> which is not expected&quot;</span><span class="p">)</span>

                    <span class="k">break</span>

                <span class="n">ind</span><span class="p">,</span> <span class="n">ekf</span> <span class="o">=</span> <span class="n">incoming</span>

                <span class="n">num_time_out</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># retrieve an ekf form the queue to process</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">[</span><span class="n">process_number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">[</span><span class="n">process_number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">num_time_out</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;QUEUE was empty for process </span><span class="si">{</span><span class="n">process_number</span><span class="si">}</span><span class="s1"> but another process is still working.&#39;</span>
                                  <span class="sa">f</span><span class="s1">&#39;Process status: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_working</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># pyright: ignore[reportArgumentType]</span>
                    <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">num_time_out</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_time_outs</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No more EKFs to smooth&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span><span class="o">.</span><span class="n">put_retry</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">process_number</span><span class="si">}</span><span class="s1"> timed out </span><span class="si">{</span><span class="n">num_time_out</span><span class="si">}</span><span class="s1"> times&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="n">smooth_successful</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">smooth</span><span class="p">()</span>

            <span class="n">sent</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">number_failed</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">while</span> <span class="ow">not</span> <span class="n">sent</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span><span class="o">.</span><span class="n">put_retry</span><span class="p">((</span><span class="n">smooth_successful</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ekf</span><span class="p">))</span>
                    <span class="n">sent</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="n">Full</span><span class="p">:</span>
                    <span class="n">number_failed</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="n">number_failed</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unable to put the smoothed results on the queue&#39;</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="n">spice</span><span class="o">.</span><span class="n">kclear</span><span class="p">()</span>

<div class="viewcode-block" id="Tracker.filter_ekfs">
<a class="viewcode-back" href="../../../ufo/ekf_tracker/giant.ufo.ekf_tracker.Tracker.filter_ekfs.html#giant.ufo.ekf_tracker.Tracker.filter_ekfs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_ekfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ekfs_to_filter</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">ExtendedKalmanFilter</span><span class="p">],</span> <span class="n">number_of_ekfs</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method does backwards smoothing on each EKF and figures out which are actually valid</span>

<span class="sd">        :param ekfs_to_filter: The list of EKFs to filter</span>
<span class="sd">        :param number_of_ekfs: The number of ekfs there are to filter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">removes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">residual_means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">residual_stds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">smoothed_ekfs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ExtendedKalmanFilter</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_ekfs</span>

        <span class="n">processes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Process</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span>
        <span class="n">smooth_process</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Process</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">smooth_process</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="n">processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="o">=</span> <span class="n">smooth_process</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ekf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ekfs_to_filter</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_number_of_measurements</span><span class="p">:</span>
                <span class="n">removes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="k">continue</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span><span class="o">.</span><span class="n">put_retry</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="n">ekf</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span><span class="o">.</span><span class="n">put_retry</span><span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">)</span>

        <span class="n">number_timed_out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">number_not_done</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">number_not_done</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ExtendedKalmanFilter</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_output</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># reset the counter</span>
                <span class="n">number_timed_out</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="s1">&#39;DONE&#39;</span><span class="p">):</span>
                        <span class="n">number_not_done</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">number_not_done</span><span class="si">}</span><span class="s1"> processes still smoothing.  Approximately &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_input</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span><span class="si">}</span><span class="s1"> things still to do&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;received an unexpected </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># compute and store the standard deviation and mean</span>
                    <span class="n">resid_mean</span><span class="p">,</span> <span class="n">resid_std</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">compute_residual_statistics</span><span class="p">()</span>

                    <span class="n">residual_means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resid_mean</span><span class="p">)</span>
                    <span class="n">residual_stds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resid_std</span><span class="p">)</span>

                    <span class="c1"># store the smoothed ekf</span>
                    <span class="n">smoothed_ekfs</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we didn&#39;t smooth so remove this</span>
                    <span class="n">removes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                <span class="n">number_timed_out</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Timed out trying to retrieve smoothed results </span><span class="si">{</span><span class="n">number_timed_out</span><span class="si">}</span><span class="s1"> times&#39;</span><span class="p">)</span>

        <span class="c1"># get rid of things that were too short or didn&#39;t smooth</span>
        <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">removes</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">smoothed_ekfs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>

        <span class="c1"># kill the processes</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Identifying valid EKFs from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smoothed_ekfs</span><span class="p">)</span><span class="si">}</span><span class="s1"> total&#39;</span><span class="p">)</span>

        <span class="n">id_sets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># filter out where the residuals are greater than the maximum standard deviation</span>
        <span class="c1"># also prepare the sets of particle ids</span>
        <span class="n">removes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">ekf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">residual_stds</span><span class="p">,</span> <span class="n">smoothed_ekfs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">std</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_residual_standard_deviation</span><span class="p">:</span>
                <span class="n">removes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># store the set of the measurement ids</span>
            <span class="k">assert</span> <span class="n">ekf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">id_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">meas</span><span class="o">.</span><span class="n">identity</span> <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">})</span>

        <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">removes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">smoothed_ekfs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="n">residual_stds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="n">residual_means</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>

        <span class="n">removes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through and figure out which ekfs are subsets of the others</span>
        <span class="k">for</span> <span class="n">first_ind</span><span class="p">,</span> <span class="n">first_meas_id_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">id_sets</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">second_ind</span><span class="p">,</span> <span class="n">second_meas_id_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">id_sets</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">first_ind</span> <span class="o">==</span> <span class="n">second_ind</span><span class="p">:</span>
                    <span class="c1"># if this is the same set then skip it</span>
                    <span class="k">continue</span>

                <span class="c1"># get the points which are in the first ekf but not the second ekf</span>
                <span class="n">first_unique</span> <span class="o">=</span> <span class="n">first_meas_id_set</span> <span class="o">-</span> <span class="n">second_meas_id_set</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># if the first ekf is a full subset of the later ekf then remove it</span>
                    <span class="n">removes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_ind</span><span class="p">)</span>
                    <span class="k">break</span>  <span class="c1"># we no longer need to consider this ekf</span>

                <span class="c1"># if the first ekf only has 1 unique point and the other has multiple unique points then then other</span>
                <span class="c1"># is a longer track and should be kept over this one</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first_unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">second_meas_id_set</span> <span class="o">-</span> <span class="n">first_meas_id_set</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">removes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_ind</span><span class="p">)</span>
                    <span class="k">break</span>  <span class="c1"># we no longer need to consider this ekf</span>


        <span class="c1"># remove things that should be removed (we might have duplicates so ignore them and unique sorts for us)</span>
        <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">removes</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">smoothed_ekfs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="n">residual_stds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="n">residual_means</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="n">id_sets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>

        <span class="c1"># now figure out which track is best for each starting particle</span>
        <span class="n">starting_dictionary</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ekf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">smoothed_ekfs</span><span class="p">):</span>

            <span class="c1"># get the initial particle in this track</span>
            <span class="k">assert</span> <span class="n">ekf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">start_id</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">identity</span>

            <span class="c1"># see if we&#39;ve considered other tracks that contain this particle already</span>
            <span class="n">current_best</span> <span class="o">=</span> <span class="n">starting_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">start_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># if this is the first track starting on this particle keep it for now</span>
            <span class="k">if</span> <span class="n">current_best</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current_best</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">residual_stds</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">starting_dictionary</span><span class="p">[</span><span class="n">start_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_best</span>
                <span class="k">continue</span>

            <span class="c1"># compare the number of measurements of the current best track starting with this particle and the track</span>
            <span class="c1"># under consideration</span>
            <span class="n">length_current_best</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_sets</span><span class="p">[</span><span class="n">current_best</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">length_under_consideration</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_sets</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">length_under_consideration</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">length_current_best</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># if the EKF under consideration has 2 or more measurements than the current best keep it</span>
                <span class="n">starting_dictionary</span><span class="p">[</span><span class="n">start_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">residual_stds</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">length_current_best</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">length_under_consideration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># if the current best has 2 or more measurements than the EKF under consideration keep it</span>
                <span class="k">continue</span>

            <span class="c1"># if the EKF under consideration and the current best are within 1 measurement of each other keep the</span>
            <span class="c1"># one with a lower post-fit std</span>
            <span class="k">elif</span> <span class="n">current_best</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">residual_stds</span><span class="p">[</span><span class="n">ind</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">starting_dictionary</span><span class="p">[</span><span class="n">start_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">residual_stds</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

        <span class="c1"># store the confirmed EKFs and ingested particles</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">std</span> <span class="ow">in</span> <span class="n">starting_dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smoothed_ekfs</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_standard_deviations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_particles</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">id_sets</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span></div>


<div class="viewcode-block" id="Tracker.track">
<a class="viewcode-back" href="../../../ufo/ekf_tracker/giant.ufo.ekf_tracker.Tracker.track.html#giant.ufo.ekf_tracker.Tracker.track">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">track</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method tracks particles from image to image using the EKF.</span>

<span class="sd">        This works by finding initial pairs for each image and then following those tracks to termination. It also</span>
<span class="sd">        handles setup and teardown of the working pool.  It then filters all of the tracks, saving only the good ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize the worker pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_tracking_workers</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_smoothing_workers</span><span class="p">()</span>

        <span class="c1"># loop through each image and identify the tracks that begin in that image</span>
        <span class="n">first</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

            <span class="c1"># do the initial pairing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_initial_pairs</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>


            <span class="c1"># reset the tracking workers for the next image</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tracking_workers</span><span class="p">()</span>

            <span class="c1"># start the process of tracking along these initial pairs</span>
            <span class="n">processes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Process</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span>
            <span class="n">smooth_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processes</span> <span class="o">=</span> <span class="n">processes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_processes</span> <span class="o">=</span> <span class="n">smooth_process</span>

            <span class="c1"># self._follow(-1)</span>

            <span class="c1"># loop through, retrieving the results</span>
            <span class="n">ekfs</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">number_to_complete</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">)</span>
            <span class="n">number_timed_out</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="k">with</span> <span class="n">TemporaryFile</span><span class="p">(</span><span class="s1">&#39;wb+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ekfs_to_smooth</span><span class="p">:</span>

                <span class="k">while</span> <span class="n">number_to_complete</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                        <span class="c1"># if the process said it is done processing then decrease the number to complete and move along</span>
                        <span class="k">if</span> <span class="n">results</span> <span class="o">==</span> <span class="s1">&#39;DONE&#39;</span><span class="p">:</span>
                            <span class="n">number_to_complete</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">number_to_complete</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All processes completed.  </span><span class="si">{</span><span class="n">ekfs</span><span class="si">}</span><span class="s1"> generated&#39;</span><span class="p">)</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tracking process has completed, </span><span class="si">{</span><span class="n">number_to_complete</span><span class="si">}</span><span class="s1"> still working&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>

                            <span class="c1"># otherwise we got new results and should store them</span>
                            <span class="c1"># ekfs.extend(results)</span>
                            <span class="k">for</span> <span class="n">ekf</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ekf</span><span class="p">,</span> <span class="n">ekfs_to_smooth</span><span class="p">)</span>
                                <span class="n">ekfs</span> <span class="o">+=</span> <span class="mi">1</span>

                            <span class="c1"># reset the number timed out</span>
                            <span class="n">number_timed_out</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                        <span class="n">number_timed_out</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">number_timed_out</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_time_outs</span><span class="p">:</span>
                            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Exceeded the maximum number of time outs.  Stopping&#39;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">:</span>
                                <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                                <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                                    <span class="k">pass</span>
                            <span class="k">break</span>

                    <span class="c1"># check if we&#39;ve reached our overall time lime</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_tracking_time_per_image</span><span class="p">:</span>
                        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Exceeded maximum execution time. Stopping&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes</span><span class="p">:</span>
                            <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                            <span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                                <span class="k">pass</span>
                        <span class="k">break</span>

                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tracking complete for image </span><span class="si">{</span><span class="n">ind</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">image_mask</span><span class="p">)</span><span class="si">}</span><span class="s1"> in &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>

                <span class="c1"># filter the ekfs and save only the good ones</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reset_smoothing_workers</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">ekfs_to_smooth</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_ekfs</span><span class="p">(</span><span class="n">_pickle_generator</span><span class="p">(</span><span class="n">ekfs_to_smooth</span><span class="p">),</span> <span class="n">ekfs</span><span class="p">)</span>

        <span class="c1"># tear down the workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tear_down_smoothing_workers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tear_down_tracking_workers</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tracker.save_results">
<a class="viewcode-back" href="../../../ufo/ekf_tracker/giant.ufo.ekf_tracker.Tracker.save_results.html#giant.ufo.ekf_tracker.Tracker.save_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">PATH</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method saves the final ekfs to a csv file.</span>

<span class="sd">        The files in the csv file are</span>

<span class="sd">        ================== =============================================================================================</span>
<span class="sd">        Column             Description</span>
<span class="sd">        ================== =============================================================================================</span>
<span class="sd">        id                 The ID for the EKF.  This is usually a UUID hash string</span>
<span class="sd">        length             The length of the EKF (number of measurements it ingested)</span>
<span class="sd">        residual std       The standard deviation of the post-fit residuals of the EKF</span>
<span class="sd">        initial time       The UTC time of the initial state for the EKF</span>
<span class="sd">        initial position x The x position of the initial state for the EKF</span>
<span class="sd">        initial position y The y position of the initial state for the EKF</span>
<span class="sd">        initial position z The z position of the initial state for the EKF</span>
<span class="sd">        initial velocity x The x velocity of the initial state for the EKF</span>
<span class="sd">        initial velocity y The y velocity of the initial state for the EKF</span>
<span class="sd">        initial velocity z The z velocity of the initial state for the EKF</span>
<span class="sd">        detection ids      A list of detection ids (dependent on the IDs of the UFO detections) separated by &#39;|&#39;</span>
<span class="sd">        ================== =============================================================================================</span>

<span class="sd">        :param out: The file to save the csv to</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">Path</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
            <span class="n">out_format</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;length&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;residual std&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial time&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial position x&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial position y&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial position z&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial velocity x&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial velocity y&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;initial velocity z&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;detection ids&#39;</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">ekf</span><span class="p">,</span> <span class="n">std</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">confirmed_filters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">confirmed_standard_deviations</span><span class="p">):</span>
                <span class="n">initial_state</span><span class="p">:</span> <span class="n">Dynamics</span><span class="o">.</span><span class="n">State</span> <span class="o">=</span> <span class="n">ekf</span><span class="o">.</span><span class="n">state_history</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span>
                                                 <span class="nb">len</span><span class="p">(</span><span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">),</span>
                                                 <span class="n">std</span><span class="p">,</span>
                                                 <span class="n">initial_state</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span>
                                                 <span class="o">*</span><span class="n">initial_state</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                                                 <span class="o">*</span><span class="n">initial_state</span><span class="o">.</span><span class="n">velocity</span><span class="p">,</span>
                                                 <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">meas</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span> <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">ekf</span><span class="o">.</span><span class="n">measurement_history</span><span class="p">)))</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>