<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.ray_tracer.rays &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.ray_tracer.rays</h1><div class="highlight"><pre>
<span></span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines a class for representing rays in GIANT, a function to generate them from a camera model, and the</span>
<span class="sd">numpy structured data type used to store the results of a ray trace.</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">In GIANT, A :class:`.Rays` is used in ray tracing to intersect with a surface.  It is defined fully by a start, a</span>
<span class="sd">direction, and an inverse direction (1/direction).  Rays are defined to be efficient in GIANT, making use of numpy</span>
<span class="sd">broadcasting so that you can efficiently have a single start for many directions or many starts for a single direction,</span>
<span class="sd">and also support translation and rotation like other ray tracer objects.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">Rays are used frequently in GIANT.  They&#39;re pretty simple to create (simply provide the start and direction as numpy</span>
<span class="sd">arrays) and can be directly created for pixels from a camera in the camera frame using :func:`.compute_rays`.  Once</span>
<span class="sd">they&#39;re created they can be used for tracing :mod:`.shapes`, :class:`.KDTree`, :class:`.Scene`, and</span>
<span class="sd">:class:`.SceneObject` and for generating illumination inputs.  In addition, you can ignore certain facets (for surfaces)</span>
<span class="sd">or entire solids when tracing rays, using the :attr:`.ignore` attribute of the :class:`.Rays` class.  The format that</span>
<span class="sd">the ids for the ignore attribute take are somewhat complicated, so be sure to read the documentation carefully if you</span>
<span class="sd">are planning to use this feature.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Self</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera_models.camera_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">CameraModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span> 


<span class="n">INTERSECT_DTYPE</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                      <span class="p">(</span><span class="s1">&#39;intersect&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span> <span class="p">(</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                                      <span class="p">(</span><span class="s1">&#39;albedo&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;facet&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The numpy datatype returned when rays are traced with a :mod:`.shapes` or :class:`.KDTree` in GIANT.</span>

<span class="sd">For an overview of how structured data types work in numpy, refer to https://numpy.org/doc/stable/user/basics.rec.html</span>

<span class="sd">The following table describes the purpose of each field.  </span>

<span class="sd">================ ================ ======================================================================================</span>
<span class="sd">Field            Type             Description</span>
<span class="sd">================ ================ ======================================================================================</span>
<span class="sd">check            bool             A boolean flag specifying if the ray hit the object</span>
<span class="sd">distance         double           The distance between the ray start and the intersect location (if the ray struck the </span>
<span class="sd">                                  object)</span>
<span class="sd">intersect        3 element double The location that the ray struck the object in the current frame (if the ray struck </span>
<span class="sd">                 the object)</span>
<span class="sd">normal           3 element double The unit vector that is normal to the surface at the point the ray struck the object</span>
<span class="sd">                                  as a 3 element array (if the ray struck the object)</span>
<span class="sd">albedo           double           The albedo of the surface as a float</span>
<span class="sd">facet            int64            The id of the facet(if traced against a surface)/solid (if traced against a solid) </span>
<span class="sd">                                  that the ray struck (if the ray struck the object).  This will be the fully encoded id</span>
<span class="sd">                                  so that you could use it in subsequent calls to trace to ignore that facet if so </span>
<span class="sd">                                  desired.</span>
<span class="sd">================ ================ ======================================================================================</span>

<span class="sd">In general, anywhere that ``check`` is not ``True`` has no guarantee on the values of the other elements.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># todo: consider updating the init to accept the inv directions for faster indexing</span>

<div class="viewcode-block" id="Rays">
<a class="viewcode-back" href="../../../ray_tracer/rays/giant.ray_tracer.rays.Rays.html#giant.ray_tracer.rays.Rays">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Rays</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to store/manipulate rays.</span>

<span class="sd">    In GIANT a ray is defined by a start and a direction (and optionally a list of ids to ignore when tracing a ray</span>
<span class="sd">    through a scene/to a shape.  In addition, given these inputs, this class automatically computes the inverse</span>
<span class="sd">    direction (1/direction) which is used when intersecting the rays with an axis aligned bounding box.</span>

<span class="sd">    When creating rays, if you are creating multiple rays that share the same :attr:`start` or the same</span>
<span class="sd">    :attr:`direction` you should input these as a single array of length 3 (not 3x1).  This will allow us to use</span>
<span class="sd">    numpy broadcasting rules to efficiently represent the rays without having to duplicate memory.  In addition, you can</span>
<span class="sd">    update the start/direction of the rays by using the :meth:`rotate` and :meth:`translate` methods, or by setting to</span>
<span class="sd">    the :attr:`start` and :attr:`direction` directly.</span>

<span class="sd">    To use the :attr:`ignore` attribute of the rays you need to encode the full id of whatever you are trying to ignore.</span>
<span class="sd">    This can be very tricky and depends on what your tracing the rays against.  For instance, if you are directly</span>
<span class="sd">    tracing the rays with a :class:`.RawSurface` like a :class:`.Triangle64` then the id is simply the facet number (row</span>
<span class="sd">    number in the :attr:`.RawSurface.facets` array).  If you are tracing with a :class:`.Solid`, then the id is the</span>
<span class="sd">    :attr:`.Solid.id`.  If you are tracing with a :class:`.KDTree` then the id needs to be a combination of the ids of</span>
<span class="sd">    the path through the tree to the leaf node containing the facet, plus the row number for the facet in the</span>
<span class="sd">    :attr:`.KDNode.surface` of the leaf node (this can conveniently be determined using :func:`.get_ignore_inds`).  If</span>
<span class="sd">    you are tracing with a scene, then you need to take the id of the geometry combined with index of the scene object</span>
<span class="sd">    in the :attr:`.Scene.target_objs` list.  All of these get combined into a single integer.  Given this, it is rare to</span>
<span class="sd">    set the :attr:`ignore` attribute yourself.  Instead, typically you either let GIANT set the attribute for you</span>
<span class="sd">    automatically, or you get the value from a previous trace (the ``facet`` component of :data:`.INTERSECT_DTYPE` will</span>
<span class="sd">    fully encode the id for whatever you traced through).</span>

<span class="sd">    This class supports iterating through rays one at a time using the normal python syntax (``for ray in rays: ...``).</span>
<span class="sd">    That being said, this is not super efficient and is not the way GIANT handles multiple rays internally.  You can</span>
<span class="sd">    also use indexing on the :class:`.Rays` object, which will return another :class:`.Rays` object.  This can be useful</span>
<span class="sd">    for things like boolean indexing and slicing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">ignore</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY_LIKE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param start: Where the rays begin at as a length 3 array or a 3xn array</span>
<span class="sd">        :param direction: The direction that the rays proceed in as a length 3 array or a 3xn array (typically this</span>
<span class="sd">                          should be unit vectors)</span>
<span class="sd">        :param ignore: The ids to ignore when tracing the rays.  This should be either ``None`` for no ignores, a length</span>
<span class="sd">                       n array for a single ignore per ray (set to -1 for rays where you don&#39;t want any ignores), or a</span>
<span class="sd">                       length n Sequence of arrays (where there are multiple (possibly different numbers) ignores for</span>
<span class="sd">                       each ray)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set up the hidden attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of rays contained in the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_start_and_direction</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_direction</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1"># use the property setters to handle things effectively</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">ignore</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Rays&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate 1 at a time through the rays contained in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">starts</span><span class="p">,</span> <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>

                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">ignore</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">directions</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">Rays</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">directions</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">Rays</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">directions</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">Rays</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">yield</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;Rays&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a subset of the rays contained in this object.</span>

<span class="sd">        Typically this is used with slicing and boolean indexing</span>

<span class="sd">        :param item: The value to use to index with</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">starts</span><span class="p">,</span> <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

                    <span class="k">return</span> <span class="n">Rays</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">directions</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">return</span> <span class="n">Rays</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">directions</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="n">Rays</span><span class="p">(</span><span class="n">starts</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">directions</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot get item from a single ray.&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rays contained in the object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span>

<div class="viewcode-block" id="Rays.rotate">
<a class="viewcode-back" href="../../../ray_tracer/rays/giant.ray_tracer.rays.Rays.rotate.html#giant.ray_tracer.rays.Rays.rotate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the start location(s) and the direction(s) of the ray(s) in place.</span>

<span class="sd">        :param rotation:  an array representing a rotation or a :class:`.Rotation` object by which to rotate the rays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Rotation</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Rotation</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_direction</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Rays.translate">
<a class="viewcode-back" href="../../../ray_tracer/rays/giant.ray_tracer.rays.Rays.translate.html#giant.ray_tracer.rays.Rays.translate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translates the start location(s) of the ray(s) in place.</span>

<span class="sd">        The directions are not affected by this method.</span>

<span class="sd">        :param translation: an array like vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">translation_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">translation_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">translation_array</span> <span class="o">=</span> <span class="n">translation_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">+=</span> <span class="n">translation_array</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The beginning location(s) of the ray(s) as an 3xn array of start locations (if n==1 then a flat 3 component</span>
<span class="sd">        array is returned).</span>

<span class="sd">        If there are multiple directions and only a single start then this will still return a 3xn array but will use</span>
<span class="sd">        numpy broadcasting so that memory is not duplicated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">starts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">starts</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

    <span class="nd">@start</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_start_and_direction</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_start_and_direction</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span><span class="p">]:</span>
        <span class="n">start_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">direction_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">start_array</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The first axis of the start array must have a length of 3&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">direction_array</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="p">(</span><span class="n">direction_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The first axis of the direction array must have a length of 3&quot;</span><span class="p">)</span>
        
        <span class="n">num_rays</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">start_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">direction_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">direction_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The start and direction arrays must have the same shape.&quot;</span><span class="p">)</span>

            <span class="n">num_rays</span> <span class="o">=</span> <span class="n">start_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">direction_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">num_rays</span> <span class="o">=</span> <span class="n">direction_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">num_rays</span><span class="p">,</span> <span class="n">start_array</span><span class="p">,</span> <span class="n">direction_array</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The direction vector(s) of the ray(s) as an 3xn array of vector(s)  (if n==1 then a flat 3 component array is</span>
<span class="sd">        returned).</span>

<span class="sd">        If there are multiple starts and only a single direction then this will still return a 3xn array but will use</span>
<span class="sd">        numpy broadcasting so that memory is not duplicated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">directions</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span>

    <span class="nd">@direction</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_start_and_direction</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inv_direction</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direction</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inv_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DOUBLE_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The inverse of the direction vectors (1/directions) as a 3xn array (if n==1 then a flat 3 component array is</span>
<span class="sd">        returned).</span>

<span class="sd">        If there are multiple starts and only a single direction then this will still return a 3xn array but will use</span>
<span class="sd">        numpy broadcasting so that memory is not duplicated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">inv_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_direction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">inv_directions</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_direction</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An array of the full ids of whatever you are trying to ignore for specific rays or None.</span>

<span class="sd">        This is generally used when illuminating a scene as a way to ignore the surface that a ray starts at.  See the</span>
<span class="sd">        class documentation for more details on how this mush be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span>

    <span class="nd">@ignore</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The ignore array must be integral&#39;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>



<div class="viewcode-block" id="compute_rays">
<a class="viewcode-back" href="../../../ray_tracer/rays/giant.ray_tracer.rays.compute_rays.html#giant.ray_tracer.rays.compute_rays">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_rays</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">cols</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">image_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Rays</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute rays passing through the given row, col pairs for the given camera in the camera frame.</span>

<span class="sd">    The rays are assumed to start at the origin of the camera frame (0, 0, 0).  The directions are formed by calls to</span>
<span class="sd">    :meth:`.CameraModel.pixels_to_unit` and are generate all at once.  The pixel values corresponding to the generated</span>
<span class="sd">    rays are returned second as a 2xn array.</span>

<span class="sd">    When creating the rays, you can specify how many rays per pixel you want to generate (evenly distributed in a square</span>
<span class="sd">    subpixel pattern) using the ``grid_size`` argument.  The result will be</span>

<span class="sd">    .. code::</span>

<span class="sd">           1  2        grid_size</span>
<span class="sd">        +------ ... ------+</span>
<span class="sd">        |                 |</span>
<span class="sd">        |                 |</span>
<span class="sd">        |  x  x ... x  x  | 1</span>
<span class="sd">        |                 |</span>
<span class="sd">        |                 |</span>
<span class="sd">        |  x  x ... x  x  | 2</span>
<span class="sd">        ...             ...</span>
<span class="sd">        |  x  x ... x  x  | grid_size -1</span>
<span class="sd">        |                 |</span>
<span class="sd">        |                 |</span>
<span class="sd">        |  x  x ... x  x  | grid_size</span>
<span class="sd">        |                 |</span>
<span class="sd">        |                 |</span>
<span class="sd">        +------ ... ------+</span>

<span class="sd">    where +-| indicates the bounds of the pixel, and x indices subpixel locations for the rays (with even spacing</span>
<span class="sd">    between each sub-pixel location and the edges of the pixel.</span>

<span class="sd">    :param model: A camera model object which is used to set the direction for the rays</span>
<span class="sd">    :param rows: An array like list of rows to generate rays through (paired with cols).  If there are only 2 elements</span>
<span class="sd">                 then it is assumed that this is a min, max pair (inclusive on both sides)  and you want to generate</span>
<span class="sd">                 rays for every pixel between min and max</span>
<span class="sd">    :param cols: An array like list of cols to generate rays through (paired with rows).  If there are only 2 elements</span>
<span class="sd">                 then it is assumed that this is a min, max pair (inclusive on both sides)  and you want to generate</span>
<span class="sd">                 rays for every pixel between min and max</span>
<span class="sd">    :param grid_size: The number of rays per edge of pixel (sqrt of number of rays).  There will be</span>
<span class="sd">                      ``grid_size*grid_size`` rays evenly distributed through the area of each pixel pair requested</span>
<span class="sd">    :param temperature: The temperature of the image the rays are being computed for passed to</span>
<span class="sd">                        :meth:`.CameraModel.pixels_to_unit`</span>
<span class="sd">    :param image_number: The number of the image the rays are being created for pass to</span>
<span class="sd">                         :meth:`.CameraModel.pixels_to_unit`</span>
<span class="sd">    :return: The rays passing through the requested pixels in the camera frame and the subpixel locations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rows must be 1 dimentional&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cols</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cols must be 1 dimentional&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">rows</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rows must be of integral type&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cols must be of integral type&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># determine the spacing between each grid point in pixels</span>
        <span class="n">grid_dist</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">grid_size</span>

        <span class="c1"># determine where in the pixel the grid will start at</span>
        <span class="n">grid_start</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">grid_dist</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># get the subpixel locations for each ray</span>
        <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid_start</span><span class="p">,</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">grid_dist</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid_start</span><span class="p">,</span> <span class="n">rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">grid_dist</span><span class="p">))</span>

    <span class="c1"># stack the columns and rows into a single xy matrix</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cols</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">rows</span><span class="o">.</span><span class="n">ravel</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># get the direction vectors for each ray</span>
    <span class="n">directions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image_number</span><span class="p">)</span>

    <span class="c1"># store the origin as the origin of the camera frame</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Rays</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">directions</span><span class="p">),</span> <span class="n">uv</span></div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>