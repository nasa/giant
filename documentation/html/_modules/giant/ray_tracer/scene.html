
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.ray_tracer.scene &#8212; GIANT 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.ray_tracer.scene</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 United States Government as represented by the Administrator of the National Aeronautics and Space</span>
<span class="c1"># Administration.  No copyright is claimed in the United States under Title 17, U.S. Code. All Other Rights Reserved.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides scene functionality for rendering in GIANT.</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">In GIANT, a scene is used to describe the location and orientation of objects with respect to each other and some</span>
<span class="sd">defined frame (usually the camera frame) at a given moment in time.  This then facilitates rendering multiple objects</span>
<span class="sd">in a scene, doing single bounce ray tracing to a light source, and other similar tasks. Additionally, the scene makes it</span>
<span class="sd">easy to tie functions that specify the location/orientation of an object at given times so that they can be used to</span>
<span class="sd">automatically place things in the scene at a requested image time.</span>

<span class="sd">Use</span>
<span class="sd">---</span>

<span class="sd">To use the scene in GIANT you simply create :class:`.SceneObject` instances for any targets and the light source for</span>
<span class="sd">your scene (currently only a single light source is allowed).  You then create a :class:`.Scene` around these objects.</span>
<span class="sd">This then gives you the ability to call the most commonly used methods of the scene :meth:`.Scene.trace` to trace rays</span>
<span class="sd">through all of the targets in the scene and :meth:`.Scene.get_illumination_inputs` to do a single bounce ray trace and</span>
<span class="sd">create the inputs required to estimate the intensity for each rendered ray using :mod:`.illumination`.</span>

<span class="sd">In general, besides initializing your :class:`.Scene` and :class:`.SceneObject` instances, you won&#39;t interact directly</span>
<span class="sd">with the scene classes much, as this is done for you in the rest of GIANT.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">giant.ray_tracer.rays</span> <span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span> <span class="nn">giant.rotations</span> <span class="kn">import</span> <span class="n">Rotation</span><span class="p">,</span> <span class="n">quaternion_inverse</span><span class="p">,</span> <span class="n">rotvec_to_rotmat</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.shapes</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Surface</span><span class="p">,</span> <span class="n">Ellipsoid</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span> <span class="nn">giant._typing</span> <span class="kn">import</span> <span class="n">Real</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span>
<span class="kn">from</span> <span class="nn">giant.camera_models</span> <span class="kn">import</span> <span class="n">CameraModel</span>
<span class="kn">from</span> <span class="nn">giant.image</span> <span class="kn">import</span> <span class="n">OpNavImage</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.illumination</span> <span class="kn">import</span> <span class="n">IlluminationModel</span><span class="p">,</span> <span class="n">ILLUM_DTYPE</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.rays</span> <span class="kn">import</span> <span class="n">INTERSECT_DTYPE</span>
<span class="kn">from</span> <span class="nn">giant.ray_tracer.utilities</span> <span class="kn">import</span> <span class="n">to_block</span>


<span class="n">SPEED_OF_LIGHT</span> <span class="o">=</span> <span class="mf">299792.458</span>  <span class="c1"># km/sec</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The speed of light in kilometers per second</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_SCAN_DIRS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A set of scan direction vectors for identifying the bounds of the body if supplied with a circumscribing sphere</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="CorrectionsType"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.CorrectionsType.html#giant.ray_tracer.scene.CorrectionsType">[docs]</a><span class="k">class</span> <span class="nc">CorrectionsType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This enumeration provides options for the different corrections that can be used when calculating the apparent</span>
<span class="sd">    position of an object in a scene</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NONE</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform not corrections</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LTPS</span> <span class="o">=</span> <span class="s2">&quot;lt+s&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform light time and stellar aberration corrections (default)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LT</span> <span class="o">=</span> <span class="s2">&quot;lt&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform only light time corrections.</span>
<span class="sd">    </span>
<span class="sd">    Note that this is not recommended because stellar aberration undoes much of the angular change imparted by light</span>
<span class="sd">    time only corrections.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform only stellar aberration corrections.</span>

<span class="sd">    Note that this is not recommended because light time undoes much of the angular change imparted by stellar </span>
<span class="sd">    aberration only corrections.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="SceneObject"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.html#giant.ray_tracer.scene.SceneObject">[docs]</a><span class="k">class</span> <span class="nc">SceneObject</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class provides a quick and easy interface for changing the position and orientation of various objects.</span>

<span class="sd">    Essentially, this class adds position and orientation attributes to shapes, rays, KDTrees, and other objects that</span>
<span class="sd">    can be translated and rotated.  It also adds optional orientation and position functions, which can be used to</span>
<span class="sd">    automatically set the position/orientation for this object at a given time using :meth:`place`.  This makes it much</span>
<span class="sd">    easier to perform frame transformations as the current frame&#39;s orientation and origin are stored with the object.</span>
<span class="sd">    The position and orientation are specified with respect to the</span>
<span class="sd">    default fixed frame for the object, which is usually [0, 0, 0] and eye(3) respectively.</span>

<span class="sd">    This class also provides 5 methods for updating the objects contained.</span>

<span class="sd">    * :meth:`change_position` - changes the position of the origin of the frame the object is expressed in.  This works</span>
<span class="sd">                                by first resetting the origin to 0 by subtracting off the previous origin, and then</span>
<span class="sd">                                setting the new origin at the specified location.  This is good when you are completely</span>
<span class="sd">                                changing the frame the object is expressed in.</span>
<span class="sd">    * :meth:`translate` - This is similar to :func:`change_position` but it does not first reset the origin to 0.  This</span>
<span class="sd">                          is good for making updates to the frame the object is expressed in.</span>
<span class="sd">    * :meth:`change_orientation` - Changes the orientation of the frame the object is expressed in by first</span>
<span class="sd">                                   resetting the orientation to be the identity matrix by rotating by the inverse</span>
<span class="sd">                                   transformation of the previous orientation, and then rotating to the new orientation</span>
<span class="sd">                                   specified.  This is good for when you are completely changing the frame the object is</span>
<span class="sd">                                   expressed in.</span>
<span class="sd">    * :meth:`rotate` - This is similar to :func:`change_orientation` but it does not first reset the orientation to the</span>
<span class="sd">                       identity.  This method is good for making updates to the frame the object is expressed in.</span>
<span class="sd">    * :meth:`place` - This automatically updates the orienation and position of the object based on the provided</span>
<span class="sd">                      :attr:`orientation_function` and :attr:`position_function`.  If either of these are still ``None``</span>
<span class="sd">                      then this will print a warning to the screen and do nothing</span>

<span class="sd">    Note that this class does not intelligently relate frames to each other, that must be done by the user.</span>

<span class="sd">    The following shows an example use of the SceneObj type.  First, we want to change the frame we have the rays</span>
<span class="sd">    expressed in.</span>

<span class="sd">    Start by doing your imports and setting up your ray in the camera frame:</span>

<span class="sd">        &gt;&gt;&gt; import giant.ray_tracer.rays as g_rays</span>
<span class="sd">        &gt;&gt;&gt; import giant.ray_tracer.scene as g_scene</span>
<span class="sd">        &gt;&gt;&gt; from giant.rotations import Rotation</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; ray = g_rays.Rays([0, 0, 0], [-1, 0, 0])</span>

<span class="sd">    Now, lets define a position and orientation function.  Here for demo purposes we&#39;ll just return constant values,</span>
<span class="sd">    though most commonly these are generated as spice function calls</span>

<span class="sd">        &gt;&gt;&gt; def position_function(date):</span>
<span class="sd">        ...     return numpy.array([-5, 6, 7])</span>
<span class="sd">        &gt;&gt;&gt; def orientation_function(date):</span>
<span class="sd">        ...     return Rotation([0.5, 2, -3.2])</span>

<span class="sd">    Now we can create our SceneObj around the ray:</span>

<span class="sd">        &gt;&gt;&gt; scene_obj = g_scene.SceneObject(ray, position_function=position_function,</span>
<span class="sd">        ...                                 orientation_function=orientation_function)</span>

<span class="sd">    Note here, that we are defining the default frame for the ray to be the current frame that it is in (the camera</span>
<span class="sd">    frame).  This means that whenever we want to **change** the frame (not update) for the rays we need to specify the</span>
<span class="sd">    new origin and orientation with respect to the camera frame.  Let&#39;s change our rays to some new frame:</span>

<span class="sd">        &gt;&gt;&gt; new_loc = [1, 2, 3]  # the new origin location expressed in the original frame</span>
<span class="sd">        &gt;&gt;&gt; new_orientation = [4, 5, 6]  # the new orientation of the new frame with respect to the original frame</span>

<span class="sd">    First, we&#39;ll update the origin of the frame (we are assuming that new_loc is expressed in the camera frame here):</span>

<span class="sd">        &gt;&gt;&gt; scene_obj.change_position(new_loc)</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.start)</span>
<span class="sd">        [ 1.  2.  3.]</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.direction)</span>
<span class="sd">        [ -1.  0.  0.]</span>

<span class="sd">    Now, we&#39;ll change the orientation:</span>

<span class="sd">        &gt;&gt;&gt; scene_obj.change_orientation(new_orientation)</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.start)</span>
<span class="sd">        [ 1.98283723  2.55366624  1.88338665]</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.direction)</span>
<span class="sd">        [ 0.42296095 -0.05284171 -0.90460588]</span>

<span class="sd">    Now lets say we want to update the current frame our ray is expressed in:</span>

<span class="sd">        &gt;&gt;&gt; update_pos = [0.05, -1, 0.2]  # where we want to move the current origin to expressed in the current frame</span>
<span class="sd">        &gt;&gt;&gt; scene_obj.translate(update_pos)</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.start)</span>
<span class="sd">        [ 2.03283723  1.55366624  2.08338665]</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.direction)</span>
<span class="sd">        [ 0.42296095 -0.05284171 -0.90460588</span>

<span class="sd">    Note how this was added to the current frame, not reset back from the original frame:</span>

<span class="sd">        &gt;&gt;&gt; update_orientation = [0.001, 0.001, 0.001]</span>
<span class="sd">        &gt;&gt;&gt; scene_obj.rotate(update_orientation)</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.start)</span>
<span class="sd">        [ 2.0323073   1.55371729  2.08386553]</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.direction)</span>
<span class="sd">        [ 0.42381181 -0.05416946 -0.90412898]</span>

<span class="sd">    Now, lets use the position function and orientation function we provided to update the rays position/orientation</span>
<span class="sd">    automatically</span>

<span class="sd">        &gt;&gt;&gt; scene_obj.place(datetime.datetime.utcnow())</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.start)</span>
<span class="sd">        [-5.  6.  7.]</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.direction)</span>
<span class="sd">        [ 0.75609837 -0.64204013 -0.12688471]</span>

<span class="sd">    And finally, lets say that we want to return our ray to the initial frame:</span>

<span class="sd">        &gt;&gt;&gt; scene_obj.change_position([0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; scene_obj.change_orientation(numpy.eye(3))</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.start)</span>
<span class="sd">        [ 0.  0.  0.]</span>
<span class="sd">        &gt;&gt;&gt; print(scene_obj.shape.direction)</span>
<span class="sd">        [ -1.  0.  0.]</span>

<span class="sd">    Typically when using the :attr:`position_function` and :attr:`orientation_function` these should give the position</span>
<span class="sd">    of the object relative to the solar system bary center in the inertial frame and the rotation from the object fixed</span>
<span class="sd">    frame to the inertial frame respectively.  This will then pair well with updating the scene to put everying in the</span>
<span class="sd">    camera frame if you also put the inertial camera position and rotation from the intertial frame to the camera frame</span>
<span class="sd">    on the :class:`.OpNavImage` as is typical.  You can conceivably work differently than this but it is then up to you</span>
<span class="sd">    to ensure all of your definitions are consistent.</span>

<span class="sd">    In addition to making it easy to move objects around in the scene, the :class:`.SceneObject` class also provides</span>
<span class="sd">    some useful methods for getting information about the object in the current scene.  This includes</span>
<span class="sd">    :meth:`get_bounding_pixels` which determines the extent of the object in the image (this only works once the object</span>
<span class="sd">    has been rotated/translated into the camera frame) and :meth:`get_apparent_diamter` which predicts the apparent</span>
<span class="sd">    diameter of the object in pixels in the image (this also only works once the object</span>
<span class="sd">    has been rotated/translated into the camera frame).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
                 <span class="n">current_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ARRAY_LIKE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">current_orientation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span><span class="p">,</span>
                 <span class="n">position_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">datetime</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">orientation_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">datetime</span><span class="p">],</span> <span class="n">Rotation</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">corrections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CorrectionsType</span><span class="p">]</span> <span class="o">=</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">LTPS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param shape: The shape that represents the object.  This is typically a subclass of :class:`.Shape`, but can be</span>
<span class="sd">                      anything so long as it implements ``translate``, ``rotate``, and ``trace`` methods.</span>
<span class="sd">        :param current_position: The current position of the object in the current frame.  If ``None`` then this will be</span>
<span class="sd">                                 assumed to be the origin.</span>
<span class="sd">        :param current_orientation: The current orientation of the object in the current frame.  If ``None`` then this</span>
<span class="sd">                                    will be assumed to be the identity rotation</span>
<span class="sd">        :param name: An identifying name for the object.  This is simply for logging/readability purposes</span>
<span class="sd">        :param position_function: A function which accepts a python datetime object and returns a 3 element array giving</span>
<span class="sd">                                  the position of the object at the requested time.  usually this should return the</span>
<span class="sd">                                  position of the object with respect to the solar system bary center in the inertial</span>
<span class="sd">                                  frame.  While this is not required, it is strongly encouraged in most cases</span>
<span class="sd">        :param orientation_function: A function which accepts a python datetime object and returns a :class:`.Rotation`</span>
<span class="sd">                                     that gives the orientation of the object at the requested time.  Usually this</span>
<span class="sd">                                     should return the rotation from the object fixed frame to the inertial frame.</span>
<span class="sd">                                     While this is not required, it is strongly encouraged in most cases</span>
<span class="sd">        :param corrections: What corrections to apply when calculating the apparent location of the object in the camera</span>
<span class="sd">                            frame.  This should either be ``None`` for no corrections, or one of the enums from</span>
<span class="sd">                            :data:`.CorrectionsType`, most typically :attr:`.CorrectionsTyps.LTPS` which applies light</span>
<span class="sd">                            time and stellar aberration corrections.  This is used by :class:`.Scene` and is only used</span>
<span class="sd">                            when the :attr:`position_function` and :attr:`orientation_function` are not ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">position_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">datetime</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="n">position_function</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function which accepts a python datetime object and returns a 3 element array giving</span>
<span class="sd">        the position of the object at the requested time.  </span>
<span class="sd">        </span>
<span class="sd">        Usually this should return the position of the object with respect to the solar system bary center in the </span>
<span class="sd">        inertial frame.  While this is not required, it is strongly encouraged in most cases</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orientation_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">datetime</span><span class="p">],</span> <span class="n">Rotation</span><span class="p">]]</span> <span class="o">=</span> <span class="n">orientation_function</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       A function which accepts a python datetime object and returns a :class:`.Rotation`</span>
<span class="sd">       that gives the orientation of the object at the requested time.  </span>
<span class="sd">       </span>
<span class="sd">       Usually this should return the rotation from the object fixed frame to the inertial frame.</span>
<span class="sd">       While this is not required, it is strongly encouraged in most cases</span>
<span class="sd">       &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corrections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CorrectionsType</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrections</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        What corrections to apply when calculating the apparent location of the object in the camera frame.  </span>
<span class="sd">        </span>
<span class="sd">        This should either be ``None`` for no corrections, or one of the enums from</span>
<span class="sd">        :data:`.CorrectionsType`, most typically :attr:`.CorrectionsTyps.LTPS` which applies light</span>
<span class="sd">        time and stellar aberration corrections.  This is used by :class:`.Scene` and is only used</span>
<span class="sd">        when the :attr:`position_function` and :attr:`orientation_function` are not ``None``. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">current_position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">current_position</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">current_orientation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">current_orientation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the object, used for logging purposes and readability.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Shape</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the shape of interest.</span>

<span class="sd">        It is usually a :class:`.Shape` or object but the only requirement is that it have</span>
<span class="sd">        translate and rotate methods.  Ideally it should also have a trace method, though this isn&#39;t checked.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;translate&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;rotate&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;The object must have translate and rotate attributes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the current position of this object as a flat length 3 array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span>

    <span class="nd">@position</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The position array must be of length three&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the current orientation of the frame this object is expressed in as a :class:`.Rotation` object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span>

    <span class="nd">@orientation</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span><span class="p">]):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># error checking is handled by Rotation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orientation</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="SceneObject.change_position"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.change_position.html#giant.ray_tracer.scene.SceneObject.change_position">[docs]</a>    <span class="k">def</span> <span class="nf">change_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_position</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the location of the object in the current frame.</span>

<span class="sd">        This is done by first subtracting off the old position then adding this value.</span>

<span class="sd">        To update the location instead of changing it see the :meth:`translate` method.</span>

<span class="sd">        :param new_position: The new location for the object in the frame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">old_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>

        <span class="c1"># error checking is handled by the position property setter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">new_position</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">old_position</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="SceneObject.change_orientation"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.change_orientation.html#giant.ray_tracer.scene.SceneObject.change_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_orientation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the orientation of the frame the object is expressed in.</span>

<span class="sd">        This is done by first applying the inverse rotation of the current orientation to get back to the base frame,</span>
<span class="sd">        and then applying the new orientation.  Note that we also update the orientation for the position vector in the</span>
<span class="sd">        same way.</span>

<span class="sd">        :param new_orientation: the new frame orientation to express the object and location in</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">previous_orientation</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">new_orientation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">previous_orientation</span><span class="o">.</span><span class="n">inv</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">)</span>

        <span class="c1"># update the orientation of the position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">quaternion_inverse</span><span class="p">(</span><span class="n">previous_orientation</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="SceneObject.translate"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.translate.html#giant.ray_tracer.scene.SceneObject.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span> <span class="n">ARRAY_LIKE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the location of the object in the current frame by adding a vector to the current location.</span>

<span class="sd">        :param translation: The vector to add to the current vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">trans_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">+=</span> <span class="n">trans_array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">trans_array</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have entered an improperly sized translation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Only length 3 translations are allowed.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;You entered a translation of length </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">translation</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SceneObject.rotate"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.rotate.html#giant.ray_tracer.scene.SceneObject.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">ARRAY_LIKE</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the orientation of the frame the object and its location are expressed in.</span>

<span class="sd">        :param rotation: how we are to rotate the current frame/location</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>

        <span class="c1"># update the orientation of the position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="SceneObject.get_bounding_pixels"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.get_bounding_pixels.html#giant.ray_tracer.scene.SceneObject.get_bounding_pixels">[docs]</a>    <span class="k">def</span> <span class="nf">get_bounding_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">temperature</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the bounding pixels for the given camera model and the current location.</span>

<span class="sd">        The bounding pixels are the pixel bounds which the scene predicts the target should be completely contained in.</span>
<span class="sd">        They are computed either by using the :attr:`.circumscribing_sphere` bounding sphere of the object if it is not</span>
<span class="sd">        ``None``, by make a circumscribing sphere if the object is an ellipsoid, or by projecting the bounding box</span>
<span class="sd">        vertices onto the image.  These are typically used to determine which pixels to trace for rendering the object</span>

<span class="sd">        This method assumes that the object has already been placed in the camera frame (the frame centered at the focus</span>
<span class="sd">        of the camera) with the z axis pointing perpendicular to the image plane.  If any of the assumptions are not met</span>
<span class="sd">        this method will return nonsense.</span>

<span class="sd">        :param model: The camera model that relates points in the 3d world to points on the image plane</span>
<span class="sd">        :param image: the index of the image that is being projected onto.  Can normally be ignored</span>
<span class="sd">        :param temperature: The temperature of the camera at the time we are trying to get the apparent diameter</span>
<span class="sd">        :return: The minimum (upper left) and maximum (lower right) pixel bounds that should contain the object based</span>
<span class="sd">                 off of the scene as a tuple of length 2 numpy arrays (min, max).  Note that these are inclusive bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">center</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">+</span><span class="mi">1</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">Ellipsoid</span><span class="p">):</span>
            <span class="n">cicum_sphere</span> <span class="o">=</span> <span class="n">Ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                     <span class="n">principal_axes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">principal_axes</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>

            <span class="n">limbs</span> <span class="o">=</span> <span class="n">cicum_sphere</span><span class="o">.</span><span class="n">find_limbs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">),</span> <span class="n">_SCAN_DIRS</span><span class="p">)</span>

            <span class="n">image_locs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">limbs</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                                                  <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="s1">&#39;circumscribing_sphere&#39;</span><span class="p">)</span> <span class="ow">and</span>
              <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="s1">&#39;circumscribing_sphere&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="n">limbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">circumscribing_sphere</span><span class="o">.</span><span class="n">find_limbs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">/</span>
                                                                 <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">),</span>
                                                                 <span class="n">_SCAN_DIRS</span><span class="p">)</span>

            <span class="n">image_locs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">limbs</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                                                  <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_locs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                                                  <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># noinspection PyArgumentList</span>
        <span class="k">return</span> <span class="n">image_locs</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">image_locs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="SceneObject.get_apparent_diameter"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.get_apparent_diameter.html#giant.ray_tracer.scene.SceneObject.get_apparent_diameter">[docs]</a>    <span class="k">def</span> <span class="nf">get_apparent_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">CameraModel</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="n">Real</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the apparent diameter for the given camera model and the current location.</span>

<span class="sd">        The apparent diameter is the be guess at how large the object should appear in the image based on the current</span>
<span class="sd">        scene and assuming a spherical approximation for the target. It is computed either by making a reference sphere</span>
<span class="sd">        by taking the mean of the principal axes of the :attr:`.Surface.reference_ellipsoid` best fit ellipsoid of the</span>
<span class="sd">        object if it is not ``None``, by making a reference sphere by taking the mean of the principal axes if the</span>
<span class="sd">        object is an ellipsoid, or by maxing a reference sphere using the average radius of the bounding box vertices of</span>
<span class="sd">        the target.</span>

<span class="sd">        This method assumes that the object has already be placed in the camera frame (the frame centered at the focus</span>
<span class="sd">        of the camera) with the z axis pointing perpendicular to the image plane.  If any of the assumptions are not met</span>
<span class="sd">        this method will return nonsense.</span>

<span class="sd">        :param model: The camera model that relates points in the 3d world to points on the image plane</span>
<span class="sd">        :param image: the index of the image that is being projected onto.  Can normally be ignored</span>
<span class="sd">        :param temperature: The temperature of the camera at the time we are trying to get the apparent diameter</span>
<span class="sd">        :return: The approximate apparent diameter of the object in pixels.  Note that if the contained object is a</span>
<span class="sd">                 :class:`.Point` this will always return 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">Ellipsoid</span><span class="p">):</span>

            <span class="n">ref_sphere</span> <span class="o">=</span> <span class="n">Ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                   <span class="n">principal_axes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">principal_axes</span><span class="o">.</span><span class="n">mean</span><span class="p">()]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="s1">&#39;reference_ellipsoid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_sphere</span> <span class="o">=</span> <span class="n">Ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                   <span class="n">principal_axes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">reference_ellipsoid</span><span class="o">.</span><span class="n">principal_axes</span><span class="o">.</span><span class="n">mean</span><span class="p">()]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we really should never get here, but if we do, this is probably a poor approximation..</span>
            <span class="n">ref_sphere</span> <span class="o">=</span> <span class="n">Ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">max_sides</span> <span class="o">-</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">min_sides</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># get the limbs from the reference sphere</span>
        <span class="n">limbs</span> <span class="o">=</span> <span class="n">ref_sphere</span><span class="o">.</span><span class="n">find_limbs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">),</span>
                                      <span class="n">_SCAN_DIRS</span><span class="p">)</span>

        <span class="c1"># project the limbs onto the image</span>
        <span class="n">image_locs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">project_onto_image</span><span class="p">(</span><span class="n">limbs</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
                                              <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>

        <span class="c1"># get the norm of the extent of the projected limbs to be the apparent diameter</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">image_locs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">image_locs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="SceneObject.place"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.SceneObject.place.html#giant.ray_tracer.scene.SceneObject.place">[docs]</a>    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="n">datetime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Place the object using the :attr:`orientation_function` and :attr:`position_function` at the requested date.</span>

<span class="sd">        This is done by calling the :attr:`orientation_function` and :attr:`position_function` with the input date and</span>
<span class="sd">        then calling methods :meth:`change_orientation` and :meth:`change_position` in order with the results from the</span>
<span class="sd">        function calls.  If either of the attributes are still None this method will print a warning and do nothing.</span>

<span class="sd">        :param date: The date we are to place the object at</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation_function</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">new_orientation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Attempted to place a SceneObject without an orientation_function&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_function</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_position</span><span class="p">(</span><span class="n">new_position</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Attempted to place a SceneObject without a position_function&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Scene"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.html#giant.ray_tracer.scene.Scene">[docs]</a><span class="k">class</span> <span class="nc">Scene</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a container for :class:`SceneObject` instances that provides an easy interface for tracing and rendering.</span>

<span class="sd">    This is most useful when you have multiple objects that you want to trace at once, as the scene will trace all of</span>
<span class="sd">    the objects for you, and choose the first intersection for each ray between all of the objects (if desired).</span>

<span class="sd">    This is also useful because it can calculate the apparent location of objects in the scene (if they have the</span>
<span class="sd">    :attr:`.position_function` and :attr:`.orientation_function` attributes defined) while applying corrections for</span>
<span class="sd">    light time and stellar aberration.  This can be done for all objects in a scene using method :meth:`update` or for</span>
<span class="sd">    individual object using :meth:`calculate_apparent_position`.  Any objects that do not define the mentioned</span>
<span class="sd">    attributes will likely not be placed correctly in the scene when using these methods and thus warnings will be</span>
<span class="sd">    printed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_objs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">],</span> <span class="n">SceneObject</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">light_obj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">obscuring_objs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param target_objs: The objects that are to be traced/rendered in a scene as a list of :class:`.SceneObject`.</span>
<span class="sd">        :param light_obj: The light object.  This is just used to track the position of the light, therefore it is</span>
<span class="sd">                          typically just a wrapper around a :class:`.Point`</span>
<span class="sd">        :param obscuring_objs: A list of objects that shouldn&#39;t be rendered but may be used externally from the scene</span>
<span class="sd">                               to identify whether targets are visible or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of digits that are required to represent the unique id of all objects contained in the scene</span>
<span class="sd">        </span>
<span class="sd">        This is used to comprise the facet number in the :data:`.INTERSECT_DTYPE` when tracing the scene such that the </span>
<span class="sd">        resulting id is</span>
<span class="sd">        </span>
<span class="sd">        .. code::</span>
<span class="sd">        </span>
<span class="sd">            [-target index-][---surface id---]</span>
<span class="sd">                            [------order-----]</span>
<span class="sd">                            </span>
<span class="sd">        where ``target index`` is the index into the :attr:`target_objs` list, ``surface id`` is the ID returned by the </span>
<span class="sd">        surface that the ray struck encoded in ``order`` digits (zero padded on the left).  This is also used when </span>
<span class="sd">        tracing to determine whether the :attr:`Rays.ignore` attribute applies to the object currently being traced.</span>
<span class="sd">        </span>
<span class="sd">        Typically users shouldn&#39;t need to worry about this too much since it is primarily handled entirely internal to </span>
<span class="sd">        the class</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_objs</span> <span class="o">=</span> <span class="n">target_objs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_obscuring_objs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obscuring_objs</span> <span class="o">=</span> <span class="n">obscuring_objs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_light_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light_obj</span> <span class="o">=</span> <span class="n">light_obj</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_objs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of objects to be tracked/rendered in the scene.</span>

<span class="sd">        This must be set before a call to :meth:`get_illumination_inputs`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span>

    <span class="nd">@target_objs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">target_objs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]]]):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SceneObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The target_objs property must be set as a list or SceneObject.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># update the order</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_objs</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;num_faces&quot;</span><span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">num_faces</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">id</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">obscuring_objs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of objects to be kept up to date with the scene but which are not actually used in the scene</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obscuring_objs</span>

    <span class="nd">@obscuring_objs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">obscuring_objs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]]]):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_obscuring_objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SceneObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obscuring_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obscuring_objs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The target_objs property must be set as a list or SceneObject.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">light_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An object describing the location of the light source in the scene.</span>

<span class="sd">        This must be set before a call to :meth:`get_illumination_inputs`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_light_obj</span>

    <span class="nd">@light_obj</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">light_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SceneObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_light_obj</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_light_obj</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The light_obj property must be set as a SceneObject or None.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Scene.phase_angle"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.phase_angle.html#giant.ray_tracer.scene.Scene.phase_angle">[docs]</a>    <span class="k">def</span> <span class="nf">phase_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes the phase angle between the observer, the target at ``target_index`` and the</span>
<span class="sd">        :attr:`light_obj`.</span>

<span class="sd">        The phase angle is define as the interior angle between the vector from the target to the light</span>
<span class="sd">        and the vector from the target to the observer.  The phase angle is computed as the arccos of the</span>
<span class="sd">        dot product of the unit vectors in these two directions, and is returned with units of radians.</span>

<span class="sd">        This method assumes that the scene has already been put in the observer frame,</span>
<span class="sd">        that is, the observer is located at the origin and the :attr:`light_obj` and the target</span>
<span class="sd">        are also defined with respect to that origin.</span>

<span class="sd">        The phase angle will always be between 0 and :math:`\pi` radians (0-180 degrees)</span>

<span class="sd">        :param target_index: the index into the :attr:`target_objs` list for which to compute the phase angle for</span>
<span class="sd">        :return: the phase angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the unit vector from the target to the light</span>
        <span class="n">line_of_sight_light</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_obj</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">line_of_sight_light</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">line_of_sight_light</span><span class="p">)</span>

        <span class="c1"># get the unit vector from the target to the observer</span>
        <span class="n">line_of_sight_observer</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">/</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">line_of_sight_light</span><span class="nd">@line_of_sight_observer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Scene.trace"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.trace.html#giant.ray_tracer.scene.Scene.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace_rays</span><span class="p">:</span> <span class="n">Rays</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trace trace_rays through the current scene and return the intersections with the objects in the scene for each</span>
<span class="sd">        ray (optionally only the first intersection for each ray).</span>

<span class="sd">        This method iterates through each object in the :attr:`target_objs` property and traces the ray through that</span>
<span class="sd">        object using the object&#39;s trace method.  The results from the tracing of each object are then reduced to only</span>
<span class="sd">        the first intersection for each ray.</span>

<span class="sd">        This method handles determining whether things are to be ignored for each target, as well as updating the</span>
<span class="sd">        ``facet`` component of the return to have the appropriate id (encoding the target number at the head of the id).</span>

<span class="sd">        This method returns a numpy array of shape (n,) where n is the number of rays traced with dtype</span>
<span class="sd">        :data:`.INTERSECT_DTYPE`.</span>

<span class="sd">        :param trace_rays:  The rays to be traced through the scene</span>
<span class="sd">        :return: a numpy structured array of the intersections for each ray.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_objs</span><span class="p">):</span>

            <span class="n">ignore_inds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">trace_rays</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ignore_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">ignore_inds</span> <span class="o">=</span> <span class="n">to_block</span><span class="p">(</span><span class="n">ignore_inds</span><span class="p">)</span>

                <span class="n">ignore_inds</span><span class="p">[</span><span class="n">ignore_inds</span> <span class="o">//</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">ignore_inds</span><span class="p">[</span><span class="n">ignore_inds</span> <span class="o">//</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">ignore_inds</span><span class="p">[</span><span class="n">ignore_inds</span> <span class="o">//</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">longfloat</span><span class="p">)</span> <span class="o">%</span>
                    <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

                <span class="n">ray_use</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">trace_rays</span><span class="p">)</span>

                <span class="n">ray_use</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="n">ignore_inds</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">ray_use</span> <span class="o">=</span> <span class="n">trace_rays</span>

            <span class="n">object_results</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">ray_use</span><span class="p">)</span>

            <span class="n">object_results</span><span class="p">[</span><span class="s2">&quot;facet&quot;</span><span class="p">][</span><span class="n">object_results</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">ind</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">object_results</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">INTERSECT_DTYPE</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_first</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">trace_rays</span><span class="p">)</span></div>

<div class="viewcode-block" id="Scene.get_illumination_inputs"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.get_illumination_inputs.html#giant.ray_tracer.scene.Scene.get_illumination_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">get_illumination_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace_rays</span><span class="p">:</span> <span class="n">Rays</span><span class="p">,</span>
                                <span class="n">return_intersects</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the required inputs for an illumination function to compute the illumination for each ray.</span>

<span class="sd">        This is done by performing a single bounce ray trace against all objects in the scene.  First, the rays as</span>
<span class="sd">        provided are traced into the scene, returning the first intersect with anything in :attr:`target_objs`.  Then,</span>
<span class="sd">        if the ray actually struck something, we trace from the intersect point toward the :attr:`light_obj` to see if</span>
<span class="sd">        the place we struck was shadowed or not.  Presuming it was not shadowed, the geometry of the single bounce ray</span>
<span class="sd">        trace is encoded into a numpy structured array with dtype :data:`.ILLUM_DTYPE` which can then be passed to the</span>
<span class="sd">        classes from the :mod:`.illumination` module to compute the intensity for each ray.</span>

<span class="sd">        If requested, this method also returns the results of the initial intersect (before the shadow bounce) as a</span>
<span class="sd">        structured numpy array with dtype :data:`.INTERSECT_DTYPE` which can be useful for determining if a ray didn&#39;t</span>
<span class="sd">        see anything because it was shadowed or because it didn&#39;t strike anything.  Both returns will be shape (n,)</span>
<span class="sd">        where n is the number of rays traced.</span>

<span class="sd">        :param trace_rays: The rays we are to compute the illumination inputs for</span>
<span class="sd">        :param return_intersects: A flag specifying whether the results of the initial trace should also be returned</span>
<span class="sd">        :return: A numpy array with shape (n,) and data type :data:`.ILLUM_DTYPE` and optionally a numpy array with</span>
<span class="sd">                 shape (n,) and data type :data:`.INTERSECT_DTYPE`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_objs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;both light_obj and target_objs must be set to get the illumination inputs&quot;</span><span class="p">)</span>

        <span class="c1"># trace through the scene to see if the rays hit anything</span>
        <span class="n">initial_intersect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">trace_rays</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">initial_intersect</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">illum_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">trace_rays</span><span class="o">.</span><span class="n">num_rays</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ILLUM_DTYPE</span><span class="p">)</span>
            <span class="n">illum_params</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">return_intersects</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">illum_params</span><span class="p">,</span> <span class="n">initial_intersect</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">illum_params</span>

        <span class="n">shadow_start</span> <span class="o">=</span> <span class="n">initial_intersect</span><span class="p">[</span><span class="n">initial_intersect</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]][</span><span class="s2">&quot;intersect&quot;</span><span class="p">]</span>

        <span class="n">shadow_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_obj</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="n">shadow_start</span>

        <span class="n">shadow_dir</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">shadow_dir</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">shadow_start</span> <span class="o">=</span> <span class="n">shadow_start</span> <span class="o">+</span> <span class="n">shadow_dir</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1e-15</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">shadow_start</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">shadow_rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">shadow_start</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">shadow_dir</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                           <span class="n">ignore</span><span class="o">=</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">initial_intersect</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]][</span><span class="s2">&quot;facet&quot;</span><span class="p">])</span>

        <span class="n">shadow_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">shadow_rays</span><span class="p">)</span>

        <span class="n">illum_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">trace_rays</span><span class="o">.</span><span class="n">num_rays</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ILLUM_DTYPE</span><span class="p">)</span>

        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="n">check</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">shadow_check</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">shadow_rays</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">trace_rays</span><span class="o">.</span><span class="n">num_rays</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">illum_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">shadow_rays</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                       <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">trace_rays</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">check</span><span class="p">][</span><span class="s2">&quot;normal&quot;</span><span class="p">]),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">check</span><span class="p">][</span><span class="s2">&quot;albedo&quot;</span><span class="p">]),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">check</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">illum_params</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">shadow_rays</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                               <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">trace_rays</span><span class="p">[</span><span class="n">check</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">check</span><span class="p">][</span><span class="s2">&quot;normal&quot;</span><span class="p">]),</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">check</span><span class="p">][</span><span class="s2">&quot;albedo&quot;</span><span class="p">]),</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">check</span><span class="p">])))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">illum_params</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">shadow_rays</span><span class="p">[</span><span class="o">~</span><span class="n">shadow_check</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()]</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                           <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">trace_rays</span><span class="p">[</span><span class="n">check</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">check</span><span class="p">][</span><span class="s2">&quot;normal&quot;</span><span class="p">]),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">initial_intersect</span><span class="p">[</span><span class="n">check</span><span class="p">][</span><span class="s2">&quot;albedo&quot;</span><span class="p">]),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">check</span><span class="p">])))</span>

        <span class="n">illum_params</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_intersects</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">illum_params</span><span class="p">,</span> <span class="n">initial_intersect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">illum_params</span></div>

<div class="viewcode-block" id="Scene.get_first"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.get_first.html#giant.ray_tracer.scene.Scene.get_first">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_first</span><span class="p">(</span><span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">traced_rays</span><span class="p">:</span> <span class="n">Rays</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This static method identifies the first intersection for each ray when there are more than 1 object in the</span>
<span class="sd">        scene.</span>

<span class="sd">        Each object in the scene is responsible for identifying the first intersection with itself for each ray.</span>
<span class="sd">        The scene is then responsible for identify which object was struck first which is handled by this method.</span>

<span class="sd">        This method works by considering the intersection for each ray with each object, and then finding the</span>
<span class="sd">        the intersection with the minimum distance between the ray and the camera.</span>

<span class="sd">        :param res: The first intersection for each ray with each :attr:`target_objs` in the scene as a numpy array with</span>
<span class="sd">                    dtype :data:`.INTERSECT_DTYPE` and shape (k,n) where k is ``len(self.target_objs)`` and n is the</span>
<span class="sd">                    number of rays</span>
<span class="sd">        :param traced_rays: The rays that these results pertain to</span>
<span class="sd">        :return: numpy array of shape (n) with the first intersect for each ray and data type :data:`.INTERSECT_DTYPE`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># nan_check = ~np.isnan(res[&quot;albedo&quot;]).all(axis=0).squeeze()</span>
        <span class="n">nan_check</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;check&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nan_check</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">min_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">min_ind</span><span class="p">[</span><span class="n">nan_check</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">traced_rays</span><span class="p">[</span><span class="n">nan_check</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span>
                                                         <span class="n">res</span><span class="p">[</span><span class="s2">&quot;intersect&quot;</span><span class="p">][:,</span> <span class="n">nan_check</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="n">min_ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_ind</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Scene.raster_render"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.raster_render.html#giant.ray_tracer.scene.Scene.raster_render">[docs]</a>    <span class="k">def</span> <span class="nf">raster_render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">illumination_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">IlluminationModel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                                       <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                                       <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the geometry for rendering a target using rasterization, not ray tracing.</span>

<span class="sd">        This is done by simply considering the geometry for each facet of a target based solely on the</span>
<span class="sd">        incidence/exidence/normal vectors for the facet.  This therefore does no occlusion or shadowing.</span>

<span class="sd">        This assumes that the scene has already been placed in the camera frame.</span>

<span class="sd">        The return is the numpy array with a dtype of :attr:`.ILLUM_DTYPE` that can be provided to an</span>
<span class="sd">        :mod:`.illumination` model and the center of each facet.</span>

<span class="sd">        This is experimental and probably shouldn&#39;t be used much.</span>

<span class="sd">        :raises ValueError: if the target is not represented by a tesselation (Surface)</span>

<span class="sd">        :param target_ind: The target index we are to render using rasterization</span>
<span class="sd">        :param illumination_model: The model we are using to convert the geometry into illumination values.  If this is</span>
<span class="sd">                                   not None then the illumination values are returned, rather than the illumination</span>
<span class="sd">                                   inputs.</span>
<span class="sd">        :return: Either the illumination inputs, the center of each facet, and the vertices of each facet in the camera</span>
<span class="sd">                 frame if ``illumination_model`` is ``None`` or the illumination values, the center of each facet</span>
<span class="sd">                 and the vertices of each facet in the camera frame if ``illumination_model`` is not ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_objs</span><span class="p">[</span><span class="n">target_ind</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">KDTree</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">shapes</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to rasterize targets that are not a surface&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># grab the normal vectors from the triangles in the camera frame</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">normals</span> <span class="o">@</span> <span class="n">target</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span>

        <span class="n">facets_camera</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">matrix</span><span class="nd">@shape</span><span class="o">.</span><span class="n">stacked_vertices</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># get the centers for each triangle</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">facets_camera</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># get the incidence vectors to each facet</span>
        <span class="n">incidence</span> <span class="o">=</span> <span class="n">centers</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_light_obj</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">incidence</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">incidence</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># get the exidence vectors from each facet</span>
        <span class="n">exidence</span> <span class="o">=</span> <span class="n">centers</span>
        <span class="n">exidence</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">illum_inp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ILLUM_DTYPE</span><span class="p">)</span>

        <span class="n">illum_inp</span><span class="p">[</span><span class="s1">&#39;exidence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">exidence</span>
        <span class="n">illum_inp</span><span class="p">[</span><span class="s1">&#39;incidence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">incidence</span>
        <span class="n">illum_inp</span><span class="p">[</span><span class="s1">&#39;albedo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># todo: use the albedo for the centers?</span>
        <span class="n">illum_inp</span><span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normals</span>
        <span class="n">illum_inp</span><span class="p">[</span><span class="s1">&#39;visible&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">illumination_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">illum_inp</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">facets_camera</span>

        <span class="n">illum_values</span> <span class="o">=</span> <span class="n">illumination_model</span><span class="p">(</span><span class="n">illum_inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">illum_values</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">facets_camera</span></div>

<div class="viewcode-block" id="Scene.update"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.update.html#giant.ray_tracer.scene.Scene.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span> <span class="n">corrections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CorrectionsType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method changes the scene to reflect the time specified by image optionally using corrections of</span>
<span class="sd">        &quot;LT&quot; (light time), &quot;S&quot; (stellar aberration&quot;, or &quot;LTPS&quot; (light time and aberration).</span>

<span class="sd">        :param image: The image from the camera you want to update the scene for as an :class:`.OpNavImage`</span>
<span class="sd">        :param corrections: A flag specifying which corrections to use or ``None`` to use the corrections specified for</span>
<span class="sd">                            each object in the scene.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># place the targets in the camera frame, optionally correcting for light time and stellar aberration</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">corrections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">use_corrections</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;corrections&#39;</span><span class="p">,</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">LTPS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_corrections</span> <span class="o">=</span> <span class="n">corrections</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_apparent_position</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">use_corrections</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuring_objs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obscuring_objs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">corrections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">use_corrections</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="s1">&#39;corrections&#39;</span><span class="p">,</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">LTPS</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">use_corrections</span> <span class="o">=</span> <span class="n">corrections</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_apparent_position</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">use_corrections</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">corrections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_corrections</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_obj</span><span class="p">,</span> <span class="s1">&#39;corrections&#39;</span><span class="p">,</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">LTPS</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_corrections</span> <span class="o">=</span> <span class="n">corrections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_apparent_position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">light_obj</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">use_corrections</span><span class="p">)</span></div>

<div class="viewcode-block" id="Scene.calculate_apparent_position"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.Scene.calculate_apparent_position.html#giant.ray_tracer.scene.Scene.calculate_apparent_position">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_apparent_position</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">OpNavImage</span><span class="p">,</span>
                                    <span class="n">corrections</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CorrectionsType</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calculates the apparent position of objects in the scene in the camera frame optionally correcting</span>
<span class="sd">        for &quot;LT&quot; (light time), &quot;S&quot; (stellar aberration&quot;, or &quot;LTPS&quot; (light time and aberration).  Corrections can only be</span>
<span class="sd">        applied to scene objects with position and orientation functions defined</span>

<span class="sd">        The target must be either specified in the inertial frame at the time of the image already or have</span>
<span class="sd">        a position function that places the object inertially when given a datetime</span>

<span class="sd">        Note that this method will update the target location in place to be in the camera frame instead of the inertial</span>
<span class="sd">        frame.</span>

<span class="sd">        :param target: The target to place in the camera frame.  Generally should be an SceneObject</span>
<span class="sd">        :param image: The index of the image from the camera you want to place to object in</span>
<span class="sd">        :param corrections: The corrections to be applied when calculating the apparent position (only applied to</span>
<span class="sd">                            scene objects with position and orientation functions defined)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># place the target inertially at the time specified for the image</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">observation_date</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># target.place(observation_date)</span>
            <span class="n">target</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">orientation_function</span><span class="p">(</span><span class="n">date</span><span class="p">))</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">corrections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">CorrectionsType</span><span class="o">.</span><span class="n">NONE</span> <span class="o">==</span> <span class="n">corrections</span><span class="p">):</span>

                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position_function</span><span class="p">(</span><span class="n">date</span><span class="p">)</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">position</span>

            <span class="k">elif</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">LTPS</span> <span class="o">==</span> <span class="n">corrections</span><span class="p">:</span>

                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">correct_light_time</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">position_function</span><span class="p">,</span>
                                                               <span class="n">image</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">correct_stellar_aberration</span><span class="p">(</span>
                    <span class="n">camera_to_target_inertial</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">velocity</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">LT</span> <span class="o">==</span> <span class="n">corrections</span><span class="p">:</span>

                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">correct_light_time</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">position_function</span><span class="p">,</span>
                                                               <span class="n">image</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">CorrectionsType</span><span class="o">.</span><span class="n">S</span> <span class="o">==</span> <span class="n">corrections</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>

                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">position_function</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">correct_stellar_aberration</span><span class="p">(</span><span class="n">camera_to_target_inertial</span><span class="p">,</span>
                                                                       <span class="n">image</span><span class="o">.</span><span class="n">velocity</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;not sure what you entered for corrections but we don&#39;t know how to do it so we&#39;re not&quot;</span>
                              <span class="s2">&quot;doing anything&quot;</span><span class="p">)</span>
                <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position_function</span><span class="p">(</span><span class="n">date</span><span class="p">)</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">position</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;You have specified a standard SceneObject which cannot be automatically placed</span><span class="se">\n</span><span class="s1">&#39;</span>
                          <span class="s1">&#39;We will assume that you know what you are doing and you have correctly placed this object</span><span class="se">\n</span><span class="s1">&#39;</span>
                          <span class="s1">&#39;for the current image but remember that you must update the inertial location of this </span><span class="se">\n</span><span class="s1">&#39;</span>
                          <span class="s1">&#39;object yourself whenever you change an image&#39;</span><span class="p">)</span>

            <span class="n">camera_to_target_inertial</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">position</span>

        <span class="c1"># change the position of the target in inertial space</span>
        <span class="n">target</span><span class="o">.</span><span class="n">change_position</span><span class="p">(</span><span class="n">camera_to_target_inertial</span><span class="p">)</span>

        <span class="c1"># rotate the target into the camera frame</span>
        <span class="n">target</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="correct_light_time"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.correct_light_time.html#giant.ray_tracer.scene.correct_light_time">[docs]</a><span class="k">def</span> <span class="nf">correct_light_time</span><span class="p">(</span><span class="n">target_location_inertial</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">datetime</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                       <span class="n">camera_location_inertial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">time</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct an inertial position to include the time of flight for light to travel between the target and the camera.</span>

<span class="sd">    This function iteratively calculates the time of flight of light between a target and a camera and then returns</span>
<span class="sd">    the relative vector between the camera and the target accounting for light time (the apparent relative vector) in</span>
<span class="sd">    inertial space.  This is done by passing a callable object for target location which accepts a python datetime</span>
<span class="sd">    object and returns the inertial location of the target at that time (this is usually a function wrapped around a</span>
<span class="sd">    call to spice).</span>

<span class="sd">    Note that this assumes that the units for the input are all in kilometers.  If they are not you will get unexpected</span>
<span class="sd">    results.</span>

<span class="sd">    :param target_location_inertial: A callable object which inputs a python datetime object and outputs the inertial</span>
<span class="sd">                                    location of the target at the given time</span>
<span class="sd">    :param camera_location_inertial: The location of the camera in inertial space at the time the image was captured</span>
<span class="sd">    :param time: The time the image was captured</span>
<span class="sd">    :return: The apparent vector from the target to the camera in inertial space</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time_of_flight</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">camera_location_inertial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">camera_location_inertial</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>

        <span class="n">target_location_reflect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">target_location_inertial</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">time_of_flight</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">time_of_flight_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">camera_location_inertial</span> <span class="o">-</span> <span class="n">target_location_reflect</span><span class="p">)</span> <span class="o">/</span> <span class="n">SPEED_OF_LIGHT</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">time_of_flight_new</span> <span class="o">-</span> <span class="n">time_of_flight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">):</span>
            <span class="n">time_of_flight</span> <span class="o">=</span> <span class="n">time_of_flight_new</span>
            <span class="k">break</span>

        <span class="n">time_of_flight</span> <span class="o">=</span> <span class="n">time_of_flight_new</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">target_location_inertial</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">time_of_flight</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span>
            <span class="n">camera_location_inertial</span><span class="p">)</span></div>


<div class="viewcode-block" id="correct_stellar_aberration_fsp"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.correct_stellar_aberration_fsp.html#giant.ray_tracer.scene.correct_stellar_aberration_fsp">[docs]</a><span class="k">def</span> <span class="nf">correct_stellar_aberration_fsp</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                   <span class="n">camera_velocity_inertial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct for stellar aberration using linear addition.</span>

<span class="sd">    Note that this only roughly corrects for the direction, it messes up the distance to the object, therefore you</span>
<span class="sd">    should favor the :func:`.correct_stellar_aberration` function which uses rotations and thus doesn&#39;t mess with the</span>
<span class="sd">    distance.</span>

<span class="sd">    Note that this assumes that the units for the input are all in kilometers and kilometers per secon.  If they are not</span>
<span class="sd">    you will get unexpected results.</span>

<span class="sd">    :param camera_to_target_position_inertial: The vector from the camera to the target in the inertial frame</span>
<span class="sd">    :param camera_velocity_inertial: The velocity of the camera in the inertial frame relative to the SSB</span>
<span class="sd">    :return: the vector from the camera to the target in the inertial frame corrected for stellar aberration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this is only good for adjusting the unit vector. Don&#39;t use if you need anything involving range</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">camera_to_target_position_inertial</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">camera_velocity_inertial</span> <span class="o">/</span> <span class="n">SPEED_OF_LIGHT</span><span class="p">)</span></div>


<div class="viewcode-block" id="correct_stellar_aberration"><a class="viewcode-back" href="../../../ray_tracer/scene/giant.ray_tracer.scene.correct_stellar_aberration.html#giant.ray_tracer.scene.correct_stellar_aberration">[docs]</a><span class="k">def</span> <span class="nf">correct_stellar_aberration</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                               <span class="n">camera_velocity_inertial</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct for stellar aberration using rotations.</span>

<span class="sd">    This works by computing the rotation about the aberation axis and then applying this rotation to the vector from the</span>
<span class="sd">    camera to the target in the inertial frame.  This is accurate and doesn&#39;t mess up the distance to the target.  It</span>
<span class="sd">    should therefore always be preferred to :func:`.correct_stellar_aberration_fsp`</span>

<span class="sd">    Note that this assumes that the units for the input are all in kilometers and kilometers per secon.  If they are not</span>
<span class="sd">    you will get unexpected results.</span>

<span class="sd">    :param camera_to_target_position_inertial: The vector from the camera to the target in the inertial frame</span>
<span class="sd">    :param camera_velocity_inertial: The velocity of the camera in the inertial frame relative to the SSB</span>
<span class="sd">    :return: the vector from the camera to the target in the inertial frame corrected for stellar aberration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">velocity_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">camera_velocity_inertial</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">velocity_mag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="n">aberration_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">,</span> <span class="n">camera_velocity_inertial</span> <span class="o">/</span> <span class="n">velocity_mag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">aberration_axis_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">aberration_axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">velocity_sin_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">aberration_axis_magnitude</span> <span class="o">/</span>
                              <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

        <span class="n">aberration_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">velocity_mag</span> <span class="o">*</span> <span class="n">velocity_sin_angle</span> <span class="o">/</span> <span class="n">SPEED_OF_LIGHT</span><span class="p">)</span>

        <span class="n">aberration_axis</span> <span class="o">/=</span> <span class="n">aberration_axis_magnitude</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">camera_to_target_position_inertial</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">aberration_axis</span> <span class="o">*</span> <span class="n">aberration_angle</span><span class="p">),</span>
                             <span class="n">camera_to_target_position_inertial</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">aberration_axis</span> <span class="o">*</span> <span class="n">aberration_angle</span><span class="p">),</span>
                             <span class="n">camera_to_target_position_inertial</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">camera_to_target_position_inertial</span></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021 United States Government.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>