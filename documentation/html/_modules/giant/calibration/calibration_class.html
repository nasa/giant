<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>giant.calibration.calibration_class &#8212; GIANT 2.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=3f530b75" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=aae3c237" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo" />
    
  </a>
</p>



<p class="blurb">A powerful API for Optical Navigation</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installing GIANT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../giant.html#indices">Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for giant.calibration.calibration_class</h1><div class="highlight"><pre>
<span></span>


<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a subclass of the :class:`.OpNav` class for performing stellar OpNav and camera calibration.</span>

<span class="sd">Interface Description</span>
<span class="sd">---------------------</span>

<span class="sd">In GIANT, calibration refers primarily to the process of estimating a model to map points in the 3D</span>
<span class="sd">world to the observed points in a 2D image.  This is done by estimating both a geometric (intrinsic)</span>
<span class="sd">:mod:`camera model &lt;.camera_models&gt;` along with an optional pointing alignment between the camera frame and the base</span>
<span class="sd">frame the knowledge of the camera attitude is tied to (for instance the spacecraft bus frame).  For both of these, we</span>
<span class="sd">use observations of stars to get highly accurate models.</span>

<span class="sd">The :class:`Calibration` class is the main interface for performing calibration in GIANT, and in general is all the user</span>
<span class="sd">will need to interact with.  It is a subclass of the :class:`.StellarOpNav` class and as such provides a very similar</span>
<span class="sd">interface with only a few additional features. It provides direct access to the :class:`.PointOfInterestFinder`,</span>
<span class="sd">:class:`.StarID`, :mod:`.stellar_opnav.estimators` objects, and :mod:`.calibration.estimators` objects and automatically</span>
<span class="sd">preforms the required data transfer between the objects for you.  To begin you simply provide the :class:`.Calibration`</span>
<span class="sd">constructor a :class:`.Camera` instance and a :class:`.CalibrationOptions` instance to configure the class with. You </span>
<span class="sd">can then use the :class:`Calibration` instance to perform all of the aspects of stellar OpNav and calibration with never </span>
<span class="sd">having to interact with the internal objects again.</span>

<span class="sd">For example, we could do something like the following (from the directory containing ``sample_data``):</span>

<span class="sd">    &gt;&gt;&gt; import pickle</span>
<span class="sd">    &gt;&gt;&gt; from giant.calibration import Calibration, CalibrationOptions</span>
<span class="sd">    &gt;&gt;&gt; from giant.rotations import Rotation</span>
<span class="sd">    &gt;&gt;&gt; with open(&#39;sample_data/camera.pickle&#39;, &#39;rb&#39;) as ifile:</span>
<span class="sd">    ...     camera = pickle.load(ifile)</span>
<span class="sd">    &gt;&gt;&gt; # Returns the identity to signify the base frame is the inertial frame</span>
<span class="sd">    &gt;&gt;&gt; def base_frame(*args):</span>
<span class="sd">    ...     return Rotation([0, 0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; cal_opts = CalibrationOptions</span>
<span class="sd">    &gt;&gt;&gt; cal_opts.alignment_base_frame_func = base_frame</span>
<span class="sd">    &gt;&gt;&gt; cal = Calibration(camera, options=cal_opts)</span>
<span class="sd">    &gt;&gt;&gt; cal.id_stars()  # id the stars for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.sid_summary()  # print out a summary of the star identification success for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_attitude()  # estimate an updated attitude for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_geometric_calibration()  # estimate an updated camera model</span>
<span class="sd">    &gt;&gt;&gt; cal.geometric_calibration_summary()  # print out a summary of the star identification success for each image</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_static_alignment()  # estimate the alignment between the camera frame and hte base frame</span>
<span class="sd">    &gt;&gt;&gt; cal.estimate_temperature_dependent_alignment()  # estimate the temperature dependent alignment</span>

<span class="sd">For a more general description of the steps needed to perform calibration, refer to the :mod:`.calibration` package.</span>
<span class="sd">For a more in-depth examination of the :class:`Calibration` class see the following API Reference.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Self</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.calibration</span><span class="w"> </span><span class="kn">import</span> <span class="n">estimators</span> <span class="k">as</span> <span class="n">est</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.stellar_opnav.stellar_class</span><span class="w"> </span><span class="kn">import</span> <span class="n">StellarOpNav</span><span class="p">,</span> <span class="n">StellarOpNavOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.camera</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant.rotations</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">giant.utilities.print_llt</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_llt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">giant._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">DatetimeLike</span><span class="p">,</span> <span class="n">EULER_ORDERS</span><span class="p">,</span> <span class="n">DOUBLE_ARRAY</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CalibrationOptions</span><span class="p">(</span><span class="n">StellarOpNavOptions</span><span class="p">):</span>
    
    <span class="n">alignment_base_frame_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DatetimeLike</span><span class="p">],</span> <span class="n">Rotation</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A callable object which returns the orientation of the base frame with respect  </span>
<span class="sd">    to the inertial frame the alignment of the camera frame is to be done with      </span>
<span class="sd">    respect to for a given date.                                                    </span>
<span class="sd">    </span>
<span class="sd">    This is used on calls to :meth:`estimate_static_alignment` and :meth`estimate_temperature_dependent_alignment` </span>
<span class="sd">    to determine the base frame the alignment is being done with respect to.  Typically this returns something like </span>
<span class="sd">    the spacecraft body frame with respect to the inertial frame (inertial to spacecraft body) or another camera </span>
<span class="sd">    frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">temperature_dependent_alignment_euler_order</span><span class="p">:</span> <span class="n">EULER_ORDERS</span> <span class="o">=</span> <span class="s2">&quot;xyz&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The order of euler angles to use for the temperature dependent alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">geometric_estimator_options</span><span class="p">:</span> <span class="n">est</span><span class="o">.</span><span class="n">GeometricEstimatorOptions</span> <span class="o">|</span> <span class="n">est</span><span class="o">.</span><span class="n">LMAEstimatorOptions</span> <span class="o">|</span> <span class="n">est</span><span class="o">.</span><span class="n">IterativeNonlinearLstSqOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The options to use to initialize the geometric estimator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">custom_geometric_estimator_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">est</span><span class="o">.</span><span class="n">GeometricEstimator</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A custom geometric camera model estimator class to use instead of one of the standard ones</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">geometric_estimator_type</span><span class="p">:</span> <span class="n">est</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">GeometricEstimatorImplementations</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">GeometricEstimatorImplementations</span><span class="o">.</span><span class="n">ITERATIVE_NONLINEAR_LSTSQ</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Which geometric estimator to use.</span>
<span class="sd">    </span>
<span class="sd">    For a custom implementation choose CUSTOM</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="Calibration">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.html#giant.calibration.calibration_class.Calibration">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Calibration</span><span class="p">(</span><span class="n">StellarOpNav</span><span class="p">,</span> <span class="n">CalibrationOptions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class serves as the main user interface for performing geometric camera calibration and camera frame attitude</span>
<span class="sd">    alignment.</span>

<span class="sd">    The class acts as a container for the :class:`.Camera`, :class:`.PointOfInterestFinder`, </span>
<span class="sd">    :mod:`.stellar_opnav.estimators`, :mod:`.calibration.estimators`, and :class:`.StarId` objects and also passes the </span>
<span class="sd">    correct and up-to-date data from one object to the other. In general, this class will be the exclusive interface to </span>
<span class="sd">    the mentioned objects and models for the user.</span>

<span class="sd">    This class provides a number of features that make doing stellar OpNav and camera calibration/alignment easy.  The</span>
<span class="sd">    first is it provides aliases to the image processing, star id, attitude estimation, calibration estimation, and</span>
<span class="sd">    alignment estimation objects. These aliases make it easy to quickly change/update the various tuning parameters that</span>
<span class="sd">    are necessary to make star identification and calibration a success. In addition to providing convenient access to</span>
<span class="sd">    the underlying settings, some of these aliases also update internal flags that specify whether individual images</span>
<span class="sd">    need to be reprocessed, saving computation time when you&#39;re trying to find the best tuning.</span>

<span class="sd">    This class also provides simple methods for performing star identification, attitude estimation, camera calibration,</span>
<span class="sd">    and aligment estimation after you have set the tuning parameters. These methods (:meth:`id_stars`,</span>
<span class="sd">    :meth:`sid_summary`, :meth:`estimate_attitude`, :meth:`estimate_geometric_calibration`, :meth:`geometric_calibration_summary`,</span>
<span class="sd">    :meth:`estimate_static_alignment`, and :meth:`estimate_temperature_dependent_alignment`) combine all of the</span>
<span class="sd">    required steps into a few simple calls, and pass the resulting data from one object to the next. They also store off</span>
<span class="sd">    the results of the star identification in the :attr:`queried_catalog_star_records`,</span>
<span class="sd">    :attr:`queried_catalog_image_points`, :attr:`queried_catalog_unit_vectors`, :attr:`extracted_image_points`,</span>
<span class="sd">    :attr:`extracted_image_illums`, :attr:`extracted_psfs`, :attr:`extracted_stats`, :attr:`extracted_snrs`,</span>
<span class="sd">    :attr:`unmatched_catalog_image_points`, :attr:`unmatched_image_illums`,</span>
<span class="sd">    :attr:`unmatched_psfs`, :attr:`unmatched_stats`, :attr:`unmatched_snrs`</span>
<span class="sd">    :attr:`unmatched_catalog_star_records`,</span>
<span class="sd">    :attr:`unmatched_catalog_unit_vectors`,</span>
<span class="sd">    :attr:`unmatched_extracted_image_points`,</span>
<span class="sd">    :attr:`matched_catalog_image_points`, :attr:`matched_image_illums`,</span>
<span class="sd">    :attr:`matched_psfs`, :attr:`matched_stats`, :attr:`matched_snrs`</span>
<span class="sd">    :attr:`matched_catalog_star_records`,</span>
<span class="sd">    :attr:`matched_catalog_unit_vectors_inertial`,</span>
<span class="sd">    :attr:`matched_catalog_unit_vectors_camera`, and</span>
<span class="sd">    :attr:`matched_extracted_image_points` attributes, enabling more advanced analysis to be performed external to the</span>
<span class="sd">    class.</span>

<span class="sd">    This class stores the updated attitude solutions in the image objects themselves, allowing you to directly</span>
<span class="sd">    pass your images from stellar OpNav to the :mod:`.relative_opnav` routines with updated attitude solutions. It also</span>
<span class="sd">    stores the estimated camera model in the original camera model itself, and store the estimated alignments in the</span>
<span class="sd">    :attr:`static_alignment` and :attr:`temperature_dependent_alignment` attributes. Finally, this class</span>
<span class="sd">    respects the :attr:`.image_mask` attribute of the :class:`.Camera` object, only considering images that are</span>
<span class="sd">    currently turned on.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera</span><span class="p">:</span> <span class="n">Camera</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">CalibrationOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param camera: The :class:`.Camera` object containing the camera model and images to be utilized</span>
<span class="sd">        :param options: The options dataclass to use to configure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># need to do this because of how the base class is set up</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">CalibrationOptions</span><span class="p">()</span>

        <span class="c1"># initialize the StellarOpNav super class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometric_estimator_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">est</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">GeometricEstimatorImplementations</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">geometric</span><span class="o">.</span><span class="n">get_estimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometric_estimator_type</span><span class="p">,</span> <span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometric_estimator_options</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_geometric_estimator_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;The custom_geometric_estimator_class must not be None if CUSTOM is chosen as the estimator type&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_geometric_estimator_class</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometric_estimator_options</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">static_alignment</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Rotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The estimated static alignment. </span>
<span class="sd">        </span>
<span class="sd">        This is set to None until :meth:`estimate_static_alignment` is called</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_dependent_alignment</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">est</span><span class="o">.</span><span class="n">TemperatureDependentResults</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The estimated temperature dependent alignment. </span>
<span class="sd">        </span>
<span class="sd">        This is set to None until :meth:`estimate_temperature_dependent_alignment` is called</span>
<span class="sd">        &quot;&quot;&quot;</span>
        

    <span class="c1"># update the model setter to also update the sid model</span>
    <span class="nd">@StellarOpNav</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># dispatch to the super setter</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geometric_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">est</span><span class="o">.</span><span class="n">GeometricEstimator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The estimator to use when estimating the geometric calibration</span>

<span class="sd">        This must implement the :class:`.GeometricEstimator` interface</span>

<span class="sd">        See the :mod:`~.calibration.estimators` documentation for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span>

    <span class="nd">@geometric_estimator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geometric_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">est</span><span class="o">.</span><span class="n">GeometricEstimator</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">est</span><span class="o">.</span><span class="n">GeometricEstimator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The geometric_estimator object must implement the GeometricEstimator interface&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span> <span class="o">=</span> <span class="n">val</span>

    <span class="c1"># ____________________________________________________METHODS________________________________________________</span>

<div class="viewcode-block" id="Calibration.estimate_geometric_calibration">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.estimate_geometric_calibration.html#giant.calibration.calibration_class.Calibration.estimate_geometric_calibration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_geometric_calibration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates an updated camera model using all stars identified in all images that are turned on.</span>

<span class="sd">        For each turned on image in the :attr:`camera` attribute, this method provides the :attr:`geometric_estimator`</span>
<span class="sd">        with the :attr:`matched_extracted_image_points`, the :attr:`matched_catalog_unit_vectors_camera`, and</span>
<span class="sd">        optionally the :attr:`matched_weights_picture` if :attr:`use_weights` is ``True``. The</span>
<span class="sd">        :meth:`~.GeometricEstimator.estimate` method is then called and the resulting updated camera model is stored</span>
<span class="sd">        in the :attr:`model` attribute.  Finally, the updated camera model is used to update the following:</span>

<span class="sd">        * :attr:`matched_catalog_image_points`</span>
<span class="sd">        * :attr:`queried_catalog_image_points`</span>
<span class="sd">        * :attr:`unmatched_catalog_image_points`</span>

<span class="sd">        For a more thorough description of the calibration estimation routines see the :mod:`.calibration.estimators.geometric`</span>
<span class="sd">        documentation.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method overwrites the camera model information in the :attr:`camera` attribute and</span>
<span class="sd">            does not save old information anywhere.  If you want this information saved be sure to store it yourself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reset things to make sure we don&#39;t mix information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># prepare the inputs</span>
        <span class="n">use_pois</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[]]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="n">use_vecs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[],</span> <span class="p">[]]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="n">l_big_weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DOUBLE_ARRAY</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[]]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="n">temperatures</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="n">pois</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">use_pois</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">pois</span>
            <span class="n">vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalog_unit_vectors_camera</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vecs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">use_vecs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_weights_picture</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">l_big_weights</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>

            <span class="n">temperatures</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">temperature</span>

        <span class="c1"># update the attributes for the geometric estimator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">:</span>
            <span class="n">big_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">l_big_weights</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">measurement_covariance</span> <span class="o">=</span> <span class="n">big_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">use_pois</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">camera_frame_directions</span> <span class="o">=</span> <span class="n">use_vecs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">temperatures</span> <span class="o">=</span> <span class="n">temperatures</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># do the estimation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">()</span>

        <span class="c1"># store the updated camera model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">overwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># update the catalog locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reproject_stars</span><span class="p">()</span></div>


<div class="viewcode-block" id="Calibration.estimate_static_alignment">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.estimate_static_alignment.html#giant.calibration.calibration_class.Calibration.estimate_static_alignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_static_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates a static (not temeprature dependent) alignment between a base frame and the camera frame</span>
<span class="sd">        over multiple images.</span>

<span class="sd">        This method uses the :attr:`alignment_base_frame_func` to retrieve the rotation from the inertial frame to the</span>
<span class="sd">        base frame the alignment is to be done with respect to for each image time. The inertial matched catalog unit</span>
<span class="sd">        vectors are then rotated into the base frame. Then, the matched image points-of-interest are converted to unit</span>
<span class="sd">        vectors in the camera frame. These 2 sets of unit vectors are then provided to the</span>
<span class="sd">        :func:`.static_alignment_estimator` optionally along with weights, to estimate the alignment between the frames.  </span>
<span class="sd">        The resulting alignment is returned as a :class:`.Rotation` object and assigned to the :attr:`static_alignment` </span>
<span class="sd">        attribute.</span>

<span class="sd">        Note that to do alignment, the base frame and the camera frame should generally be fixed with respect to one</span>
<span class="sd">        another.  This means that you can&#39;t do alignment with respect to something like the inertial frame in general,</span>
<span class="sd">        unless your camera is magically fixed with respect to the inertial frame.</span>

<span class="sd">        Generally, this method should be called after you have estimated the geometric camera model, because the</span>
<span class="sd">        geometric camera model is used to convert the observed pixel locations in the image to unit vectors in the</span>
<span class="sd">        camera frame (using :meth:`~.CameraModel.pixels_to_unit`).</span>

<span class="sd">        .. Note::</span>
<span class="sd">            This method will attempt to account for misalignment estimated along with the camera model when performing</span>
<span class="sd">            the estimation; however, this is not recommended. Instead, once you have performed your camera model</span>
<span class="sd">            calibration, you should consider resetting the camera model misalignment to 0 and then calling</span>
<span class="sd">            :meth:`estimate_attitude` before a call to this function.</span>
<span class="sd">            </span>
<span class="sd">        :return: The static alignment results as a :class:`.Rotation` from the base frame to the camera frame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare the inputs</span>
        <span class="n">base_uvecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cam_uvecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;the alignment base frame function must be specified to perform static alignment&quot;</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inertial_vecs</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalog_unit_vectors_inertial</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># rotate the inertial catalog directions into the base frame</span>
                <span class="n">rot_inertial2base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">)</span>

                <span class="n">base_uvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rot_inertial2base</span><span class="o">.</span><span class="n">matrix</span> <span class="o">@</span> <span class="n">inertial_vecs</span><span class="p">)</span>

                <span class="c1"># get the unit vectors in the camera frame using the camera model</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">image_points</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_extracted_image_points</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;The image points shouldn&#39;t be None if the unit vectors aren&#39;t None&quot;</span>
                <span class="n">cam_uvecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pixels_to_unit</span><span class="p">(</span><span class="n">image_points</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="n">image</span><span class="o">=</span><span class="n">ind</span><span class="p">))</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="n">inertial_weights</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_weights_inertial</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;The weights shouldn&#39;t be None if use_weights is set to True&quot;</span>
                    <span class="c1"># use the trace of the inertial weights</span>
                    <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">inertial_weights</span><span class="p">))</span>
                    
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">:</span>
            <span class="n">provided_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">provided_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># compute the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">static_alignment</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">static_alignment_estimator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">base_uvecs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">cam_uvecs</span><span class="p">),</span> <span class="n">provided_weights</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_alignment</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Calibration.estimate_temperature_dependent_alignment">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.estimate_temperature_dependent_alignment.html#giant.calibration.calibration_class.Calibration.estimate_temperature_dependent_alignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_temperature_dependent_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">est</span><span class="o">.</span><span class="n">alignment</span><span class="o">.</span><span class="n">temperature_dependent</span><span class="o">.</span><span class="n">TemperatureDependentResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method estimates a temperature dependent (not static) alignment between a base frame and the camera frame</span>
<span class="sd">        over multiple images.</span>

<span class="sd">        This method uses the :attr:`alignment_base_frame_func` to retrieve the rotation from the inertial frame to the</span>
<span class="sd">        base frame the alignment is to be done with respect to for each image time. Then, the rotation from the</span>
<span class="sd">        inertial frame to the camera frame is retrieved for each image from the</span>
<span class="sd">        :attr:`.Image.rotation_inertial_to_camera` attribute for each image (which is updated by a call to</span>
<span class="sd">        :meth:`estimate_attitude`).  These frame definitions are then provided to the</span>
<span class="sd">        :func:`.temperature_dependent_alignment_estimator` to estimate the temperature</span>
<span class="sd">        dependent alignment.  The estimated alignment is returned and can be queried for a specific temeprature</span>
<span class="sd">        using :func:`.evaluate_temperature_dependent_alignment`.  It is also stored in the </span>
<span class="sd">        :attr:`temperature_dependent_alignment` attribute.</span>
<span class="sd">        </span>
<span class="sd">        Note that to do alignment, the base frame and the camera frame should generally be fixed with respect to one</span>
<span class="sd">        another (with the exception of small variations with temperature).  This means that you can&#39;t do alignment with</span>
<span class="sd">        respect to something like the inertial frame in general, unless your camera is magically fixed with respect to</span>
<span class="sd">        the inertial frame.</span>

<span class="sd">        Generally, this method should be called after you have estimated the attitude for each image, because the</span>
<span class="sd">        estimated image pointing is used to estimate the alignment.  As such, only images where there are successfully</span>
<span class="sd">        matched stars are used in the estimation.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            This method will attempt to account for misalignment estimated along with the camera model when performing</span>
<span class="sd">            the estimation; however, this is not recommended. Instead, once you have performed your camera model</span>
<span class="sd">            calibration, you should consider resetting the camera model misalignment to 0 and then calling</span>
<span class="sd">            :meth:`estimate_attitude` before a call to this function.</span>
<span class="sd">            </span>
<span class="sd">        :return: The temeprature dependent alignment as linear (in temperature) euler angle equations in radians to go from</span>
<span class="sd">                 the base frame to the camera frame </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;the alignment base frame function must be specified to perform temperature_dependent_alignment&quot;</span>

        <span class="c1"># prepare the inputs</span>
        <span class="n">base_frame_rotations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Rotation</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">camera_frame_rotations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Rotation</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">temperatures</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="c1"># only consider images where we have matched stars</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_catalog_unit_vectors_inertial</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># rotate the inertial catalog directions into the base frame</span>
                <span class="n">base_frame_rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alignment_base_frame_func</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">observation_date</span><span class="p">))</span>

                <span class="c1"># get the unit vectors in the camera frame using the camera model</span>
                <span class="n">camera_rotation</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">rotation_inertial_to_camera</span>
                <span class="c1"># handle the misalignment if it exists</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;get_misalignment&#39;</span><span class="p">):</span>
                    <span class="n">camera_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">camera</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_misalignment</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">camera_rotation</span> <span class="c1"># type: ignore</span>

                <span class="n">camera_frame_rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camera_rotation</span><span class="p">)</span>

                <span class="n">temperatures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature_dependent_alignment</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">temperature_dependent_alignment_estimator</span><span class="p">(</span><span class="n">base_frame_rotations</span><span class="p">,</span> <span class="n">camera_frame_rotations</span><span class="p">,</span> <span class="n">temperatures</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature_dependent_alignment_euler_order</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature_dependent_alignment</span></div>



<div class="viewcode-block" id="Calibration.reset_geometric_estimator">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.reset_geometric_estimator.html#giant.calibration.calibration_class.Calibration.reset_geometric_estimator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_geometric_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets the existing calibration estimator instance with a new instance using the initial</span>
<span class="sd">        settings provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">reset_settings</span><span class="p">()</span></div>


<div class="viewcode-block" id="Calibration.update_geometric_estimator">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.update_geometric_estimator.html#giant.calibration.calibration_class.Calibration.update_geometric_estimator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_geometric_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometric_estimator_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">est</span><span class="o">.</span><span class="n">GeometricEstimatorOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates the attributes of the :attr:`geometric_estimator` attribute.</span>
<span class="sd">        </span>
<span class="sd">        Note that to update only specific settings it is best to initialize the settings structure with </span>
<span class="sd">        `update = cal.geometric_estimator.original_options.copy()` and then modify the specific attributes</span>

<span class="sd">        :param geometric_estimator_update: An instance of the GeometricEstimatorOptions or a subclass to update settings with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">geometric_estimator_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geometric_estimator_update</span><span class="o">.</span><span class="n">apply_options</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="p">)</span></div>


<div class="viewcode-block" id="Calibration.reset_settings">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.reset_settings.html#giant.calibration.calibration_class.Calibration.reset_settings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method resets all settings to their initially provided values (at class construction)</span>

<span class="sd">        Specifically, the following are reset</span>

<span class="sd">        * :attr:`star_id`</span>
<span class="sd">        * :attr:`point_of_interest_finder`</span>
<span class="sd">        * :attr:`attitude_estimator`</span>
<span class="sd">        * :attr:`geometric_estimator`</span>
<span class="sd">        </span>
<span class="sd">        along with direct attributes of the class</span>

<span class="sd">        This is simply a shortcut to calling the ``reset_XXX``` methods individually.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset_settings</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_star_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_attitude_estimator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_geometric_estimator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_point_of_interest_finder</span><span class="p">()</span></div>


<div class="viewcode-block" id="Calibration.geometric_calibration_summary">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.geometric_calibration_summary.html#giant.calibration.calibration_class.Calibration.geometric_calibration_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">geometric_calibration_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measurement_covariance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="n">DOUBLE_ARRAY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This prints a summary of the results of calibration to the screen</span>

<span class="sd">        The resulting summary displays the labeled covariance matrix, followed by the labeled correlation coefficients,</span>
<span class="sd">        followed by the state parameters and their formal uncertainty.</span>

<span class="sd">        One optional inputs can be used to specify the uncertainty on the measurements if weighted estimation wasn&#39;t</span>
<span class="sd">        already used to ensure the post-fit covariance</span>
<span class="sd">        has the proper scaling.</span>

<span class="sd">        Note that if multiple misalignments were estimated in the calibration, only the first is printed in the</span>
<span class="sd">        correlation and covariance matrices.  For all misalignments, the values are replaced with NaN.</span>

<span class="sd">        :param measurement_covariance: The covariance for the measurements either as a nxn matrix or as a scalar.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">measurement_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">weighted_estimation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometric_estimator</span><span class="o">.</span><span class="n">measurement_covariance</span> <span class="o">=</span> <span class="n">measurement_covariance</span>
            <span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometric_estimator</span><span class="o">.</span><span class="n">postfit_covariance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometric_estimator</span><span class="o">.</span><span class="n">postfit_covariance</span>
            
        <span class="k">assert</span> <span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;estimate_geometric_calibration must be called before geometric_calibration_summary&quot;</span>

        <span class="c1"># get the uncertainty for each parameter</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariance</span><span class="p">))</span>

        <span class="c1"># compute the correlation coefficients</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">covariance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariance</span><span class="p">))]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># get the labels for each element</span>
        <span class="n">labels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_state_labels</span><span class="p">()</span> 

        <span class="c1"># if misalignment is in labels we need to do some fancy manipulation</span>
        <span class="k">if</span> <span class="s1">&#39;misalignment&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;misalignment&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;align_x&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;align_y&#39;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;align_z&#39;</span><span class="p">)</span>

        <span class="c1"># print the covariance matrix</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance:&#39;</span><span class="p">)</span>
        <span class="n">print_llt</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span>

        <span class="c1"># print the correlation coefficient matrix and get the maximum label size</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Correlation coefficients:&#39;</span><span class="p">)</span>
        <span class="n">max_label</span> <span class="o">=</span> <span class="n">print_llt</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>

        <span class="c1"># build the format strings for the parameter/formal uncertainty pairs</span>
        <span class="n">label_format</span> <span class="o">=</span> <span class="s1">&#39;{:&lt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s}&#39;</span>
        <span class="n">number_format</span> <span class="o">=</span> <span class="s1">&#39;{:&gt;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_label</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;e}&#39;</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">label_format</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">number_format</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">number_format</span>
        <span class="n">state_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_vector</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parameter value and formal uncertainty:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;align&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">state_vector</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">sigmas</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span></div>


<div class="viewcode-block" id="Calibration.limit_magnitude">
<a class="viewcode-back" href="../../../calibration/calibration_class/giant.calibration.calibration_class.Calibration.limit_magnitude.html#giant.calibration.calibration_class.Calibration.limit_magnitude">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">limit_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_magnitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_magnitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes stars from the ``matched_...`` attributes that are not within the provided magnitude bounds.</span>

<span class="sd">        This method should be used rarely, as you can typically achieve the same functionality by use the</span>
<span class="sd">        :attr:`.StarID.max_magnitude` and :attr:`.StarID.min_magnitude` attributes before calling :meth:`id_stars`.  The</span>
<span class="sd">        most typical use case for this method is when you have already completed a full calibration and you now either</span>
<span class="sd">        want to filter out some of the stars for plotting purposes, or you want to filter out some of the stars to do an</span>
<span class="sd">        alignment analysis, where it is generally better to use only well exposed stars since fewer are needed to</span>
<span class="sd">        fully define the alignment.</span>

<span class="sd">        When you use this method, by default it will edit and return a copy of the current instance to preserve the</span>
<span class="sd">        current instance.  if you are using many images with many stars in them this can use a large amount of memory;</span>
<span class="sd">        however, so you can optionally specify ``in_place=True`` to modify the current instance in place.  Note however</span>
<span class="sd">        that this not a reversible operation (that is you cannot get back to the original state) so be cautious about</span>
<span class="sd">        using this option.</span>

<span class="sd">        :param min_magnitude: The minimum star magnitude to accept (recall that minimum magnitude limits the brightest</span>
<span class="sd">                              stars)</span>
<span class="sd">        :param max_magnitude: The maximum star magnitude to accept (recall that maximum magnitude limits the dimmest</span>
<span class="sd">                              stars)</span>
<span class="sd">        :param in_place: A flag specifying whether to work on a copy or the original</span>
<span class="sd">        :return: The edited Calibration instance (either a copy or a reference)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">camera</span><span class="p">:</span>
            <span class="c1"># test which stars don&#39;t meet the requirements</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">matched_records</span> <span class="o">:=</span> <span class="n">out</span><span class="o">.</span><span class="n">matched_catalog_star_records</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mag_test</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched_records</span><span class="o">.</span><span class="n">mag</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">max_magnitude</span><span class="p">)</span> <span class="o">|</span> \
                           <span class="p">(</span><span class="n">matched_records</span><span class="o">.</span><span class="n">mag</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">min_magnitude</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mag_test</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mag_test</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                    <span class="n">out</span><span class="o">.</span><span class="n">remove_matched_stars</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">indicies</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>

</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
<div class="footer">
    <div style="display:inline-block;vertical-align:middle;">
        <img src="/_static/NASA_logo.svg" alt="NASA" style="width:80px;height:80px;">
    </div>
    <div style="display:inline-block;vertical-align:middle;">
        &copy;2023 United States Government | 
        NASA Official: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a> |
        Curator: <a href="mailto:andrew.j.liounis@nasa.gov">Andrew Liounis</a>
        <br>
        Last updated on Sep 03, 2025 |
        
        |
        Powered by <a href="http://sphinx-doc.org/">Sphinx 8.2.3</a>
        &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 1.0.0</a>
        
        |
        <a href="https://www.nasa.gov/about/highlights/HP_Privacy.html">Privacy Policy/Notices</a>
    </div>
</div>
  </body>
</html>